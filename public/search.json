[{"title":"开启新的旅程！","date":"2020-12-14T09:33:41.000Z","url":"/2020/12/14/%E5%BC%80%E5%90%AF%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"转眼间，从我搭建第一个博客已经过去了一年，服务器到期，现在将博客转移到了github下进行托管，在此对对本博客做出贡献的大家说声谢谢！，现在本博客失去了投稿功能，但是我们还是能在评论区相见！域名我会续费，还请大家持续关注starydy.xyz，关注Star Blog！ 谢谢大家！ 以下是测试！ 成功啦o(*￣▽￣*)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠框的标题 被折叠的内容 1被折叠的内容 2 面板框的标题 面板里的内容 1面板里的内容 2 "},{"title":"毕设开坑，欢迎大家关注","date":"2020-11-28T23:14:00.000Z","url":"/2020/11/29/%E6%AF%95%E8%AE%BE%E5%BC%80%E5%9D%91%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"好久没更新，这次开了毕设坑，欢迎大家关注我的github项目：SSVIO"},{"title":"从支持向量机到拉格朗日乘子对偶问题","date":"2020-09-17T19:11:00.000Z","url":"/2020/09/18/%E4%BB%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"很早以前就在林哥那儿听过支持向量机这个神奇的名字，是用来识别（分类）装甲板数字的，当时觉得很高深，很硬核。最近在研读周志华老师所著的《机器学习》，又看到了这个熟悉而又陌生的名词——支持向量机。这次终于能够更深入地了解它了。写此文章来记录。 支持向量机首先考虑一个二分类问题，我们有一组有标记的样本，分布在样本空间中，假设是一个二维的样本空间，那么它们看起来可能是这样的：其中我们可以认为三角代表正类而圆圈代表反类。怎样找到一条直线能够最大程度上地区分正类和反类呢？很容易想到我们需要一条直线（超平面），使它的一侧全是正类，另一侧全是反类。这种情况叫做线性可分的情况，等一会儿我们会讨论基本线性可分与非线性情况。不过这样的直线（超平面）有很多，哪一条更好呢？这里的更好代表着对于新来的样本也能有很好的划分能力，所以我们启发式地想，找一条能够划分样本，并且两边样本到直线最近距离最大且相等的直线。这些据直线最近的样本的位置（向量）就叫做支持向量。用更严谨的数学表示就是：不要忘记我们能够划分样本的条件：细心的我们可以发现，我们定义的这个直线理应具有dim(w)个自由度，而实际上却有dim(w)+1个参数（别忘了截距b），我们很容易想到，同时放大缩小w与b，直线是不变的，但是对于直线wx+b=1，却是在变化的，因此我们仅仅优化|w|²看似不合理，实际上整条直线已经在条件中进行了限制，所以b也会被考虑进去的。 于是我们使用支持向量机把二分类模型训练问题转化为了一个带不等式约束的优化问题。我们知道对于等式约束的优化问题我们可以用拉格朗日乘子法进行解决，但是对于不等式约束，我们又该怎样解决呢？我们称这个优化问题为原始问题，解决办法就是使用拉格朗日乘子法找到一个对偶问题，解决对偶问题并且在满足KKT条件的情况下，我们就能解决原始问题。那么具体怎么做呢？首先还是使用拉格朗日乘子法，找到拉格朗日函数：为了把不等式约束消解掉，我们分情况讨论：如果求得的直线不满足不等式约束，则L取得max只需要α-&gt;∞，就有：如果满足不等式约束，则有L取得max发生在α=0的情况下，即：所以我们把不等式约束的优化问题化为双重最值的优化问题：根据对偶原理，它的对偶问题为：同时还要满足KKT条件：解得最终的超平面为：（具体方法略）我们还得到一个结论，就是最终发挥作用的样本点只有支持向量，这点我们也能直观地感受到。 还有一些没解决的问题上面一节我们只讨论了线性可分的情况，如果遇到基本上线性可分的情况（有有限个点被分错），或者非线性可分的情况我们该怎么办呢？ 1.软间隔法对于基本上线性可分的情况，我们可以改进优化参数，使其允许一些错误出现，但是要尽最大可能避免这些错误，比如这样：在优化函数中引入惩罚项，惩罚那些超过界限的样本点。2.核方法对于非线性的方法，软间隔就不能用了，比如这种情况：但是我们可以使用一个映射将样本转换到另一个空间中这样就能解决非线性可分的问题了。"},{"title":"第二次硬件尝试之开关电源","date":"2020-09-12T19:45:00.000Z","url":"/2020/09/13/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A1%AC%E4%BB%B6%E5%B0%9D%E8%AF%95%E4%B9%8B%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"为了能使树莓派脱离有线的束缚，我这次就做一个简单的锂电池充放电电路来练练手(●ˇ∀ˇ●)（第一次做了更为简单的STM32-UARTHUB）电源芯片选择的是珠海智融科技有限公司的SW6124，SW6124是一款高度集成的电源管理IC，适用于快速充电移动电源应用。 它集成了4A开关充电器，18W同步升压，PD / QC / FCP / PE / SFCP快速充电协议，电量计和电源控制器。 SW6124借助简单的外部组件，为快速充电电池管理提供了交钥匙的高效解决方案。 手册最后给出了电池管理充放电应用电路图：已经比较符合我们的需求了，我们在其之上稍作更改，去掉了USB-A和Micro USB的接口，仅保留USB Type-C接口。并且使用一个单刀双置开关切换USB供电与电池供电。原理很简单，在插入USB TypeC时，使用开关将5V输出直接与TypeC电源连接，直接向树莓派供电，与此同时，TypeC电源也向电池充电。在未插入USB时，使5V输出与Boost电路输出端相连接，使用电池进行供电。画出原理图：TypeC接口部分；开关，树莓派插针部分；芯片电量显示部分；芯片Boost电路（3.7V-&gt;5V）及控制部分。这个电路最重要的部分就是开关电源部分，好在SW6124集成了开关管以及控制电路，我们只需要外加一个电感就能实现Boost升压的功能。 最后就是PCB绘制：首先进行布局布线。简单的PCB布局可以按照原理图的分布进行，并且要合理设计接口位置，注意芯片手册上的说明和注意事项。布线过程中注意根据线所流经的电流大小调整线的粗细，上层下层横纵交错，GND网络使用覆铜进行连接。 接下来是覆铜。对于信号要求较高的板子，最好分离信号地与电源地，并且在覆铜结束后检查是否留有未接通的GND网络，进行微调（比如打过孔）。最终一个简单的锂电池充放电电路板就绘制完成了，接下来就是焊接和调试啦！"},{"title":"ROS入门","date":"2020-08-28T06:08:00.000Z","url":"/2020/08/28/ROS%E5%85%A5%E9%97%A8/","categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"进入大四，终于要开启我的ROS之旅。接触了几天ROS，越发发觉它的便利，今天来记录一下最基础的ROS操作。（大部分来自ROS官网，俗话说官网是学习的最佳路径） ROS项目管理机制ROS使用Workspace+Package的方式来管理一个项目。比如以一个机器人为例，机器人的每一个功能（比如传感器数据接收，运动控制，导航感知，决策）都会对应一个Package，这些Package之间可能互相依赖，他们共同构成一个Workspace，就构成了这个机器人整体。从零开始构建一个项目，首先需要构建一个Workspace，使用： 在家目录构建一个空的，名为catkin_ws的Workspace，使用catkin_make可以自动生成一些所需的配置文件和目录（这个命令也充当着ROS管理工程中CMake的作用）。如果想让ROS命令认识这个包，需要把他的位置加入到环境变量中去，这时我们就需要使用source（用来执行命令行脚本）执行～/catkin_ws/devel/中的 setup.bash命令了。这时$ROS_PACKAGE_PATH变量就包含了我们的工作区/src/目录。如果想要使用官方的一些Package，他们的初始化脚本是/opt/ros//setup.bash。（也可将其放入~/.bashrc中，在启动终端后自动执行）对ROS的Package的一些操作： 如何创建一个Package？一个Package由一个独立的文件夹内的package.xml和一个CMakeists.txt文件（以及其他必要文件）组成，如下所示： 如何自动创建这些文件？在~/catkin_ws/src目录中使用 创建一个依赖于dependx的Package。使用 build这个Workspace（内的所有Package），并且将其（内的所有Package）加入环境变量。 这些Package都有着各自（直接）依赖的Package，catkin_create_pkg命令中的dependx会体现在package.xml中。直接的依赖Package使用以下命令查看：$ rospack depend1 [Package name]间接的依赖Package使用以下命令查看：$ rospack depends [Package name]对于你自己的项目，可以通过修改package.xml和CMakeLists.txt来进行定制化的操作。（详细略） 就如同CMake管理的项目一样，ROS管理的项目使用catkin_make进行项目的编译构建。在～/catkin_ws/中使用： 这个命令会build整个Workspace下的所有Package，与cmake命令有相同作用。 ROS通信机制 1##ROS不仅为我们提供了一种项目管理的功能，还提供了一种便利的多进程通讯机制。要启用这个多进程通讯机制，首先我们要启动ROS内核，使用： 这个roscore进程是ROS进程间通讯的核心，起到了中继站的作用。一切ROS应用都少不了它。ROS中，node代表一个可以进行通讯的节点，使用以下命令查看node属性： 使用rosrun来运行一个Package中的node。 node之间通讯是通过node-msg-topic机制，两个或多个node向同一个topic发送消息msg，并接收其他node的特定的消息msg，就能实现通讯。使用以下命令可以图形化查看当前运行中的node和topic： 为了查看运行中topic中传递的数据和一些其他信息，使用： 手动上传msg到指定的topic，使用： （注意，我们在命令行中使用的一些命令也是通过创建节点来实现功能的） ROS通信机制 2##除了node-msg-topic的通信方式，我们还可以通过service实现通信。rosservice的基本使用方法： 总而言之，每个Package会包含一些service，使用rosservice call可以调用这些service（可以理解为调用方法），实现某些功能。 使用rosparam可以存储某个Package参数，调整Package的功能： 使用图形化界面管理ROS，使用如下命令： 使用.launch文件一键启动整个项目： 使用rosed进行编辑： 创建Package_dir/msg/Num.msg文件，来规定传递的msg。创建Package_dir/srv/AddTwoInts.srv文件，来规定service的类型。（需要在package.xml和CMakeists.txt声明该文件） 最后，我们可以在C++程序中使用ROS的库来实现msg和service的操作。（对于我们添加的msg和srv，make后会自动生成对应的头文件，便于对其进行操作） "},{"title":"利用ANSYS进行叶轮动态流场仿真分析实例","date":"2020-08-15T07:37:05.000Z","url":"/2020/08/15/%E5%88%A9%E7%94%A8ANSYS%E8%BF%9B%E8%A1%8C%E5%8F%B6%E8%BD%AE%E5%8A%A8%E6%80%81%E6%B5%81%E5%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"大家好，我是Albert！没错，我又来了！最近题主正在做一个小项目，其中一个功能就是利用一个半开离心泵进行对一个有限固定水域（就是一个小泳池）进行水循环，我们都知道洗衣机滚筒就是一个典型的离心泵，所以有很大可能将离心泵开口后，里面的水有可能流不出来，或者说达不到预期参数，为了直观快速地看到整个流场情况以确定下一步迭代方向，题主选择了ANSYS中的Fluent作为仿真平台，借着这个项目正好分享一下动态仿真如何进行。下图是离心泵模型图和简化模型图（因为是几小时出的初稿，很丑）。 一、模型前处理及导出 从上面两张图可以看出，简化模型主要保留了离心泵特征和开口尺寸等关键信息，这样的处理是为了减少计算量，突出问题主要矛盾。除此之外呢，可能比较注重细节的同学看到了简化模型有些许不同，在叶轮外加了一个圆柱体，这部分叫做仿真的前处理，在进行动态流场仿真的时候，流体的传递并不是像真实物理世界连续传递那样，那样的计算量过于庞大，效率很低，Fluent的解决方式是通过interface连接动域和静域，将流动流体（interior）交互到静止流体（interior）中，所以在前处理就是要建立流动域和静止域，方便后面几何处理，从简化模型中可以看出，圆柱体作为旋转域，外部的几何体为静止域，通过圆柱外表面作为interface进行交互。将简化后的模型导出为STEP格式、igs格式或Parasolid格式均可，即可进行下一步操作。 二、ANSYS中几何处理及划分网格 题主使用的版本是ANSYS 17.0，下一步就是打开Workbench，将Geometry模块拖入工作区然后打开Geometry后，将刚刚导出的模型文件导入Geometry中，结果就像下图所示，可能不同格式文件导入会出现一些不同，比如题主使用的是STEP格式，会导致圆柱面分离，即图中看到的圆柱壁面分成了两个面，这时候使用Tools下面的merge指令选择需要合并的面，合并一些面，做成连续面，这样处理也是为了减小运算量和避免一些玄学BUG。 基本上模型处理成这样就可以了，下一步就要建立旋转域和静止域，这里用到的是Tools下的Enclosure指令，因为我们是自己创建的几何体，所以类型选择User Defined，这里面有一个点是需要关注，以旋转域为例，所谓旋转域就是由于叶轮运动而旋转的水，所以旋转域应当是圆柱体与叶轮实体的差集，在类型选择上，User Defined Body选择圆柱体，即基本几何轮廓，Target Body选择叶轮，即内部实体，两者取差集得到流动域。如下图所示。 静止域的处理方法与旋转域相同，题主只把最后得到的效果放出来，这一步处理之后我们就可以close Geometry了，然后进入下一步了。 此时返回Workbench主界面，将Fluid Flow（Fluent）拖入界面连接到Geometry上，并双击打开mesh进行网格划分。这里的mesh是ANSYS自带的网格划分软件，一些基本处理是可以完成的，是基于ICEM，所以和ICEM界面一样感人。 当我们进入mesh后，第一步在左侧结构树中先找到叶轮，将其suppress掉，方便后续处理，接下来是设置一下进出口面（inlet和outlet），目的是方便观察，还有就是气动仿真中会用到计算起点，对于液体来说就是方便观察。第二步是最关键的，即在旋转域中建立动力交互面interface，我们先把刚刚得到的旋转域独立出来（即将其余body隐藏掉），将光标选择换为Box Select。 然后长按鼠标左键框选旋转域中的叶轮表面，记住此时的叶轮形状并不属于叶轮实体，而是旋转域的内壁表面，然后右键绿色区域，并Create Named Selection，这样导入Fluent就可以自动生成interface了。 下一步就是自动划分网格了，直接点击mesh，generate即可，因为是自动划分的网格，所以网格尺寸较大，可根据需要调整尺寸大小，在Body Sizing中调整element size。 网格划分完毕后，我们的前处理就完成了，即可进入Fluent里进行计算了。 三、仿真计算 我们close meshing后返回Workbench主界面，先update一下mesh文件，然后双击打开Setup，这里设置一下计算方式换为并行计算，将核数改为6，增加一个GPU，提高计算速度。 将General设置如下图，我们这次选择的是瞬时分析，由于流体是水，一定要加上重力加速度。 粘性模型选择K-omega下的SST模型，在Model下的Viscous选项中选择，并在材料中，将液态水添加进流体类型中，关键步骤，设置旋转域旋转，旋转域转轴及转速，如下图所示，选择mesh motion，右侧是旋转轴方向，左侧是旋转轴相对于世界坐标系的偏移量，由于我的叶轮旋转轴与世界坐标系Y轴重合，即无需偏移，转速设置为25rad/s。 下一步就是进行初始化，选择Hybrid Initialization，初始化后的步骤就是preview，及观察叶轮是否转动，保证我们的计算是有效的。在preview中，设置步长0.01s，先跑10步。 preview验证 - 知乎 从preview的视频中看出，叶轮的转动是正常，我们就可以开始仿真了，由于仿真时间太长，收敛后是十分密的锯齿曲线，直接上结果，速度场变化的动画。从仿真视频中可以看出，水是可以从离心泵中流出来，但是流域不是很理想，这就需要后面慢慢改导流机构啦！（由于这个Blog添加不了视频，我就把视频放到了知乎上，后面的连接复制打开一下就能看到结果啦！） 速度场结果 - 知乎 下次看个人情况更新机器人学或者SLAM十四讲的学习笔记吧！希望对你有用，bye！"},{"title":"从双网卡——到路由表","date":"2020-08-13T02:18:00.000Z","url":"/2020/08/13/%E4%BB%8E%E5%8F%8C%E7%BD%91%E5%8D%A1%E2%80%94%E2%80%94%E5%88%B0%E8%B7%AF%E7%94%B1%E8%A1%A8/","categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"现在的电脑一般都拥有双网卡，但这是否是一件好事呢？对于某些小白来说，可能并不是（比如我(●ˇ∀ˇ●)）。 发现问题拿到刚到手的树莓派，首先要做的肯定是配环境！但是在VNC连接树莓派时遇到了问题：当我使用WIFI连接树莓派时，由于带宽限制，界面很卡，影响体验。当我使用有线连接树莓派时，由于有线网卡的优先级高于无线网卡，导致树莓派只能浏览内网（也就是我笔记本的网络），如果使用笔记本共享外网的话只能使用DHCP自动分配IP，这样则会导致IP变化不方便我们连接 树莓派。但是我明明有一个无线网卡连接外网啊！！！怎样才能把它利用起来，成了我要解决的问题。 原理探究找了好久，终于发现了路由表这个神奇的东西，百度百科这样说道：在计算机网络中，路由表（routing table）或称路由择域信息库（RIB, Routing Information Base），是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。 简单来讲，路由表可以规定发往何处的信息使用哪一个路由，也就是决定要发出的信息（对于计算机）或收到的信息（对于路由器）的下一跳是哪里。 在linux中配置路由表很简单，因为它全部被集成到了route这一个指令中。首先我们来看路由表长什么样。拿我的服务器举例，在终端中输入（sudo）route，可以看到：其中Destination表示目标的IP地址；Gateway表示选择下一跳网关IP地址（所有跨网段传输的信息均需要通过该网段的网关传输）；GenMask代表掩码，用于确定一个网段；Flags是用于区分的标志位；Iface是网卡设备的名称（可以使用（sudo）ifconfig来查看）；Flags标志位确定了一系列的路由类型，主要有以下几种：主机路由：顾名思义，主机路由表示单独指向某个特定主机（IP）的路由，所有目标为该主机的信息都发送到所设定的网关，同时也确定了用哪个网卡设备传输信息。主机路由除了Flags的区别，最明显的特征就是它的Destination是一个完整的IP地址，并且它的GenMask是255.255.255.255。这说明了它的目标不是一个网络而是一个特定的主机（IP）。 网络路由：理解了主机路由 在来理解网络路由并不是很难。网络路由指向一个特定的网段，因此它的GenMask不全是 1（比如是255.255.0.0）。它的Destination中也包含0（比如192.168.0.0），0的含义就是任意，这个网段表示整个192.168.*.*的网络。同理，所有目标为该网络的信息都发送到所设定的网关。 默认路由：剩下最简单的就是默认路由了，没有特殊指明的主机（IP），就发送到默认路由设定的网关。默认路由最明显的特征是它的Destination是default，GenMask是0.0.0.0（表示全部网段）。 想要改变路由表，就要使用route命令，它的基本操作如下： 添加路由：route add route add -host 192.168.1.2 dev eth0 添加设备eth0为主机路由，主机IP为192.168.1.2 route add -host 10.20.30.148 gw 10.20.30.40 添加网关10.20.30.40为主机路由 route add -net 10.20.30.40 netmask 255.255.255.248 eth0 添加网络路由，网段为255.255.255.248 route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41 同上，使用网关添加 route add -net 192.168.1.0/24 eth1 添加网络路由，使用目标IP段/MASK位数形式 route add default gw 192.168.1.1 添加默认路由 删除路由：route del route del -host 192.168.1.2 dev eth0 原理同上 route del -host 10.20.30.148 gw 10.20.30.40 route del -net 10.20.30.40 netmask 255.255.255.248 eth0 route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41 route del -net 192.168.1.0/24 eth1 route del default gw 192.168.1.1 解决问题了解了基础知识，我们来解决一下实际问题！首先删除所有默认网关： 添加eth0（有线网卡）仅进行内网访问，即仅在Destination为192.168.*.*的时候使用它。 添加wlan0（无线网卡）进行全网络的访问，即在非内网情况下，使用wlan0进行访问。 需要注意的是，如果使用网关确定，需要设置两个网卡的 默认网关不同；这样设置还有一个弊端就是在访问外网时不能使用有线网卡，可能在没有WiFi的情况下还需要切换。 这样设置下来，双网卡内外分工就大功告成了！"},{"title":"轨道交通领域的差速问题&amp;我与轨交","date":"2020-07-16T08:07:40.000Z","url":"/2020/07/16/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%AE%E9%80%9F%E9%97%AE%E9%A2%98and%E6%88%91%E4%B8%8E%E8%BD%A8%E4%BA%A4/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"大家好，我是那个喜欢火车的Captain。有人说，一个男人不成熟的标志是可以为了一项事业英勇地死去，而一个男人成熟的标志是可以为了一项事业卑贱地活着。我可能是成熟了。在上个周末，从7月10号到13号的四天时间里，我经历了两场专业课考试，一个夏令营，外加一篇恶心的硕士毕业设计级别的论文（我正在和这个课的老师对线，祝我成功）。可喜的是，夏令营的结果还不错，优营在手，只可惜没有推免资格，不能很有底气地去跟想考的导师聊，虽然现在也有别的方向的导师要我。可能不满足和缺陷才是人生的真正形态吧。今天拿到了结果其实挺高兴的，听栋宇说明天考完试打算给这个blog做个宣传，我说那我不如今晚出一篇文章，开始。我是学电气的，或者说我本科是学电机的，就是那个会动的大铁疙瘩，但我今天想跟大家聊聊偏机械方面的内容。我们日常生活中最常见的交通工具应该就是汽车了。无论以什么能源方式驱动，汽车在行驶过程中都会遵循相同的规律，我转动方向盘，前轮的方向就会变化带动汽车曲线运动。对于轨道交通（传统轮轨）而言，这样的过程发生在铁轨与走行部之间。走行部，理解字面即可，用于列车在铁轨上走行的部分。通俗一点讲，就是转向架。如果你不知道转向架是什么，没关系，你可以理解为是火车的车轮以及和它配套的一系列起到固定、缓冲减震、传动作用的机械系统。可能很多人大概知道转向架是什么，但并没有真正地去研究过。的确，很惭愧地讲，在准备这个夏令营之前我也没有好好研究过，我关注的往往是与电有关的内容，机械部分的我一般都会很礼貌地跳过。转向架就是铁路车辆转弯的作动装置，它的上部与车厢相连接，并可以以垂直道面的方向为轴做小角度转动。注意，这里说的是“垂直道面的方向”，而不是竖直方向或者重力方向，一会儿会说为什么。一个转向架大概长这样。我们可以看到它有两对车轮。同轴的一对车轮我们称之为一个“轮对”，有几个轮对就称几轴。例如，我们最常见的25系列客车，也是现在普铁最广泛使用的列车，每节车厢有两个二轴转向架，车辆本身是四轴车。有兴趣的小伙伴可以去B站等平台搜一下C64K，神华十二轴电力机车，那可是机车届的扛把子，全世界功率最大的机车，单机功率达到了14400kW。14400是什么概念呢，这么说吧，感兴趣的朋友可以去看我的上一篇投稿，CRH2A非统型两列加一起差不多也就这配置。我们来简单了解一下转向架的构造。传统的转向架有一类叫做“三大件式转向架”，三大件指的是两个侧架和一个摇枕。摇枕指的就是转向架中央与车体接触的条状或盘状或长条形的机械结构，承担车体重量，同时能够像刚才说的那样转动。摇枕本身是和车体相对静止的，转动时是二者共同相对于转向架其他机构轴向转动。转向架的另一个比较重要的点就是悬挂系统，分为一系悬挂（轴箱和轮对之间）和二系悬挂（摇枕或车体与构架之间）。要命的是，我买的两本教材其中一本把一二系悬挂的定义写反了，我还先看的写错的这一本，导致我现在依旧分不清一二系悬挂，每次提到都要翻书看一眼。随着技术发展，更多的转向架也慢慢出现，在转向、减震缓冲等方面的性能有着很大的提升，像摆式列车这样的转向架也更为复杂，那就是另一回事了。怎么样，听迷糊了没，如果没有咱就继续。刚才提到汽车转弯的过程。转弯势必会带来一个问题，那就是两个轮子如果保证角速度相同，则线速度也应该相同，但转弯时相同时间内外侧轮子滚过的距离显然是比内侧轮子长的，这个差不可以忽视。我们知道汽车是通过差速器解决的这个矛盾，那么火车也没有差速器或者类似差速器的装置呢？没有。道理很简单，第一，轮对两侧的轮子是同轴的，能保证绝对的角速度相同，不存在差速的条件；第二，从操作的角度讲，我个人认为差速器是一个主动作动部件，你给方向盘一个转动信号差速器才会发挥作用，而你给出转向信号是因为你希望人为地使车辆转弯。但火车不是这样，火车的导向是靠轨道对轮缘的限制实现的。如果问我轮缘是什么，这里放一张图大家自己看吧，我懒得讲。看的时候顺便也了解一下踏面是什么。好了，我们来讲火车转弯时发生了什么。可能大家高中学物理的时候做过这样类型的题，说火车转弯，转弯半径给你了，车辆质量给你了，速度给你了，轨道面倾角也给你了，让你求对内侧轨道的压力。当时做这题我就觉得这是纯扯，你把火车当质点系？闹呢？不过话说回来，这个模型其实很大程度上真实还原了火车过弯时候的情况。如果大家有兴趣，可以下次坐高铁动车的时候体验一下，看看过弯的时候火车是不是倾斜的（普速列车也存在这个现象，但设计速度越快的线路越明显，所以动车是最优解）。这其实是为了保护铁轨和车轮，在转弯时人为将外侧铁轨垫高，使重力的一个分量先行充当向心力（效果力），尽量不让轮缘和轨道之间发生摩擦。实际上，新建的铁路大多是无砟铁路（有砟铁路就是底下是石头子儿的铁路），对于这个垫高的高度会有很精确的控制，但既有线等有砟铁路还依赖人工修正，工人师傅会定期到转弯处，测量垫高是否符合技术手册的标准，如果不够，就用工具往外侧铁路地下推石子儿，强行垫高。很有趣其实。扯远了，说回到转弯过程。这里各位应该就明白上文中我提到的并不是竖直方向而是垂直于道面了吧。到这里，还是没解决差速的问题，火车的解决思路就很巧妙，真的。如果你们仔细看上面那个图，你会发现其实踏面不是柱面，而是锥型面（不知道柱面和锥型面的小伙伴自己去补高数和线代去），越靠近轮缘半径越大。这就好办了。当火车进入弯道，铁轨开始倾斜，于是车厢向一侧倾斜，重力分量充当向心力带着车厢开始画圆。由于离心效果，车辆整体会有向外侧移动的趋势，也就是车辆本身会往外侧（垫高一侧）甩，就像你家的洗衣机或者你那热爱蹦迪的男朋友/女朋友一样。甩完之后的结果是，车辆的中轴线和轨道的中心线不再在竖直面内平行，而是错开一定的距离，此时接触轨道的踏面也会向外移，那么实际接触到外侧轨道的踏面滚转半径就要比内侧大了。在严格的角速度相等的时候，两侧的线速度就会不相等，外侧比内侧大，也就不存在差速的问题了。多巧妙，是不是，这就是轨道交通的魅力。本来想继续讲讲轨道和道岔的，内容都想好了，忽然有些感慨想说点别的，那这部分内容就留到下一篇吧。有人说能让一群男人为止奋斗的从来不是金钱而实梦想，我觉得同济轨交就是我的梦想。我在哈工大电气，也不错，但我能学到的终究还是电气的东西，即便是与轨道交通有关，也仅仅是“有关”罢了。要想真正走入这个行业，还是要跟着专业的人学专业的东西，坐专业的事情。中国铁路，无论是国铁还是地方铁路、城市轨道交通，其实一直在风口浪尖上。有人说中国的高铁技术都是国外引进的，中国技术不行，有人说中国修铁路太浪费钱。实际上真的是这样吗？我还没有走入这个行业里。我的前脚已经搭在门槛上了，等我进去看看便知分晓。但我想说，任何一种技术都是从无到有从零到一的，十几年前我们没有技术的时候引进了国外的技术，也是花了大价钱的，后来我们慢慢在发展，到今天我们有了自己标准的动车组，我们开始向国外出口中国生产的轨道交通车辆，作为一名向往轨道交通的人，我是很自豪的。我们的第一艘航母也是买的前苏联的，后面经过我们的研究还是造出了自己的航母。一样的，我们的C919是以A320为模板的，阿娇（ARJ21）也是从模仿开始一步一步提升的。中国的技术现在行不行，我们去看看中车的海外订单就知道了。那天我看了一个纪录片，超级工程第一季，其中一集讲到了北京地铁网络的建设，有一个片段让我热泪盈眶，我截了下来，放在这里。写这篇文章的时候，脑海里多次会想起这个画面，每当我看到这个动图我都忍不住落泪。可能这就是热爱，可能这就是我热爱一项事业的方式。我希望自己能够进入到这个行业中去真正做一些事情。我们没有西门子那样将近两百年的发展历程，我们真的要做很多努力去超越和创新。对于轨道交通，我很自豪地讲我是有自己的想法的，也希望有朝一日我也能够再次热泪盈眶地说一句：“为了搞我们国家自己的轨道交通事业，我们那代轨交人，可以说是付出了辛苦的，很自豪。”谢谢。"},{"title":"新人报到！虚拟样机在机器人领域的应用（入门篇）","date":"2020-07-13T05:33:00.000Z","url":"/2020/07/13/%E6%96%B0%E4%BA%BA%E6%8A%A5%E5%88%B0%EF%BC%81%E8%99%9A%E6%8B%9F%E6%A0%B7%E6%9C%BA%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"Hello！大家好呀，我是你们的新朋友，也是宇哥的搭档。先自我介绍一下子哈，我的名字是冯宸，跟栋宇一样是哈工大竞技机器人队的现役队员，大家可以叫我Albert，主要是从事机械方向的工作，当然嵌入式和视觉方面也有（cai）所（de）涉（yi）猎（pi）。前几天偶然发现了栋宇的Blog，就想着抛砖引玉写一篇科普小文章，奈何才疏学浅再加上这几天事情比较多，就搁置了下来，不过今天刚好有时间，就尝试把自己之前弄的一些基础的小东西来支持一下我宇哥。好啦！废话不多说上才艺！ 虚拟样机技术简介虚拟样机技术一般在大型复杂系统的产品设计中应用，虚拟样机技术 (Virtual Prototyping Technology)是指在产品开发设计过程中，将分散的零部件设计和分析技术融合在一起,在计算机上建造出整体模型,并针对该产品在投入使用后的各种工况进行仿真分析，预测产品的整体性能，通过仿真结果指导改进设计、提高产品性能。一般流程是在仿真软件中搭建一个动力学模型来模拟系统工作时的工作状态,通过数据输出(位移、速度、加速度)或者仿真动画输出来观察和分析系统的可靠性，分析结果用来指导物理样机 的版本迭代。在RoboMaster 比赛中,如果能搭建正确的战车一些核心模块的虚拟样机,在方案试验阶段能节省很大一部分的人力成本资金成本和时间成本.并且能在分析问题时有一定说服力的依据而不是只停留在经验层面上,解决问题一针见血。 常用虚拟样机软件自然界广泛存在四种物理场：温度场、电磁场、结构(位移、应力、应变)场、流场 。不同的工程所分析的物理场不一样,不同的物理场所应用的公式理论和仿真软件也不一样.本文主要针对robomaster 比赛中机械仿真案例进行阐述.目前来看主要是运用结构场和流场 进行建模分析.其中涉及到多体动力学分析和静力学分析以及流体力学分析。一般涉及到软件Solidworks、Adams、Ansys workbench、Fluent… 等。Solidworks 主要进行三维建模设计也可进行关键零件的静力学分析(Simulition静力学模块)和动力学模型搭建(motion模块)。Adams 是多体动力学仿真计算中最常用的软件,也是本文的中点阐述对象.可以进行动力学模型搭建(View模块)仿真求解(Solver模块)以及数据处理模块(Postprocessor模块)Ansys 是有限元仿真中常用软件，可以进行静力学分析(Static Structural模块)也可以进行碰撞分析(LS-dyna模块)还有流场分析(Fluid Flow模块)，Workbench集成了很多有限元模块，可以共享各自的结果数据使Ansys的功能异常强大。结构场是最主要的分析场.本文是在结构场中以步兵拨弹模块 为例进行展开系统的虚拟样机搭建过程.研究Adams虚拟样机中17mm子弹在弹仓中的运动状态和拨轮受力情况，指导拨弹模块的改进，进而提高射频满足比赛要求。 搭建虚拟样机的动力学模型简单的机械系统可以搭建数学模型进行动力学分析,但是像拨弹这中多自由度的复杂系统很难或者无法直接搭建整个拨弹过程的数学模型,只能通过多体动力学软件搭间接搭建数学模型进行迭代计算和过程动画模拟来分析问题。虚拟样机其实包括建模、仿真、后处理.建模即创建样机添加工况,仿真即是求解方程,由计算机幕后完成,后处理主要是查看动画以及输出一些感兴趣的物理量,复杂的由专业后处理模块Adams/PostProcessor进行。在Solidworks中的motion模块和Adams View中均可搭建动力学模型。Solidworks中操作比较简单，对于大多数同学来讲上手比较快。可以把模型在SW中搭建好之后导入到Adams进行求解计算，这样可以在短时间内完成一个简单系统的仿真工作，不过如果需要更精确的求解计算建议还是使用Adams搭建模型比较好，求解更精确。 4.在Solidworks中简化模型导入Adams计算和后处理（1）在solidworks中简化拨弹模块，压缩不影响本次研究问题的无关零件(发射模块、弹舱盖、其他保护壳等)。并添加上子弹,子弹是阵列生成,需要右键解散阵列 .所有零件应赋材料(子弹材料TPE,用PA代替)如图4-1到图4-2的简化。 图4-1简化前 图4-2简化后（2）打开【motion】插件,进入motion模块(如没有在→插件中勾选motion),在左下角将页面切换至【运动算例1】 ,将下拉菜单【动画】切换到【motion分析】 ,依次添加各个实体间的接触力contact(球与球之间、球与拨轮之间、球与弹舱之间),检查弹舱为固定状态,最后设置重力 .到此为止,模型搭建完毕,驱动马达可以不添加,放在Adams 中操作.图4-3是各按钮位置。 图4-3 motion模块的操作界面在动力学模型中每个实体之间的接触是靠添加两个物体间的接触力实现的,在Adams和Solidworks中每个接触均有8个参数(图4-7中标出),四个碰撞参数:Stiffness(刚度系数)、Force Exponent(刚度指数)、Damping(阻尼系数)、Penetration Depth(最大穿透值),四个库仑摩擦参数:Static Coefficient(静摩擦系数)、Dynamic Coefficient(动摩擦系数)、Stiction Transition Vel(静摩擦过渡速度)、Friction Transition Vel(动摩擦过渡速度), 表3-1给出大致参数确定方法，也可参考附件data文件夹下《ADAMS中接触的定义及参数设置》.图4-4和图4-5方便理解各个参数的意义。 表3-1 Impact接触参数与Coulomb摩擦参数 图4-4 Impact接触参数参考图 图4-5 Coulomb摩擦参数参考图 图4-6 各球之间接触 图4-7各球之间的接触参数设置图4-6为添加球和球接触中实体选择操作,可以看出不勾选接触组时,添加的是所选择各实体间的接触,17颗球之间一共有136个接触.图4-7为球和球之间的接触参数设置(推荐)。 图4-8球和各个弹舱零件的接触 图4-9 球与弹舱之间的接触参数设置图4-8使用【接触组】添加接触,球和拨轮以及球和弹舱的接触需要使用接触组,即球为一组与另外三个零件分别添加接触,各球之间接触不会被重复添加,在图中看出17个子弹与四个零件间分别添加接触,共68个接触. 图4-9为球和弹舱之间的接触参数设置(推荐)。另外拨轮和球之间的接触同样使用接触组,系数设置中将图4-9中【Stiffness】(刚度)系数改为400即可。使用Solidworks 方便交互式批量添加各实体间的接触力,Adams 中接触力的添加比较难操作.多个实体之间只有用脚本命令进行添加比较方便。最后添加上重力。（3）导入到Adams中,检查模型,稍作修改,一些复杂的约束用简单约束来替换,在Solidworks 中的互相固连的零件可以进行两种操作①两个零件用Fixed约束锁死②使用Boolean运算进行零件合并,给拨轮添加Revolute铰接约束,在铰接约束上添加motion驱动.打开求解器进行运算即可。 图4-10计算按钮 图4-11 Solidworks与Adams的接口把模型按照第一第二步搭建完之后,点击【计算】按钮(图4-10),计算结果一般都会报错可以忽略,Solidworks中的求解器计算很容易失败,所以只用motion做模型搭建这种前处理工作.右键模型名称输出Adams(图4-11),输出英文命名的.adm文件和一些.xmt_bin以及.res文件均保存在英文路径下.附件中例程保存在 adams_file\\project\\model\\adams_1中。 图4-12导入.adm文件 图4-13 MKS单位制设置打开Adams导入.adm文件,新建模型“loader_1”,设置单位制。 图4-14 Connectors约束 图4-15 添加Fixed约束 图4-15 Fixed(固定)和Revolute(旋转)约束在Adams中删除【Connectors】中所有约束,将几个固定零件间添加Fixed约束(固定锁死)。 图4-16 右键→Appearance 图4-17 Appearance→Color更改拨轮颜色为Red,方便观察和操作,如图4-16和图4-17.也可以根据需要更改其他零件颜色.图4-17中【Visibility】点选off即可隐藏该零件,该操作同样适用于其他类型信息,如Connectors、Motion、Force等。 图4-18添加Revolute(旋转)约束 图4-19 Revolute(旋转)约束结果在拨轮和弹舱中间添加旋转副,操作如图4-18结果如图4-19。 图4-20 Rotational Joint motion(旋转驱动) 图4-20 motion结果 图4-21 motion参数 将旋转驱动添加到拨轮的旋转副上。在joint_4上添加motion_1,参数设置如图4-21。17mm子弹材料为TPE,密度970 kg/m³弹性模量3.4GPa,泊松比0.32(近似)。 图4-22 新建材料 图4-23 TPE材料参数【body】树下右键其中一个球单击【Modify】, 出现对话框如图4-22在【Define Mass By】下拉菜单选择【Geometry and Material Type】,在【Material Type】中右键出现图中对话框,依次选取【Material】→【Create】会跳出对话框如图4-23，按照TPE参数设置单击【Apply】→【ok】,然后单击图4-22中【Apply】即发现图中材料参数刷新至新建TPE材料.依次添加剩余球的材料和弹仓材料(【Material】→【Guesses】→【aluminum】)。模型搭建完毕,进入simulation进行求解计算。 图4-24仿真参数设置如图4-24仿真正在进行中,左上角为仿真计算过的模型时间,右下角为仿真进程百分比,在Simulation Control对话框中【End Time】为仿真总时长,【Step Size】为仿真步长根据模型复杂程度给定,合理的步长节省仿真时间、提高仿真精度.如果计算报错则检查模型有无物理干涉和严重死点,调整仿真时间继续进行仿真计算,多次仿真计算应勾选【Reset before running】保证每次仿真计算前参数重置.仿真时间由模型复杂度和电脑CPU以及内存而定,如果模型复杂则仿真时间会十几个小时甚至几天，电脑配置稍好些会加快运算效率.另外合理的模型化简和模型搭建也能影响仿真时间。关于充分利用电脑性能加快仿真速度,可以开从多线程运算和增大可调用内存两个方面入手。多线程运算途径&gt;在Adams/View界面下通过“settings&gt;solver&gt;Executable”菜单打开设置窗口，并勾选More选项，在Thread Count位置输入参与计算的线程数(128).如图4-25。 图4-25增大调用内存途径&gt;开始–程序–MSC.software–MSC.ADAMS–ADAMS settings分别打开Aview和Asolver中的Preference，在右侧memsize一栏中选择huge点击ok保存。重新运行ADAMS即可.如图4-26。 图4-26（4）进入后处理模块Postprocessor,观察动画可以看到子弹在拨轮中的运状态,进行子弹轨迹追踪和一些感兴趣物理量的测量.比如输出电机的驱动扭矩值,进行电机选型.通过仿真动画和数据指导版本迭代改进。5.Solidworks提供三维模型,Adams中进行模型搭建和计算及后处理（1）Solidworks简化模型,操作过程和流程和4.1中相同,最后将装配体另存成Parasolid(*.x_t)格式如图5-1,导入Adams做前处理.注意:Adams不支中文路径和中文文件名。 图5-1导出x_t打开Adams View,新建模型导入.x_t文件.单击【New Model】输入自定义模型名称(英文),单击【ok】会新建一个空白模型,【主菜单】&gt;【File】&gt;【import】下拉菜单第一个【File Type】中选择Parasolid,在【File To Read】中右键&gt;【Browse】浏览到目标.x_t文件,在【Model Name】右键选择新建的模型名称.单击【Ok】.模型导入完成.如图5-2。 图5-2 .x_t导入Adams（2）在Adams里面搭建动力学模型.在此之前应掌握Adams图形界面基本操作和工具栏的分布.模型需要用cmd脚本搭建,准确高效,所以要求能读懂简单的编程语言.本章节均用一些简单的命令语言来实现建模操作.这里的脚本编辑器使用的是VScode,桌面新建.txt英文命名后缀改为.cmd,用VScode打开编辑后保存即可。【主菜单】&gt;【View】&gt;【Command Window】打开命令窗口,每一步界面操作的命令都会在命令窗口中滚动.可以复制出来修改后使用。Cmd脚本对拨弹部分建模流程如下①修改Bodies Name②布尔运算操作③定义材料④添加约束⑤添加驱动⑥定义接触力(部分步骤的先后顺序可调)。①基本设置设置单位制(MKS)和重力方向(-Z)。!————-setting———————-!default units length=mm mass=kg force=newton &amp; time=Second angle=degrees frequency=hz!units_MKS! int dia disp dia=gravity_panel!打开对话框重力设置对话框!force modify body gravitational gravity = ACCGRAV_1 &amp; x_comp = 0 &amp; y_comp = 0 &amp; z_comp = -9806.65!-Z轴gravity!!—————–end————————!②修改Bodies Name在模型树中【Bodies】下可以查看各个实体.如果在Solidworks中是中文命名,导入后会重新命名,但是命名均有规律.现需要修改实体名字,方便查看和操作。图形界面操作按钮如图5-3,【模型树】&gt;【Bodies】&gt;【任意一组件右键】。 图5-3 Rename按钮 !————-modify_part_name—————!entity modify entity =____002 new = wheel_loaderentity modify entity =__ new = magazin_1entity modify entity =_______2 new = sheetentity modify entity =____ new = magazin_2 entity modify entity =17mm____ new = 17mm_____1for variable_name=ip start_value=1 end_value=17 !for循环批量修改球的name,ip为变量名!entity modify entity =(eval(“17mm__“//rtoi(ip))) new =(eval(“ball_”//rtoi(ip)))end entity modify entity =____ new = _________1for variable_name=ip start_value=1 end_value=2entity modify entity =(eval(“_________”//rtoi(ip))) new = (eval(“pipe_”//rtoi(ip)))end!——————-end———————-!根据模型树中的信息,编写modify_name命令如下,通过【主菜单】&gt;【File】&gt;【import】导入.cmd实现对模型的操作如图5-4， 图5-4 .cmd导入Adams操作前后的对比如图5-5和图5-6 图5-5 Bodies Name修改前 图5-6 Bodies Name修改后③布尔运算操作在三维模型为DFM(面向制造的设计),不影响功能情况下,使用布尔运算将多个零件合成一个。图形界面操作按钮如图5-7,【功能区】&gt;【Bodies】&gt;【Booleans】。 图5-7 Booleans操作按钮根据模型,编写Booleans命令操作如下,!————-Booleans_parts—————–!part merge rigid_body part_name=pipe_2 into_part=pipe_1!将pipe_2合并到pipe_1!!——————-end———————-!操作前和操作后的区别如图5-8和图5-9 图5-8 布尔合并前 图5-9 布尔合并后④定义材料图形界面操作按钮,【模型树】&gt;【Bodies】&gt;【任意一个构件右键】&gt;【Modify】接下来的操作设置如图5-10和图5-11 图5-10 新建材料 图5-11TPE材料参数材料参数:①密度(Density)②弹性模量(Youngs Modulus)③泊松比(Poissons Ratio)根据模型,编写Material命令操作如下,!————-modify_material—————–!material create &amp; !新建材料TPE! material_name = .materials.TPE &amp; density = 0.97e-6 &amp; youngs_modulus = 3400 &amp; poissons_ratio = 0.32for variable_name=ip start_value=1 end_value=17!for循环批量修改! part modify rigid mass_properties &amp; part_name = (eval(“ball_”//rtoi(ip))) &amp; material_type = .materials.TPEend part modify rigid mass_properties &amp; part_name = pipe_1 &amp; material_type = .materials.aluminumpart modify rigid mass_properties &amp; part_name = magazin_1 &amp; material_type = .materials.aluminumpart modify rigid mass_properties &amp; part_name = sheet &amp; material_type = .materials.aluminumpart modify rigid mass_properties &amp; part_name = wheel_loader &amp; material_type = .materials.aluminum!——————-end———————-!修改前后对比如图5-12和图5-13 图5-12 新建材料 图5-13 TPE材料参数⑤添加约束在此模型中每个子弹都有6个自由度,不存在约束,剩余零部件都有自己的固定方式.如图5-14中,wheel_loader和ground有个旋转约束,其余零件和ground都是固定约束。 图5-14 模型树中需要约束的零部件图形界面操作按钮如图5-15 图5-15 Fixed(固定)和Revolute(旋转)约束·固定约束(Fixed Joint)根据模型,编写Fixed_joint命令操作如下,!—————Fixed_Joint——————!marker create marker=.ground.MAR_fixed_1 &amp; !在ground上创建marker点命MAR_fixed_1!location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置重合!orientation=0.0,0.0,0.0 !MAR_fixed_1和ground.cm坐标重合!marker create marker=.sheet.MAR_fixed_1 &amp;!在ground上创建marker点命名MAR_fixed_1! location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置合! orientation=0.0, 0.0, 0.0 !MAR_fixed_1和点ground.cm坐标重合!constraint create joint Fixed &amp; !在上述创建的两个marker间创建一个固定约束! joint_name=fixed_1 &amp; !Fixed约束的名称! i_marker_name=.sheet.MAR_fixed_1 &amp; j_marker_name=.ground.MAR_fixed_1 marker create marker=.ground.MAR_fixed_1 &amp; location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp; orientation=0.0, 0.0, 0.0marker create marker=.magazin_1.MAR_fixed_1 &amp; location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp; orientation=0.0, 0.0, 0.0constraint create joint Fixed &amp; !创建固定约束! joint_name=fixed_2 &amp; i_marker_name=.magazin_1.MAR_fixed_1 &amp; j_marker_name=.ground.MAR_fixed_1 marker create marker=.ground.MAR_fixed_1 &amp; location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp; orientation=0.0, 0.0, 0.0marker create marker=.pipe_1.MAR_fixed_1 &amp; location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp; orientation=0.0, 0.0, 0.0constraint create joint Fixed &amp; !创建固定约束! joint_name=fixed_3 &amp; i_marker_name=.pipe_1.MAR_fixed_1 &amp; j_marker_name=.ground.MAR_fixed_1!——————-end———————-!创建Fixed后如图5-16 图5-16 固定约束的结果图·旋转约束(Revolute Joint)需要在拨盘(wheel_loader)和ground之间添加旋转约束，根据模型,编写Revolute_joint命令操作如下,variable create variable_name=wheel_name string_value=”wheel_loader” !定义变量”wheel_name”,string_value代表字符串类型!marker create marker=.ground.run_MAR_1 &amp; location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp;! orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))marker create marker=.wheel_loader.run_MAR_2 &amp; location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp; orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))constraint create joint Revolute &amp; !创建Joint_Revolute! joint_name=run_1 &amp; !约束名称! i_marker_name=.ground.run_MAR_1 &amp; j_marker_name=.wheel_loader.run_MAR_2variable delete variable_name=wheel_name !删除变量!Adams中建模命令均是对是通过对Marker点的操作来完成的,拿创建旋转副举例(固定约束同理),分为三步：i.创建一个坐标点run_MAR_1,该点在ground上,与wheel_loader.cm重合。ii.创建另外一个坐标点run_MAR_2,该点在wheel_loader上,依旧与wheel_loader.cm重合。iii.创建一个转动副,转动副名字为.loader_2.run_1,他是由于两个坐标点发生相对转动构成的,这两个坐标点分是上述两步创建的坐标。此外上述脚本开头定义了一个字符串变量wheel_name,在创建Joint中使用,结尾删除.使用变量可以方便代码移植。⑥添加驱动Adams中驱动一般添加在旋转副或者移动副上,拨弹模块只需添加拨盘旋转，图形界面操作按钮如图5-17 图5-17 Rotational Joint motion(旋转驱动)根据模型,编写Joint Motion命令操作如下，!————-Revolute_Joint—————-!variable creat variable_name=MC_run_1 string_value=”step(time,0.1,0,0.3,-360d)”!电机转速!constraint create motion motion_name=.loader_2.motion_1 &amp; joint=.loader_2.run_1 &amp; !motion添加在run_1上! type=rotational &amp; !类型是转动! time_derivative=velocity &amp; !驱动类型为velocity(速度)! function=(eval(MC_run_1)) !调用定义的变量MC_run_1!!——————-end———————-!使用step函数定义驱动,step函数：STEP（time，1，0d，2，20d）+STEP（time，6，0d，12，-40）意义：1秒到2秒：从0递增至20d；2秒到6秒：保持电机输出数值为20d不变；6秒到12秒：由20d递减40d，结果为-20d旋转约束和驱动添加之后的结果如图5-18 图5-18添加旋转约束和驱动⑦定义接触力在Adams中所有的碰撞接触的均应添加接触力。该模型中接触力的添加操作要稍微复杂,每个球都有6个自由度,所以每两个球之间都要有添加接触力,第四节中已经说明球之间需要添加136个接触力,需要使用命令批量添加，准确高效。图形界面操作按钮如图5-19【功能区】&gt;【Forces】&gt;【Special Forces】&gt;【Create a contact】。 图5-19 添加实体间接触力按钮根据模型,编写Create contact命令操作如下!————create_contact_between_solids————–!variable create variable_name=MODEL_name string_value=”loader_2”!模型名称!variable create variable_name=part_box string_value=”CSG_4”!被接触对象! variable create variable_name=add_1 integer_value=6!子弹Body名称和SOLID名称的序号差! variable create variable_name=MC_stiffness real_value=164 !刚度系数,计算公式参考stiffness.m!variable create variable_name=MC_damping real_value=0.5 !阻尼系数!variable create variable_name=MC_exponent real_value=2 !指数!variable create variable_name=MC_dmax real_value=0.00005!最大实体入侵! variable create variable_name=MC_mu_static real_value=0.7 !静摩擦系数!variable create variable_name=MC_mu_dynamic real_value=0.65!动摩擦系数!variable create variable_name=MC_sti_tra_vel real_value=0.1!静摩擦过渡速度!variable create variable_name=MC_fri_tra_vel real_value=10 !动摩擦过渡速度! !—————sheet————-! variable modify variable_name=part_box &amp; string=SOLID2 !修改part_box为sheet的Solid!variable modify variable_name=MC_stiffness real_value=4.4e8variable modify variable_name=MC_damping real_value=5e4variable modify variable_name=MC_exponent real_value=1.5variable modify variable_name=MC_dmax real_value=0.01for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//““//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent)) &amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)end!—————magazin_1————-! variable modify variable_name=part_box &amp; string=SOLID1variable modify variable_name=MC_stiffness real_value=4.4e8variable modify variable_name=MC_damping real_value=5e4variable modify variable_name=MC_exponent real_value=1.3variable modify variable_name=MC_dmax real_value=0.01for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con“//rtoi(ipp+add_1)//““//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent)) &amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)endvariable modify variable_name=part_box &amp; string=SOLID3for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent))&amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)end!—————pipe_1————-! variable modify variable_name=part_box &amp; string=SOLID4variable modify variable_name=MC_stiffness real_value=4.4e8variable modify variable_name=MC_damping real_value=5e4variable modify variable_name=MC_exponent real_value=1.5variable modify variable_name=MC_dmax real_value=0.01for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con“//rtoi(ipp+add_1)//““//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent)) &amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)endvariable modify variable_name=part_box &amp; string=SOLID5for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent))&amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)end!—————wheel_loader————-! variable modify variable_name=part_box &amp; string=SOLID6variable modify variable_name=MC_stiffness real_value=4.4e8variable modify variable_name=MC_damping real_value=5e4variable modify variable_name=MC_exponent real_value=1.5variable modify variable_name=MC_dmax real_value=0.01for variable_name=ipp start_value=1 end_value=17contact create &amp; contact_name = .(eval(MODEL_name)).(eval(“con“//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp; j_geometry_name = (eval(part_box)) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent)) &amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)end!—————contact_between_balls——————-!variable modify variable_name=MC_stiffness real_value=1.64e8variable modify variable_name=MC_damping real_value=2e4variable modify variable_name=MC_exponent real_value=2variable modify variable_name=MC_dmax real_value=0.1variable modify variable_name=MC_mu_static real_value=0.35 !静摩擦系数!variable modify variable_name=MC_mu_dynamic real_value=0.3!动摩擦系数!!—————————————!variable create variable_name=ipp integer_value=1variable create variable_name=a integer_value=1!第一颗子弹的序号!variable create variable_name=b integer_value=17!最后一颗子弹的序号!variable create variable_name=add_2 integer_value=1 for variable_name=num_1 start_value=(eval(a)) end_value=(eval(b-1))!两个for循环,依次添加子弹之间的各约束! for variable_name=num_2 start_value=(eval(a)) end_value=(eval(b-ipp))contact create &amp; contact_name =.(eval(MODEL_name)).(eval(“con_”//rtoi(num_1)//“_”//rtoi(num_1+add_2))) &amp; i_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1))) &amp; j_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1+add_2))) &amp; stiffness = (eval(MC_stiffness)) &amp; damping =(eval(MC_damping)) &amp; exponent =(eval(MC_exponent))&amp; dmax =(eval(MC_dmax)) &amp; coulomb_friction = on &amp; mu_static =(eval(MC_mu_static)) &amp; mu_dynamic =(eval(MC_mu_dynamic)) &amp; stiction_transition_velocity =(MC_sti_tra_vel) &amp; friction_transition_velocity =(MC_fri_tra_vel)variable modify variable_name=add_2 integer_value=(eval(add_2+1))endvariable modify variable_name=ipp integer_value=(eval(ipp+1))variable modify variable_name=add_2 integer_value=1end variable delete variable_name=ippvariable delete variable_name=avariable delete variable_name=b variable delete variable_name=MODEL_namevariable delete variable_name=part_box variable delete variable_name=add_1variable delete variable_name=add_2!———————–end——————————! 到此为止动力学模型已经搭建完毕,其中一些参数设置一般指接触力参数和仿真步长参数,尤其使接触力参数中的刚度系数和阻尼系数需要查询资料来确定,作者在这一块也没有太明确的方法,文献中显示stiffness标准值是在1.0e+7~1.0e+9(N/m)之间，阻尼系数一般取stiffness的0.01%。材料参数如表5-1 表5-1 ⑧设置仿真时长和步长开始仿真本模型中有17个子弹,200个接触,如果40个子弹,各部分接触达到1000个.仿真时长取决于具体物理场景，仿真步长取决于模型复杂度，步长越小，计算结果越容易收敛，模型越精确，步长过大结果发散后就会报错。但是步长过小计算就变慢，合适的步长有利于模型仿真计算。本案例中步长给0.0005~0.001比较合适，时长给2s既可以说明问题如图。 图5-21仿真细节参数⑨查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。⑩一般的搭建过程如图,徐要验证和迭代框图5-21。 ⑪查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。（3）后处理模块将样机的虚拟数据输出成曲线或者生成直观的动画来查看。后处理数据需要在模型中调用，采用measure命令即可调取其中的参数，本例中关心拨弹电机的扭矩是够用，故在【模型树】&gt;【motions】&gt;【右键motion_1】&gt;【measure】按照如图5-22设置&gt;【apply】。 图5-22 Measure按钮输出的扭矩图如5-23 另外可以通【功能区】&gt;【Results】&gt;【Postprocessor】进入后处理模块【空白页右键】&gt;【Load Animation】进行动画输出如图5-33，红色框中是播放暂停好和录制按钮。 还有其他感兴趣的任意物理量均可输出，通过对数据和动画的分析寻找结构优化的突破点，事半功倍。6.结论所提到的Solidwoks搭建动力学模型导入Adams中进行计算,对于新手来讲比较容易上手,能在短时间内搭建出动力学模型,并且简单的机械系统的仿真计算结果是可信的.而一些复杂些的系统求解精度就很低,和实际情况不太相符.在做拨弹仿真中就出现实体实体间的互相侵入太多的情况,目前还没找到原因.故复杂模型建议使用以下叙述的模型搭建方法。虚拟样机需要在建立后，根据物理样机修改才能得到更精确的仿真结果。各种仿真软件都只是工具，建模的关键还在于正确的工况分析与合理的参数设置，这些都是在仿真过程中逐渐完成的。如何把建立正确的物理样机以及仿真后数据的分析与改进方向是需要人工分析完成的。7.写在最后的预告各位朋友们，如果大家觉得这部分比较有趣的话，下一次可以和大家分享机器人学的部分知识，先从运动学和动力学开始吧，比如D-H法，拉格朗日方程，牛顿-欧拉方程，以及这些数理知识是如何应用在机器人设计中的，有机会的话下次见啦！"},{"title":"LCD vs OLED","date":"2020-07-11T06:41:00.000Z","url":"/2020/07/11/LCD%20vs%20OLED/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"转载以下知乎大佬们为我们带来的LCD与OLED大比拼： 链接：OLED 和 LCD 有什么区别？ 来源：知乎 "},{"title":"轨道交通领域的牛顿特斯拉之战和你坐地铁听到的“防空警报声”","date":"2020-06-30T09:21:11.000Z","url":"/2020/06/30/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E7%89%9B%E9%A1%BF%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E6%88%98%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%B0%E9%93%81%E5%90%AC%E5%88%B0%E7%9A%84%E2%80%9C%E9%98%B2%E7%A9%BA%E8%AD%A6%E6%8A%A5%E5%A3%B0%E2%80%9D/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"好了，我不是鸽子，我只是最近突然开始考试了。再一个，闫栋宇这博客的影响力太低，划了半天才遇到这样一个问题。 感谢这位同学，好样的。你的问题我在后面解答了，记得查收。今天考完了信号与系统，下午忽然看到中车长客下线了哈尔滨地铁2号线的第一列电客车，外形样子很有JR的味道，内部LCD很像港铁。挺帅的，可以期待一下。所以挺高兴的，忽然想起来自己应该看看这个博客里面也没有人提问题了，就点进来看了一下。遂琢磨写一篇推送，说点轨交的小东西。开始。提到轨道交通，大家想到的可能是和谐号，复兴号，白色车身，蓝色肩带的钢铁巨龙；或者是拉着汽笛咣啷啷前行的绿皮车。事实上我对轨道交通的兴趣，大概来自于我从小就住在铁路边上，绥满铁路哈尔滨段，也是中东铁路最靠近哈尔滨站的这一段。那时候也没有啥娱乐手段，每天最大的快乐就是看火车。我家门口的铁路桥往北走一点就是著名的滨洲铁路桥，现在已经是个景点了。高中想考同济轨交，没考上，现在换了个地方继续考，我就不信了我还治不了你了。扯远了，说回来。目前的轨道交通是以电气化发展为主的，你们看看自己城市的地铁，没有在用内燃机车或者蒸汽机车的吧，都是电客车。电客车，以电为能源的载客列车，字面意思即可。通常我们认为火车是车头带着一溜车厢走，动力来自于车头，也就是所谓的机车。机车通过电能驱动电机，或者内燃机燃烧燃料带动车轮（这里要注意，为了更好地控制运行速度，相当一部分内燃机车采用电传动，简单来说就是燃烧燃料是为了发电，，电能驱动列车前进，本质上还是电机带动车轮转动），机车通过车钩把力传给后面的车厢，再传给再后面的车厢，一节一节套娃即可。这种模式成为机辆模式，只有机车有动力，后面全是没有动力的拖车。这样的车坐起来的体验比较差。我们可以把一列火车想象成一个高中学动量定理时候常用的简单的物理模型，就是若干物块通过弹簧串联起来。列车停放时，弹簧是松弛的（有空的时候可以给你们讲讲制动的原理，制动靠的是空气，很有意思），机车带动第一节车厢从零加速，第一个弹簧绷直，第一节车厢有速度之后，第二个弹簧绷直，第二节车厢受力开始加速。落实到乘坐体验上，就会在启动的时候忽然觉得自己所在的车厢被一个很大的力撞了一下，车迷俗称“咣一声”。不同车型的体验是不一样的，减震缓冲做的越好这种感觉越微弱，但再微弱也会有。同理，制动的时候也一样。但如果你坐的火车在站内停车的时候忽然向运行反方向抖了一下，紧接着又向运行方向抖了一下，不要慌，这是在进行更换机车的机车连挂作业，也就是换车头。传统的机辆方式很传统，但会带来一些问题。刚才说的乘坐体验是一方面，另一方面就是运行方面的问题了。这样的方式限制了列车的加速性能，毕竟要一节一节地去把车厢从静止“拽”成有速度，且一节机车能提供的总功率有限，很难把运行速度进一步提升，目前普速列车最高的速度等级是Z，最高运行速度也就160左右，拉的越多速度还越慢。这倒也好解决，你一辆机车不够我就加一个呗，俩不够就来仨，是可以的。这样的运行模式下，负责总控制的机车称为本务，剩下那些来帮忙的都叫做补机。这样的方法行倒是行，但也仅仅是“凑合着用”。这里我们引入一个不是很严谨的概念，叫动拖比。为什么不严谨暂且不表，先说它是什么。动拖比，字面意思是动力车和拖车的数量比。比如ICE3，很经典的德国高速动车组，我国CRH3C和CRH380B系列都是以ICE3为原型车的。ICE3为8节编组，4动4拖，即4节车上有电机，其余4节轮子上没有驱动装置（但是制动装置是都有的，安全起见），动拖比就是50%，注意动力车本身也算在拖车总数里。一个数据告诉你德国货多牛逼，50%动拖比的ICE3的总牵引功率，比同样是8辆编组且动拖比75%的CRH2A（以新干线为原型车）要高出将近三分之一，这才叫真正的强劲动力。介绍完动拖比的概念，我们不难理解，对于相同水平的动力配置，动拖比越高的列车功率越高。这就为上述问题提供了一个思路，我能不能把动力单元分散到几个车厢中去，让更多的拖车变成动力车，这样起动性能会更好（因为打破了机辆模式），最高运行速度也会更高（动拖比增加，功率增加）。于是，动车组诞生了（这里暂且不谈动力集中型动车组，也就是垃圾桶，机破之王CR200J）。我们现在看到的动车组都觉得很常见，但这个分散动力单元的思想是很具有跨时代意义的。就像当年被魔改的波音737，把发动机从尾部挪到了大翼悬臂梁下面一样，开创了一个时代。按照这样的定义，其实我们平时坐的地铁也是动车吗？是的。举一个很简单的例子，哈尔滨地铁今天下线的2号线首列电客车，它的动力配置是4动2拖六节编组（1号线也一样，所以我才觉得他俩是一个模子扣的），两端是带控制室的拖车，符号是Tc，第二节和第五节是带受电弓的动车，符号是Mp（p代表受电弓pantograph），第三节第四节则是普通动车，符号是M。提到受电弓，大家可以理解为无轨电车的大辫子，跟它原理上没有任何区别。同理，有些地方可能有轻轨，重庆的单轨，还有一些有轨电车（北京的西郊线，车迷称西溜线，这个故事很有意思，以后可以单拿出来写一篇）等，都可以算是动车的范畴。以下划重点，我来讨论一下图里的问题。先说交流直流。我们知道输电的时候有两种形式，交流和直流。其实这两种电轨道交通都在用，只不过国铁（普速铁路或者高铁动车）用的是交流电（惭愧啊，忘了电压是多少了，好像是3000V吧），城市轨道交通一般用的是直流电。注意是一般，不是全部，这个和设计有关系。区别主要在于用的电机不同，国铁的电力机车或者电力动车组用的都是交流电机，感应电机或者永磁同步电机，而城市轨道交通一般用的是无刷直流电机。有人可能会说无刷直流电机和永磁同步电机本质上没有差别。是的，说的没错，但是用在这个场合里的区别在于，国铁主要承担的是大运量、远距离的运输，需要电机长时间稳定高速运行，而城市轨道交通的站间距相对较短，需要频繁的起动制动，所以在这个语境下把这个电机当成一个直流电机来控制，可以得到很好的快速启动、快速制动特性，加速度可以很大。这就是为什么地铁起动的时候，我们一定好扶好坐稳，因为加速度很大，而坐高铁动车的时候，列车起动可能都没什么感觉，加速很慢，但是加速过程很长。此外，发电厂发出来的电可是交流电，荒山野岭的地方隔几公里就要给高铁修个变电站，咱也得考虑成本啊，修个变压器就得了，再整个整流装置太费钱，干脆你就用交流电吧。但城市轨道交通不同，在城市里一条线路可能也就需要一两个主变电站，对于每公里3亿到7亿的成本，两个大容量整流装置应该用不了几个钱。这就是一种相克相生的关系，我需要长时间稳定高速，就用交流电，但起动性能就差；我需要快速起动快速制动，就用直流电，加速很快，但就麻烦点。这里说一下，这么大功率的电机基本没有用有刷电机的。要是用了我估计得天天换电刷。其实直流交流的区别，上述是业内主要考虑的方面。看到问题里的那个朋友说损耗问题，也有一定道理，确实国铁的线路比较长，高压的交流输电能减少不少损耗，但要知道3000V并不算很高（直接输给受电弓的电压可不是超高压或者特高压的），整个线路的电压都是这个数值，这个电压等级的长距离输电损耗应该也不小，毕竟电压低，所以我个人认为这不是一个主要方面。而且交流和直流相比，如果考虑电缆的集肤效应，同等电压等级的情况下是不是交流的损耗还要高一些？这也是个很有意思的问题，有空可以探讨一下。这个交直流的问题并没有定论，其实也是电客车运用的长期经验反馈给设计者的一种信息。就像舌尖上的中国里的大自然给人类的馈赠一样，倒逼着我们去改进设计，这可能也是工科特有的魅力。好了，现在说说那个“防空警报声”。其实我不说你可能觉得它很陌生，但我要是说“唱歌电机”，你可能就恍然大悟了。是的，就是VVVF，variable voltage variable frequency，变压变频调速，就是那个声音。电机嘛，启动过程中一定要调速控制的，我接触到的电力机车或者电力动车组都是VVVF调速。事实上，不同厂家生产的变流装置发出的声音是不一样的。说到这就不得不提一下三个龙头企业——西门子，阿尔斯通，庞巴迪。这三家企业生产的相关半导体器件制成的变流装置在进行VVVF调速的时候发出的声音是不一样的。防空警报一样的是西门子平台，阿尔斯通和庞巴迪的声音有独特的变化规律，这个区别很明显，每一家公司的产品都很独特，还有其他企业的（比如日立，南车等），但用语言不可描述，感兴趣的话可以来找我，我给你几个B站链接。车迷中有一个群体很喜欢听VVVF声音，有些人可能把它当成asmr了吧。我也喜欢，但我喜欢只是因为我是学电的。再一个，我觉得它很好听。也许工科生不懂浪漫，但工科也有自己的美吧，即使是一段并不具有太大欣赏价值的VVVF声音。今天就说到这吧，我还在等同济轨交院的短信和邮件，不知道我能不能进夏令营。这篇文章放在这，感谢栋宇给我这个平台，也感谢提问题的这位兄弟，我真的是看见有人提了个问题才决定今天无论如何也要写一篇出来。轨道交通是一个很冷门的行业，它融合了机械，车辆，空气动力学，能源动力，电气，控制，土木，材料等等很多学科。我自己预测至少30年内传统轮轨还有发展的余地，传统轮轨会向着智能化、自动化、无人化、绝对安全化、绿色节能化、高速和高效化发展。还有一个，就是磁悬浮，那就是另一个故事了。最近胡志强跟我说了有一些想法，觉得轨交这个行业也挺好的。如果可能的话，我也挺希望他能跟我一起去轨交领域开创一片天地出来。调研和问题招募长期有效，欢迎大家对轨道交通领域有什么问题都可以来栋宇的博客下面找我的文章留言，不定期给大家做点硬核科普。"},{"title":"数字图像处理-课程设计","date":"2020-06-24T01:47:00.000Z","url":"/2020/06/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"这是2020年春季学期我选的外专业课“数字图像处理”的课程设计，觉得比较有趣，故拿来记录留念。在这门课程中，我第一次对图像处理进行实践，老师讲得非常好，推荐大家选这门课，能学到不少知识。 课设题目天文摄影师常常用照相机对夜晚的天空进行拍摄。v1.avi和v2.avi是两段持续几秒的夜晚天空景象的视频。可以注意到，夜晚较暗的光照使得视频中有明显的噪声。设计一个算法用于去除这两组图像数据中的噪声。根据学过的图像处理知识可知，为了实现通过多帧图像数据获取一幅去除噪声后的图像，一种常用的方法是平均去噪法，即计算多帧图像的平均值。分别计算这两组多帧图像数据的平均值，获得两幅去噪图像。用上述方法可以发现去噪结果并不令人满意，原因是各帧图像间存在一定的偏移。请设计一个算法克服这种偏移同时获得较好的平均法去噪结果。 实验原理以视频中的第一帧为基准，逐帧遍历视频图片，由于图片位移间隔时间小，位移小，可以通过特殊方法获得当前帧图片与第一帧基准图片的相对运动大小，求出变换矩阵，通过变换的逆矩阵反向平移当前帧，即可认为观察者未运动，再使用平均值法去噪即可。由于运动时间短，我们忽略运动的旋转部分，仅考虑平移运动。平移运动为二自由度，因此我们只需要找到两张图中一个对应的特征点，即可求得变换矩阵。 涉及的 MATLAB 函数VideoReader;用于读取视频中的内容，将其每一帧都读出来。im2double；将读入的图像转换为浮点形式，便于后期处理。rgb2gray；将rgb图像转化为灰度图，便于后期处理。strel；创建形态学操作的构造元素。imerode；图像形态学腐蚀处理。edge边缘检测。find、max；求得数组最大值并确定最大值的位置。 实验内容与方法首先观察两个视频，可以看出，视频中图像含有许多噪声：这些噪声分布均匀且均值基本为0，可以通过均值滤波的方法消除噪声。但是，由于视频拍摄的抖动导致直接进行多帧均值滤波会使运动物体产生模糊，导致滤波效果变差：因此，想到了使用特征点的方法求出前后两帧的相对运动关系，将后一帧移动到前一帧对应的位置，以消除运动产生的影响。首先使用im2double与rgb2gray将图像处理为浮点型的单值图，之后对两段视频分别选择寻找特征点的方法。对于第一个视频，使用缩小范围的寻找特征点的方法，在原图中找到一个sector区域，作为特征点运动的范围。选取这个位置要保证范围内有且仅有一个比较明亮的点，并且在运动过程中这个点不会跑出这个范围。sector = frame(421:472,681:728);处理前的sector对其进行处理，首先进行形态学的腐蚀处理形态学操作可以改变物体形状形态学腐蚀就是求局部最小值的操作se = strel(‘disk’,1);sector = imerode(sector,se);之后使用find函数找到图片中幅值最大的像素，以这个点的位置作为特征点。[x_1,y_1] = find(sector == max(max(sector)));处理后的sector选择这个点作为特征点进行唯一判断。对于第二个视频，我们使用图中月亮的圆心作为特征点。首先对图像进行canny边缘检测：result_frame = edge(frame,’canny’,[0.3,0.5]);Canny边缘检测包含以下四个步骤：1.高斯滤波滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。而高斯滤波主要使图像变得平滑（模糊），同时也有可能增大了边缘的宽度。2.计算图片梯度边缘一定就是图像中像素变化较快的区域，因此使用梯度就可以检测出边缘。我们使用sobel算子对图片进行滤波，就可以计算出它的梯度。3.过滤非最大值在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为0。这样就可以使检测到的边缘始终是一个像素。4.使用上下阈值确定边缘通过给定的上下阈值确定最终哪些地方属于边缘，哪些地方不是。梯度过小的地方不应该是边缘，而梯度过大的地方也不应被视为边缘 。 想要检测图片中的圆首先想到，可以使用Hough圆变换来求解圆的圆心：首先理解霍夫线变换。霍夫线变换的基本理论，就是二进制图片中每一个点都可能属于某些线。如果将过(x0,y0)的这些条线参数化为一个斜率为a，截距为b的线，由于这条线过这一点，可以将a，b作为变量，画出这个点对应的所有直线参数，在a，b平面中的形式：也是一条直线，并且斜率与截距都是确定的。对于每一个图像中的非零点，都进行这样的操作，并且在a，b平面表示出来。当所有的非零点都表示出来，并进行累加后，a，b平面上数值比较大的点就是原图中可能的直线的参数。同理，霍夫圆变换与直线变换的原理相同，先将圆参数化，只不过这时需要三个参数，得到的参数平面将会是一个三位体中的坐标。这样也是可行的，只不过运算缓慢，通常使用霍夫梯度法来检测圆。圆心是圆所有法线的交汇点，通过梯度，确定这些法线，并求出他们的交点中最有可能的那一个，就能检测到圆心。随后再判断圆心到圆周上点的距离，相同或相近距离数量多，就能确定圆的半径，并且也能检验圆心选择的正确性。在思考过程中，又发现进行完canny边缘检测后，这张图像十分完美，故使用运算更为简便的方法进行圆检测。使用扫描算法检测这个圆的圆心，具体方法为：逐列遍历整个图像，若在每一列检测到两次白点，计算两个白点之间的距离，所有距离中最长的距离就是圆的直径，这时两个点中间的的那个点就是圆的圆心。 实验结果实验所使用代码（Matlab）如下：对于第一个视频： 对于第二个视频： 运行结果：可以看到，经过处理的图像噪声明显减少，并且并未受到观察者视角移动而出现动态模糊的影响。"},{"title":"由LIT MOTORS平衡车获得的理力知识","date":"2020-06-18T04:02:00.000Z","url":"/2020/06/18/%E7%94%B1LIT%20MOTORS%E5%B9%B3%E8%A1%A1%E8%BD%A6%E8%8E%B7%E5%BE%97%E7%9A%84%E7%90%86%E5%8A%9B%E7%9F%A5%E8%AF%86/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"第一次听到Lit Motors平衡车，是在东大四足机器人研讨会上，东大向我们介绍四足平衡的灵感，正是源于Lit Motors。第一次看到，实在是震惊！于是今天再次补习了一下理论力学的知识，希望能给大家讲明白其中的原理。 角动量与力矩根据牛顿第二定律，物体不受力就会保持原有动量，物体受力就会改变动量。在描述刚体平动时，这时十分好用的，因为所有的力都作用在质点上，不会产生旋转，此时刚体每一个微元具有相同的运动形式，所以我们可以把它们看作整体，使用牛顿第二定律进行分析。但是我们发现，当其中有些力作用在质点上时，物体就（可能）会旋转，这时，如果还使用牛顿第二定律，由于每一个微元有不同的运动（速度的大小与方向），再使用牛顿第二定律时会变得十分麻烦（并不是说它就不成立了），物理学家们将旋转的部分单独拿出来，就出现了角动量、力矩的概念：（X代表向量叉乘）角动量：L = J*ω；力矩： M = r X F；旋转起来的牛顿第二定律就成了物体不受力矩就会保持角动量，物体受到力矩就会改变角动量。 假设我们有一块土豆，我们怎么对它进行动力学分析呢？首先，这块土豆可能受很多个力，它们大小不同，方向各异。（红色代表质心，蓝色代表力）作用在刚体上的力，在考虑了旋转的情况下，是不能够轻易移动的！我们通过力的合成原理，移动一个力，就会产生一个力偶，也就产生了一个力矩:M = r X F（r为位移向量）我们把力全都移动到土豆的质心，并且将力矩叠加（力矩是可以叠加的！）（粉色是合成之后的力矩）作用在一点的力，也可通过力的合成原理，得到一个合力（大概）这个作用在质心的力，确定了质心的平动运动，而这个作用在物体上的力矩，决定了物体的转动运动，我们把土豆的运动解耦了！注意，这个旋转是绕质心的旋转，如果旋转时偏心旋转，如下面这个被插了的土豆：本身并没有绕着质心旋转，只是质心本身在绕着转轴旋转，这时就只需要考虑质心平动就行了(每个质点都在做圆周运动)。 角动量守恒与Lit Motors大家先看一段视频感受一下：神奇的自平衡两轮汽车 Lit Motors是不是很神奇？学过理论力学的人一定明白它的原理——角动量守恒。 首先我们来考虑一个简单的问题，为什么陀螺不会倒？静止的陀螺，受到重力与支持力合成产生的力矩，最终一定会倒下：究其根本，正是力矩改变角动量，使其产生了旋转。但是，当陀螺转起来，事情变得有点不一样了!难道转了起来，它的角动量就不变了吗？不是的，无论如何，牛二是不会出错的！只不过，角动量大小没有变（忽略损耗），而是方向变化了，这样也会有一个ΔL！这样，力矩的作用没有使陀螺倒下，而是让陀螺产生了进动！这个例子生动形象地展现了三维世界中角动量定理为我们带来的无限可能与不可思议！ 接着，我们来看Lit Motors的例子先让我们看一看它的主要结构：两个反向旋转的陀螺（飞轮），构成了使其平衡的主要结构。由角动量守恒我们知道，在不受外力矩的情况下，整个系统的角动量是不变的。当我们用内力改变系统某些部分的角动量时，必然会产生另外一个力矩，维持这个角动量不变！我们是用内力（电机）偏转其中一个飞轮，就会产生一个飞轮力矩：两个反向旋转的飞轮同时反向偏转，则抵消掉竖直方向上的力矩，和力矩在前进方向上，就可以防止Roll轴的倾覆！通常使用角度反馈进行闭环控制，实现平衡的功能。这样一想，稚晖君做的这个动量轮倒立摆，其中的原理（动量轮），也是通过内力改变角动量（只不过这次是改变角动量的大小而不是方向），来产生力矩，实现平衡的。只不过这个方法只能抵御周期性扰动，如果扰动带有直流分量，那么系统会一直旋转（加速）。 东大的四足机器人，则是使用了正交的两套Lit Motors的飞轮装置，使其可以同时保持Roll、Pitch两轴的平衡： 角动量定理真的能为我们带来许多意想不到的点子，又发现了下面这个好玩的东西，也是这个原理：神奇立方体 - 可以跳起来、保持平衡和自我运动 @柚子木字幕组"},{"title":"欢迎新的小伙伴加入Star Blog，这里有注册方法哦！","date":"2020-06-11T03:14:00.000Z","url":"/2020/06/11/%E6%AC%A2%E8%BF%8E%E6%96%B0%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%8A%A0%E5%85%A5Star%20Blog%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%93%A6%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"欢迎新的小伙伴加入，在这里成为贡献者，分享自己的学习历程，心得体会，感想感言，任何人都可以在这里注册发文哦!当然身为网站管理员，我也会定期检查站内违法言论进行封禁，请大家注意语言文明！由于这是一个阿里学生服务器搭起来的网站，可能会面临资金问题（没错，就是我供不起了（＞人＜；）），到时候会把服务器硬盘内的数据存为硬盘快照分享出来，大家不必担心数据丢失的问题。还有就是本人学识尚浅，对这些问题仍处于学习阶段，在文章中难免有错误之处，如果大家认为内容有误，欢迎前来指正，如果大家在学习中遇到问题，欢迎与我一起讨论。 大家记得在文章中写出文章的作者是谁哦o(￣▽￣)o 之后就是最重要的注册方式，看这里！！ 点我注册！(❤ ω ❤)点我注册！(❤ ω ❤)点我注册！(❤ ω ❤)点我注册！(❤ ω ❤)"},{"title":"一个并不无聊的人的加入和调研","date":"2020-06-10T23:30:33.000Z","url":"/2020/06/11/%E4%B8%80%E4%B8%AA%E5%B9%B6%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E5%8A%A0%E5%85%A5%E5%92%8C%E8%B0%83%E7%A0%94/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"嗨！朋友们你们好。因为疫情，我们可能已经有半年没见了。也是因为疫情，好多同学开始开发研究新的技能，比如有些人去学了做饭，而闫栋宇这个B就去搞了个blog自己运营。当他第一次把网址发给我的时候，我还以为是个黄片网站，或者是那种，点开就，是吧，发出不可描述且不可关闭的声音的那种。他说是博客，自己做的blog，当时我的表情大概就像2018年他被抢了回来敲我门一样，满脸写着“忽悠”二字。但后来我还是点开了，心里想着万一是黄色网站，我也不亏（虎狼之词狗头保命）。结果发现真是一个blog，很真实，跟闫栋宇的风格有点不搭，除了满屏的二次元。但有什么事是他干不出来的呢？可能是新年新气象吧。之后的日子里，很偶尔的也打开看一眼，发现这家伙搞的这玩意儿有点东西哦。今天他来找我问了点有关磁场的事情，因为我是电机方向的，就胆战心惊地讲了讲，发现还行没讲错什么东西。他邀请我把这个过程记录下来做成像样的东西发到这个博客上来。我说害，我干嘛写这个，我写我擅长的不好吗。他说也行啊，很欢迎。于是我就来了——大家好，我是Captain，微信和QQ名字是5033，如果你加过我你就会知道我是谁。极其业余的轨道交通和民用航空爱好者，目前在准备同济大学轨交专业的夏令营和考研。收到闫栋宇的邀请，今天开始成为此blog的用户，VIP中P。我目前的专业是电气工程及其自动化，当然我就住在闫栋宇隔壁。如果顺利的话明年这个时候我就是同济的研究生了，铁道与轨道交通研究院或者磁浮中心的某个专业（可能是车辆/机械/交通/载具运用）。如果再顺利一些，可能考虑读个博再。所以我是很忙活的。之所以答应他来写这个，是因为我实在想在复习之余找点事情做。人不能总做一件事情，不然就会变傻。像闫栋宇那样，一直学习，就被劫匪盯上了。今天写这篇文章，是想调研一下各位闫栋宇的用户，也给他做个广告，大家有没有关于轨道交通或者民航方面想知道的东西，或者有没有坐火车坐地铁坐飞机（别跟我抬杠地铁轻轨什么的，这里就是个总称。具体的区别我应该也知道）的时候有什么看见觉得很神奇但又解释不了的事情，请在评论区留言，我会考虑写进我的投稿里。给大家提一些思路吧。比如，为什么铁路下面有的有石头有的没有，为什么地铁供电是直流的而高铁是交流的，为什么地铁起步的时候会有像防空警报一样的声音，为什么铁路还是不能完全的自动驾驶，为什么有的铁路旁边会有一个牌子，上面写着“断”或者“合”。再或者，为什么我的微信QQ名字叫5033，这个数字有什么梗，等等吧。欢迎大家多提问题，能解答的我写进文章里，解答不了的我就去研究。近期也在准备同济轨交的夏令营，这一个月期间会集中去看轨交的知识和专业英语，所以第一篇投稿应该不会很晚问世。如果写得好，我就问闫栋宇要一个专属标签。来吧。"},{"title":"电磁学中的物理量","date":"2020-06-10T23:11:00.000Z","url":"/2020/06/11/%E7%94%B5%E7%A3%81%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E9%87%8F/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"感谢6系电机专业的刘逸舟同学用生动形象的例子为我讲解了电磁学的基础知识，没有他就没有这篇文章。 电路中的物理量我们十分熟悉，在电阻上施加电压，就会形成电流。但是对于磁场的各种物理量，能否用类似的“磁路”来进行描述呢？答案是肯定的！ 首先，电能来源于电场，是电子具有的电势能（这个电势能可能来自于化学能——电池，也可能源自于机械能——发电机……等等）进行的释放所产生的能量。那么磁场的能量来自于哪里？由安培环路定律，我们可以发现，电流是产生磁场的方法之一，我们把这个产生磁场的能力定义为磁动势F（永磁体当然也能够产生磁场，因此也具有磁动势），磁动势在磁路中的定位就如同电动势在电路中的定位，具有给予磁场应力的属性。其中I表示电流，N表示线圈匝数，它的单位是 安*匝。有了磁动势，磁场中就会产生出类似电路中电流的东西，这就是磁通Φ；同样能够描述的还有磁感应强度B，它表示单位面积的磁通，更能够描述磁场的散布情况，磁通的单位是韦伯Wb，磁感应强度的单位是特斯拉T。有了电压（磁动势）电流（磁通），磁路中电阻的概念就是磁阻，与电阻类似，可表示成：其中L表示磁路长度，μ表示磁场的，S表示磁通流过的面积。又由于介质的存在，实际磁场强度H与磁感应强度B相差一个系数μ（正是之前的μ），H=μB这样一来，磁动势方程又可以写成： 磁路是怎样向外界回馈能量的呢？这就涉及到一个电机中经常说到的量了——反电动势我们知道一根通有电流的导线在磁场中会产生力的作用，事实上大部分电机的工作原理就是这个简单的原理。但是如果这根导线仅拥有电流就能产生能量，那岂不是能量不守恒了？为了能让能量守恒，磁场会在移动中的导线（也就是常说的切割磁感线）两端加上一个反电动势，这样一来电流与电动势所产生的功率就是导线受力运动所消耗的功率。后来我们进一步拓展这个公式，就变成了人们熟知的反电势公式：（未归定方向，按一般规定的正方向的话确实应该加一个负号）这个公式说明了反电动势取决于磁通变化率，N代表的仍是线圈匝数，在多匝线圈中，产生的电动势叠加起来，就会产生N倍的效果。研究电机的人觉得这很麻烦，于是就把匝数与磁通合体，就有了我们常提到的磁链ψ。于是反电势就与磁链变化率相等了。磁链与电流成正比，这个比例关系就是我们熟知的电感。 总结一下！磁动势由电流而产生 ———— 外界产生磁场的方法（安培环路定律） 经过磁路中的磁阻生成了磁通 ———— 磁场内部的磁芯特性 磁场与导线相对运动 ———— 外界感受磁场存在（法拉第电磁感应定律）"},{"title":"让编译不再麻烦——CMake使用","date":"2020-06-09T21:41:00.000Z","url":"/2020/06/10/%E8%AE%A9%E7%BC%96%E8%AF%91%E4%B8%8D%E5%86%8D%E9%BA%BB%E7%83%A6%E2%80%94%E2%80%94CMake%E4%BD%BF%E7%94%A8/","categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"相信大家在进行C/C++开发时，经常会遇到项目管理的问题。如果你只有一个源文件，那么这将不是什么难事，一条gcc/g++指令，配合上合适的参数，就能够做得很好。但是对于像这样庞大的工程：每个源文件需要一行编译命令，之后还需要链接，才能编译成二进制可执行文件与库，想着想着，我人都傻了Σ(っ °Д °;)っ幸好有的IDE已经很智能地帮我们做了这一点，我们只需要用图形界面配置好工程中文件的组织形式，引用路径，库的位置，就能够一键编译了。（比如交叉编译IDE 我们熟知的Keil）但是IDE灵活性不足，并且有平台的局限性，不能做到轻量化，在使用VSCode这种不带编译器的编辑器的时候，想要更多地自己配置编译方式，就需要用到我们今天的主角Makefile与CMake了！ Makefile为了能够自动化地配置工程，完成编译，人们发明了Makefile这样的文件。在含有Makefile文件的目录下执行make命令就可以执行编译动作。使用设定好的编译器，系统会读取Makefile文件的内容进行编译。Makefile按照目标：依赖的结构组织工程，后面紧接着由依赖变化到目标的gcc（g++）命令。使用自动化变量加上自动寻找依赖的机制，Makefile的确使得编译更加方便，但是要写好Makefile，还是离不开gcc（g++）繁琐的语法，同时还要满足Makefile的语法格式。人们又发明了自动生成Makefile文件的工具CMake。##Makefile的语法 CMake想要使用Makefile，一般的Linux系统都会自带Makefile工具。但是CMake需要自行安装。CMake的设计初衷就是使用简单易懂的CMake语法生成晦涩难懂的Makefile语法，使得配置编译设置就像在IDE使用图形化配置一样方便（事实上确实有图形化的CMake——CMake GUI）。在工程目录创建一个CMakeLists.txt文件，并且创建子目录build，用于放置编译生成的中间文件，进入build，执行cmake ..（注意这个..，表示上一级目录），就会生成我们想要的Makefile文件了，相信这个步骤使用源码安装Linux软件的同学都不陌生。 CMake语句： 新建一个CMake项目main，确定cmake需要的最低版本为2.8 set(CMAKE_BUILD_TYPE “Release”) set(CMAKE_CXX_FLAGS “-O3”) set(CMAKE_CXX_FLAGS “-std=c++11”)确定编译发布版，优化-o3，C++标准为c++11，set就是进行变量的赋值 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)确定输出可执行文件、库文件的位置 find_package(OpenCV REQUIRED)找到系统已经安装的库文件的路径，将其赋值给对应变量。一些比较大的库自己能够告知CMake自己的位置，但是有时就需要我们把FindXXlib.cmake文件告诉CMake（一般库中会提供的）： list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)确定cmake文件的位置 include_directories(${OpenCV_INCLUDE_DIRS})添加头文件目录，相当于gcc（g++）命令中的-I add_subdirectory(./src)添加一个子目录，需要保证子目录中有CMakeLists.txt文件，然后就会执行子目录中的CMake文件，用于多个目录的工程。一般在子目录中将源文件编译为库文件，再在根目录的CMake中链接这个库。 add_library(HELLO hello.cpp) add_executable(main main.cpp)生成一个库、可执行文件，使用源文件（可以是多个），进行编译、链接，生成一个二进制文件，相当于gcc（g++）中的 -o target_link_libraries(common ${OpenCV_LIBS})给可执行文件链接一个库，这个库可以是绝对路径，也可以是已经放在环境变量中的变量。 总而言之这就是CMake的基本原理，确实是大大方便了工程项目配置，已经逐渐成为了主流。 附上在学习高翔老师《视觉SLAM14讲》时使用的CMake文件，留做参考。 ./中的CMakeLists.txt project(main) cmake_minimum_required(VERSION 2.8) ./src中的CMakeLists.txt cmake_minimum_required(VERSION 2.8) "},{"title":"浅尝OpenGL","date":"2020-06-04T18:17:00.000Z","url":"/2020/06/05/%E6%B5%85%E5%B0%9DOpenGL/","categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"学习了OpenGL的一些基础知识，来分享一下!Learn OpenGL首先，OpenGL到底是什么？OpenGL是API，没错，但OpenGL更被认为是一种标准，然后每个显卡公司，会针对这种标准，编写自己的一套API函数。这就带来了一个麻烦，代码的可以执行问题。对于不同的一套显卡设备，API函数不同，让移植变得很困难。因此，在进行OpenGL开发之前，通常使用一种函数映射的库将硬件对应函数对应到一套公用的函数上，只要使用一套公用的函数API，就能够方便地进行移植（也方便了学习）。因此我们先将glad库（正是负责函数映射库）加入到工程中。配合使用的OpenGl库是glfw库，矩阵运算库选择的是glm库，图片操作库选择的是stb_image库，这些库都需要用户先安装。至此，我们的OpenGL开发环境就搭建完成了。 坐标变换OpenGL的最基础元素是顶点元素，三个顶点可以组成一个三角形，构成了最基础的图形，OpenGL的所有图形均是由三角形构成的，这点一定要明确！（即使我想要一个正方形，我也只能通过两个三角形来构建）首先我们通过某种方式（自己定义在内存中、导入各种格式的模型等）得到一个物体的顶点坐标，这个顶点坐标称为局部空间（Local Space），也就是最初物体的坐标，一般将物体坐标放在中央。我们通过坐标变换，对每个顶点进行变换（Model Matrix），让他出现在应该出现的世界坐标的位置，这个变换包括6个自由度，分别确定了物体在世界坐标下的三维位置与姿态（称之为位姿）。之后，需要将这些点再次变换到以摄像机为中心的坐标系下 （View Matrix），以实现摄像机的自由运动。但是这样直接显示在屏幕上，OpenGL会直接去掉这些点的Z坐标，会有一种不真实的感觉（总而言之就是没有近大远小的感觉），我们再使用投影变换，再将结果同时÷Z坐标，将每个平截头体内点变换到屏幕上，这样我们就得到了一个三维点在二维平面上的坐标了，OpenGL将其画出来就行了。（甚至你可以直接使用小孔模型进行变换） 着色器Shader机器是如何把图像画出来的呢？学习OpenGL，其中重要的一点就是学习Shader的编程（GLSL语言）以及它的工作流程（渲染流水线）下面这张图展示了渲染流水线的工作流程：上图每一个着色器对应一个shader文件，但是大部分情况下我们只需要顶点着色器（VERTEX SHADER，简称为VS）和片段着色器（FRAGMENT SHADER，简称为FS）即可，顶点着色器用于绘制点，片段着色器用于绘制光栅化后三角形内每一个像素的颜色。我们在程序里使用API函数编译、链接这些SHADER文件，构成一个SHADER项目，供我们在渲染中使用（SHADER是跑在GPU中的！）。VS接受程序存在内存中的点的坐标（不只是位置，还可以包括颜色、法向量等其他属性），对其进行坐标变换，将结果送入FS，FS接受VS处理的结果，并在整个三角形中对接收数据进行插值，相当于接收到的数据不再是三个顶点而是光栅化后的三角形内的许多像素，再依据程序对这些像素进行运算（需要GPU并行加速），输出每个像素的颜色，进行渲染。 光照与纹理有了上面的基础，在OpenGL中实现光照效果就很简单了（因为我们已经知道如何操作每一个像素的颜色），重中之重在于找到合适的光照模型：在这里我们使用冯氏光照模型，一个物体的颜色由三个分量加权得到：ambient：环境光占有分量最少，描述的是物体在完全黑暗处由于极少量反射呈现的颜色。颜色取决于物体颜色。diffuse：漫反射占有分量最多，强度大小由光源向量与面的法向量的内积确定。颜色取决于物体颜色。specular：镜面反射占有份量也比较多，强度大小取决于反射后的光线向量与视角向量的内积。颜色同时取决于光源颜色与物体颜色。 由于FS中获得的是VS传来值的插值，也就能够获得每个像素点的坐标，因此在FS中进行光照计算能够使得光照更加真实，但是运算量也会更大。 这样一来，每个像素经过渲染流水线就能够产生一个特定的颜色，显示在我们的屏幕上。 最后我们就可以实现一些简单的渲染啦，不要说我技能点点歪了，学习渲染也可以图形化一些问题，也是解题的一大工具呢！ 将我的一个入门小项目源码放在这里供大家学习： 使用的Makefile： "},{"title":"HTTP协议最常见的两种请求方法","date":"2020-05-14T01:25:00.000Z","url":"/2020/05/14/HTTP%E5%8D%8F%E8%AE%AE%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/","categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"运行在网络中的诸多协议，组成了你生活中所有网络应用的基础。这些应用层协议常见的有如下几种： http：最常见的协议，实现超文本传输，浏览器中文本图像在服务器与客户端之间传递； ssh：安全shell，远程连接服务器的shell； ftp：远程文件系统； dns：域名解析； smtp：邮件协议；等等等等…… 只要掌握了这些协议的内部原理，我们就可以随意操作实现功能了。这次我们来讲一下使用python的requests库实现http协议的请求http协议通过客户端（浏览器）向服务器发出请求，服务器相应这些请求，文字，图像就能够显示在我们的浏览器上了！这些请求有如下几种：我们主要讲解两种最常见的——GET、POST GETGET请求是一种显式传递信息的方式，通常用于获取服务器发来的数据而做出请求。常见发起GET请求的方式就是URL。我们在浏览器中输入一个URL，点击访问，就是发起了一次GET请求GET请求的内容通常是直接显式地显示在URL后面，以?分隔的。GET返回的内容就会被浏览器理解，显示在界面上了：使用浏览器自带的抓包工具，我们来看一下GET请求与响应都是什么样的点开B站的一瞬间，扑面而来的GET请求瞬间刷屏，当然这些都是第一个GET所带来的连锁反应首先General中告诉我们这是一个GET，目标URL是B站，IP也可以看见，status code就是状态码，200表示成功大家常见的404、502也是状态码： 关于状态码详细——百度百科后面接着是Request Header，请求头，是我们发给服务器的数据：这其中包含着语言、所用浏览器、操作系统、编码方式等等，服务器拿到这些数据进行分析，来给你做出响应（反-反爬虫最基本的就是伪造请求头(●ˇ∀ˇ●)）当然这里面最重要的是cookie信息，它保存着我的登录信息，利用cookie就可以实现免重复登陆的功能。B站接到这个请求后，会进行处理，返回给我们一个Response Header：还有Response的内容，也就是B站主站的index.html，通过这个html我们就知道接下来该去哪些URL去GET些什么了。接下来，就是一系列GET来搭建出整个网站所呈现出的样子，比如一些图片啊、script啊之类的。至此，通过一系列的GET我们访问到了B站。 POST当我们想去向服务器传递内容时，比如登陆时传递用户名密码，发送弹幕、评论，该如何发送请求呢？这时就需要POST登场了。与GET不同，POST是一种隐含的信息传递方式，因此它更安全，适合向服务器传递隐私内容。常见发起POST请求的是FORM表单。这次我们以发送弹幕为例来看看POST是如何工作的：点击发送弹幕，发现，我们确实发出了一次POST请求（忽略下面这个failed的GET）除了Request Header和Response，我们发现，POST还多了一个Form Data表单：这个Form Data中就保存了我们要传递给服务器的数据，比如弹幕的字体大小、颜色、内容、发送时间、BV号等等。服务器接收到这样的POST请求，就能做出反应（在视频上显示出该弹幕），同样，评论与登录也是一个道理。得到的Response也挺有趣的(/▽＼)"},{"title":"双系统？虚拟机？Docker？","date":"2020-05-10T00:20:00.000Z","url":"/2020/05/10/%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9FDocker%EF%BC%9F/","categories":[["工具","/categories/%E5%B7%A5%E5%85%B7/"]],"content":"Linux环境由于它可移植性强，轻量化，底层化的特点，得到了开发者们广泛的应用。它在服务器市场，移动嵌入式市场，机器人领域有着重要的应用。但是，有的应用对Linux支持很不友好（腾讯，说的就是你！），甚至没有Linux版本，这时候就需要另外一个Windows环境来运行Windows程序，这是，两个环境之间的切换就成了问题。 今天我们来讨论一下在一台机器上运行Windows环境与Linux环境的方法。 为什么程序对操作系统环境有要求首先，我们抛出一个问题，是不是所有程序运行都需要操作系统的支持？紧接着，又有几个问题，为什么Linux下编译的程序不能再Windows环境下运行，反之也不行呢？ 对于第一个问题，不是所有程序都需要操作系统才能够运行，最常见的，单片机里跑的程序，U-Boot、grub这样的引导操作系统程序，还有操作系统本身，这些都是不需要运行在操作系统环境下运行的，我们称之为裸机程序。逻辑程序唯一要求的，就是芯片的架构。ARM、x86、RISC-V架构的芯片跑的一定不是相同的程序。这也就是操作系统需要对不同架构芯片做版本移植的原因。 第一点就是编译器的问题。不同的操作系统，有不同的内核提供的系统调用，这就对应着不同的编译器，才能编译不同操作系统下的程序。默认的编译器总是编译自己操作系统的代码，如果想编译运行在其他操作系统的代码，就需要交叉编译工具链（编译器、链接器……）平时一点就ok的按钮，其实就使用了交叉编译工具链，这就是IDE的力量(。・∀・)ノ 还有就是库的问题。Win下动态链接库是.dll文件，静态链接库则是.lib文件，目标文件是.obj，而在Linux下，对应的分别是.so，.a，.o文件。最终一点，可执行文件格式也不同，Win是大家耳熟能详的.exe文件，而Linux没有特定的后缀名。最后两点本质上也是由于编译器、链接器不同导致生成的文件格式也不同。 双系统解决方案一：双系统，最简单粗暴的方法，在一台电脑中安装两个操作系统。方便的是拥有完整的环境，操作系统可享用完整的计算机资源，缺点则是切换麻烦，文件传输麻烦，多个操作系统不能同时工作。这里还要注意的是，操作系统的引导是由引导程序来进行的。BIOS会按顺序对每个硬盘分区最前面的区域进行查找，如果找到了引导程序，就执行它。如果不想启动先被找到的操作系统，则由引导程序将启动权交给下个分区内的引导程序。不过，由于Windows自带的引导程序无法启动Linux，但是grub却可以启动Windows，所以需要先安装Windows再安装Linux，否则Linux的引导会被覆盖。 虚拟机解决方案二：虚拟机（VMWare）。虚拟机的具体实现需要OS的知识才能够理解，本菜鸡就不做过多解释了，总之可以理解为这是一个应用程序，在应用程序内又跑着一个操作系统。虚拟机的优势就在于两个操作系统可以同时运行，交互良好（可以互相传文件），缺点就是两个操作系统共同占有一块计算机资源，性能下降，并且还有虚拟机对显卡支持不好的缺点。 Docker与虚拟机类似，Docker也是跑在宿主OS中的程序（更准确是容器）这个容器能够隔离内部程序与操作系统，且内部不需要安装操作系统，就能跨平台运行程序，上手容易，轻量化，很好用！ 对比Docker与虚拟机 基于Docker的人工智能小助手艾拉前几天突然心血来潮，拿图灵机器人+酷Q做了一个简单的人工智障小助手，结果发现酷Q只能在Win下运行，想尽一切办法最终发现酷Q有一个on docker版本，赶紧拿来使用。几行命令，这个人工智障就已经跑在我的Linux服务器下了。这个Docker使用VNC远程桌面作为图形界面交互，我把它放在了我服务器的7070端口，进入VNC界面，你就会发现里面是一个实打实的Windows环境。 具体命令见这篇：酷Q on docker 安装部署、使用及二次开发教程 顺便吐槽一下，现在的腾讯对QQ的外部接口是越来越不上心了，果然微信才是主流嘛……"},{"title":"浅浅浅浅浅谈计算机求数值解的方法","date":"2020-05-08T23:01:00.000Z","url":"/2020/05/09/%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B1%82%E6%95%B0%E5%80%BC%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"梯度下降法之前最小二乘的那篇文章中，我们知道了最优化的最基本方法就是求出cost function的极值点。对于简单的、已知表达式的cost function（就比如最小二乘），我们可以直接通过偏导数等零的方法求得极值点。但是对于表达式复杂、甚至无法获取表达式的cost function，求偏导的方法就无能为力了，我们只能借助计算机这个不是很聪明但是算的很快的工具，通过迭代的方法，求出极值点的近似解。 怎么个迭代法呢？极小值点，就是附近一片区域中函数值最小的那一个点，将函数看作一块地面，我们如果在极小值附近区域放上一个小球，小球一定可以滚落到极小值点的位置。如果我们使用计算机来模拟这个小球的行为，不就能够得到极小值点了吗伟大的科学家们利用这个原理，发明了梯度下降的方法来求解极小值点： 将一个初始点送入梯度下降算法（小球放在初始某个位置） 使用差分代替微分，求出初始点位置函数的梯度（地面的梯度方向即为小球下降趋势的方向） 使当前这个点向梯度反方向前进，速度为梯度大小，时间为步长τ，得到一个新的点（近似模拟小球下降的过程） 将新得到的点作为起始点，重复执行此过程，直到梯度大小小于某个阈值δ，停止迭代，得到结果（小球稳定在地面的最低点处） 实际上这是一个很简单的算法，我们只需要规定步长τ与阈值δ就能求出函数的极值点其中，步长τ越大，算法收敛的也就越快，但是在步长过大时可能出现在极值点附近震荡而无法进入阈值范围而陷入死循环；而阈值δ越大，限制条件相当于越宽松，收敛也会更容易，但是精度相对变差，δ越小则反之。 这个简单的算法也有着诸多限制条件： 目标函数的点的细度一定要足够，否则求取梯度会不精确，极值点的精度也会变差，必要时可能需要插值 目标函数在一定范围内一定要平滑，即梯度函数要连续，不能出现梯度的突变，否则不能收敛 目标函数在一定范围内一定要连续 没有全局性。可能会求得局部极小值，即最优化问题中的局部最优解 牛顿迭代法同梯度下降法一样得思路，牛顿迭代法是用来解决方程的解的问题的 我们通过对f(x)的迭代，可以的出一元方程f(x) = 0的近似数值解，方法如下： 同样，选取起始点 求出起始点位置函数f(x)导数 向着导数反方向移动该点，步长τ，得到新的点 将新点当作初始点，迭代运算，直至新点处函数值小于阈值δ，得到方程近似解 可以看到梯度下降与牛顿迭代具有很强的相似性，二者的方法与性质也大体类似，本质上，二者都是通过对f(x)泰勒展开式进行近似（取一阶导数项），通过近似式进行迭代求解。这种迭代求数值解的思想值得我们借鉴与学习。"},{"title":"FIR和IIR之间的故事","date":"2020-05-08T06:31:00.000Z","url":"/2020/05/08/FIR%E5%92%8CIIR%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%85%E4%BA%8B/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]]},{"title":"从 最小二乘 到 最优化算法","date":"2020-05-06T22:30:00.000Z","url":"/2020/05/07/%E4%BB%8E%20%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%20%E5%88%B0%20%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"在讲最小二乘之前我们先普及一下插值和拟合的含义 插值与拟合数值分析中，有两大利器在工程实际的数据处理中有着很重要的地位，它们就是插值和拟合。 插值指的是对于已知的离散序列，使用同时过这个序列中的点的函数将其中间间隔的部分填充满，使任意一个点都有数值与其对应。最常见的一种应用就是，在图像处理领域中，对图像进行线性变换（如放缩、旋转、仿射变换或透视变换等）后，原来对应整数坐标上的像素点可能在新的图像中处于非整数坐标，若想要构建变换后的图像，就需要依据这些已知像素还原出整数坐标上的未知像素，这里就用到了插值。插值使用经过已知序列得函数填充中间部分 同样是已知序列，若想要求得一个函数，能够最接近地表达出这个序列，但是不要求这个函数经过这个序列中的任一个点，这种方法就称作拟合。拟合也有着重要得工程价值，在神经网络、系统辨识等领域均有应用。下图展示了欠拟合、比较好的拟合和过拟合三种情况拟合使用不一定经过已知序列的函数表达已知序列 最小二乘的原理最小二乘法是一种很常用的拟合手段。上面提到了，拟合是寻找一个函数，能够最接近地表达出这个序列，最小二乘算法对这个最接近地下了一个定义，即均方误差最小。通过数学表达就是这个ε最小 想要进行最小二乘，就先要知道想要拟合的目标函数是怎样的。对于一个有n个未知参数，n个自变量的函数f（这个函数应该是n个自变量对于n个未知参数的线性组合），我们进行n阶最小二乘，这时我们的序列数据也应该是n维的（若小于n维，则应该根据拟合函数中变量的变化方法对其进行变化）对非线性函数这样线性化 这样一来，我们能够用矩阵方便的表示这个不存在的方程X是序列中m个n维点组成的矩阵，其中m应该大于n，否则方程可解或多解，也就没有拟合的必要了；β是n维线性函数f的系数矩阵；y是m个n维点对应的纵坐标；三者满足关系：通过这个方程求出β即求出拟合函数就是我们的目标，但由于m&gt;n，显然这个方程无解，我们根据最小二乘的条件均方误差最小，将等式相等换为一个要求更小的约束，即在β变化时，ε(β)取最小值。这样我们就将最小二乘法化简为一个求多元函数极值点的问题。高中数学我们就学过，一个函数极值一定出现在导数为0的情况下，我们对ε(β)求导使其等于0，得到：这个β_hat代表对β的最佳估计（观测）值。 从另一个角度理解最小二乘我们回到得到一个无解的矩阵方程这一步：无解，则代表着没有一组对于X向量组的线性组合能够表示y向量，本质上是由于y向量不在X矩阵的列空间中。但是，如果选择一个y’，使其是y在X矩阵列空间的投影，这样Xβ = y’就有解，我们也许就能最近似地“求出”这个方程组的解。利用向量投影的法则，我们得到了和上面方法同样的结果：数学真的很神奇！ 从 最小二乘 到 最优化（Optimal）算法最优化算法是什么？最简单的理解，就是通过改变方法与参数，使得某个特定的代价函数（cost function）取地最小值（即代价最小），这样确定的参数，就是最优化系统中的最优解。最小二乘拟合的过程，也可以看作一个最优化问题，这个过程的代价函数就是ε(β)。类比推出，求取最优解的一个思路就是对代价函数求导，在其导数等于0的位置，就是代价函数的极值点，也就是可能的最优解。对于带有约束的问题，使用拉格朗日乘子法来解决拉格朗日乘子法本质上就是是：在满足约束条件时梯度相等的位置就是最优解。如下图：最优化问题是一个很深奥、很复杂的问题，但是从最小二乘切入来理解，也是一个不错的思路 延申阅读：凸优化、拉格朗日乘子"},{"title":"留数。。。也太难了吧","date":"2020-05-06T04:49:00.000Z","url":"/2020/05/06/%E7%95%99%E6%95%B0%E3%80%82%E3%80%82%E3%80%82%E4%B9%9F%E5%A4%AA%E9%9A%BE%E4%BA%86%E5%90%A7/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"学习复变函数时，我们一定曾被它折磨得死去活来，但是在实际应用中，这个家伙还算有点用处，今天就来介绍一下这个令人又爱又恨的家伙——留数。主要搬运一下华中科技大学复变函数MOOC的内容。 首先我们要了解复变函数的一个重要概念——孤立奇点：我们最常见的孤立奇点当属极点了，极点在判别系统稳定，系统微分方程以及差分方程的求解都有重要的作用，所以研究这些特殊的孤立奇点也很有必要。 首先我们需要知道一个复变函数积分的重要性质： 留数是对复变函数f(z)洛朗级数展开后闭路积分唯一剩余的洛朗系数，它的定义如下： 根据那个闭路积分，引出留数定理： 对于极点这一类型的孤立奇点，留数有如下的计算法则：对于一阶极点，有如下法则求取留数： 说了这么多关于留数的性质，留数以及留数定理有什么用呢？ 留数定理的应用：在求取z逆变换时，就可以使用留数法： 其实，留数定理化简了闭路积分的运算，我们如果能将实函数的定积分表示成闭路积分，那么就可以利用留数简化定积分的运算。"},{"title":"傅里叶变换的两种变形——L&amp;Z","date":"2020-04-23T22:11:00.000Z","url":"/2020/04/24/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8F%98%E5%BD%A2%E2%80%94%E2%80%94L&amp;Z/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"拉普拉斯变换函数能够进行傅里叶变换的条件是绝对可积，但是许多信号都不满足这个条件，为了能对更多信号进行频域分析，引入一个收敛因子σ，这个函数就变成了绝对可积的了：这样对这个新函数的傅里叶变换就成了：其中：这个算子e^-st是这样螺旋收敛的：拉氏变换将微积分运算变为代数运算，可以很方便地用来解微分方程。 Z变换离散时间傅里叶变换DTFT需要序列满足绝对可和的条件，同样的道理，也让它加上一个收敛因子σ：其中：也可认为z变换就是对离散信号的拉普拉斯变换。z变换将序列的差分求和运算变换为代数运算，可以很方便地用来解差分方程。 以上这二者由于收敛因子的引入，需要注意收敛域的明确。 离散系统设计对于一个连续系统，可以通过系统s域传递函数的零极点判断系统性质；而对于一个离散系统，可以通过系统z域传递函数的零极点判断系统性质；由s到z是一个复平面上一一对应的映射关系，s平面上稳定性分割线Re=0在z平面就变成了|z|=1，称为判断离散系统稳定性的基本判据； 我们很难实现通过微分方程来更新系统（模拟电路），但很容易实现差分方程更新系统（数字处理器）！对于一个离散控制系统，我们可以先在连续状态下设计控制器（使用微分方程），再离散化（转化为程序能实现的差分方程）：用系统s域传函离散化为系统的z域传函（利用泰勒展开近似为z的多项式形式），再来求出系统的差分方程，即可应用在数字控制器中，这是系统离散化的一种常用的手段。利用z变换的性质，有很重要的方法来求差分方程：x[k] &lt;-&gt; X(z)x[k+1] &lt;-&gt; z*X(z) 对于观测器与滤波器，这个离散系统将一直在程序中更新迭代，得到离散的输出；而对于控制器，最终得到的输出序列再经过零阶保持器，又变为连续信号输入被控系统。"},{"title":"简简单单锁相环PLL","date":"2020-04-22T17:20:00.000Z","url":"/2020/04/23/%E7%AE%80%E7%AE%80%E5%8D%95%E5%8D%95%E9%94%81%E7%9B%B8%E7%8E%AFPLL/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"玩过单片机的同学们一定听说过锁相环（PLL）这个东西，就是这个锁相环的倍频作用使得我们能够仅仅使用8MHz或者12MHz的晶振获得几百甚至上千兆Hz的主频。但是，你是否真的了解锁相环背后的原理？锁相环除了这样倍频的作用，又有那些其他的作用呢？ 今天我们来简简单单地介绍一下锁相环 传统意义上的锁相环百科上这样说：锁相环通常由鉴相器（PD，Phase Detector）、滤波器（LF，Loop Filter）和压控振荡器（VCO，Voltage Controlled Oscillator）3部分组成前向通路，由分频器组成频率相位的反馈通路，如图所示。根据锁相环的框图，可以看出，锁相环输入信号与反馈得到的信号送入鉴相器，鉴相器通过比较二者相位，输出相位差送入滤波器，随后滤波器输出控制压控振荡器来产生一定频率的信号。本质上讲，这就是一个反馈控制系统，鉴相器输出相位差如果构成负反馈的话，这个系统就能使输出信号平稳跟踪输入信号，二者频率是相同的。那锁相环又是如何做到倍频的呢？ 还是利用自动控制原理的知识来解释，如果我们反馈输出信号的本身，由于系统想要收敛使得误差为0，那么系统输出信号就会跟随输入信号；但当我们反馈输出信号的N分频，系统还想要收敛使得误差为0，这时反馈信号会跟随输入信号，最终的输出信号就会变成输入信号的N倍频。直接分频是很容易做到的，但直接倍频却很难，我们通过一个简单的反馈控制系统和分频器就实现了一个倍频器，这就是控制理论的魅力所在。 了解了锁相环倍频的原理，大家会不会提出一个疑问，就是为什么锁相环不能有非整数的倍频？其实这是因为锁相环处理反馈的鉴相器是通过比较两个信号的相位来计算误差的，而并不是比较频率（个人认为比较频率是很难实现的），非整数倍频就需要非整数分频，这可能会导致相位差不能收敛使得系统失控，只有整数倍频率能够使得相位差收敛至0。 锁相环的妙用锁相环除了能够实现平稳跟踪信号频率，倍频，还有其他的妙用：在电机无传感器估计电角度时，我们通过扩张状态观测器可以观测到α、β两相的反电动势大小，到了这一步该如何获得电角度呢？最简单的方法大家可能已经知道了，就是反三角函数法，直接使用arctan函数即可计算得到对应的电角度。但由于观测器参数设置等原因，可能导致电角度不平滑，使得矢量控制不平滑，电机性能下降。这时可以虚拟一个电角度，使这个电角度跟踪通过观测得到的电角度，可以使电角度得到平滑，如下图：这里通过ΔE来确定θ_hat向目标收敛的速度，也就是ω。不仅是观测器可以利用这种方法使角度收敛，高频注入法也可以使用锁相环获得角度。 本质上讲，锁相环相当于一个低通滤波器！"},{"title":"出息啦！","date":"2020-04-18T04:19:41.000Z","url":"/2020/04/18/%E5%87%BA%E6%81%AF%E5%95%A6%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"![4ZL893UZXIA@LY7@1U`VG92.png]1 被谷歌爬到了！可惜百度还是没有(;´༎ຶД༎ຶ`)"},{"title":"卡尔曼滤波器家族与观测器","date":"2020-04-16T02:28:00.000Z","url":"/2020/04/16/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%AE%B6%E6%97%8F%E4%B8%8E%E8%A7%82%E6%B5%8B%E5%99%A8/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"在之前的文章（现代控制理论总结1——Linear部分）中曾经提到过观测器。观测器可以这样理解：使用软件构建一个虚拟的系统，使这个系统与实际系统同步更新，并根据给予的输入与传感器测得的输出不断更新、纠正这个虚拟系统，使得系统的状态变量趋近于实际系统，这样我们就能够获得一些测不到的状态变量，来进行状态反馈。而卡尔曼滤波器则通过对系统噪声（高斯分布噪声）建立模型，在更新系统状态的同时也在更新系统的方差，也可以看作是同时更新系统的均值与方差，同时考虑状态更新方差与测量方差，得到一个卡尔曼增益K，这个卡尔曼增益则对应着观测器中的观测增益L。使用每次后验的均值作为结果，来不断更新系统。 我们来进一步，仔细地看一看Kalman Filter是如何工作的。 卡尔曼滤波KF首先要注意，卡尔曼滤波器只适用于线性系统，并且噪声应为高斯分布的系统。既然是一个线性系统，那么我们就可以使用状态方程与测量方程（对于离散系统，使用差分方程）来表示这个系统:通过以下方程更新一个虚拟系统：其中参数的含义：我们先使用上一时刻估计得到的状态变量，通过一个完全理想化的系统（不一定完全准确），得到本时刻先验的状态变量；使用同样的系统更新本时刻协方差矩阵的先验，注意由于每次更新都使用了不准确的更新方程，我们要将这个不确定性考虑进去，所以每次都要引入系统更新带来的噪声的协方差；由于使用的是理想的系统，没有考虑系统误差、扰动带来的影响，这样的开环观测器一定是无法准确观测的。接着使用测量方程，通过先验的状态变量得到先验的测量量；同理，使用相同的测量方程得到测量量的协方差，这里同样也要引入一个由于每次测量不准确噪声的协方差；使用状态量协方差与测量量协方差计算卡尔曼增益；使用卡尔曼增益作为权重，权衡测量量与先验状态量，来更新本时刻的后验状态量。至此，一次迭代就完成了，让这个虚拟系统运行下去，就能使估计值趋向于真实值。 卡尔曼滤波器主要需要调整的参数使Q、R两个协方差矩阵的值，而其他的值都会在迭代中收敛，如何整定Q、R参数呢？我们知道Q、R代表着系统更新引入噪声的协方差与测量引入噪声的协方差，我们很容易想到，Q越大，我们就会越“相信”（“相信”体现在卡尔曼增益上）测量，滤波器收敛变快，但由于测量带来的噪声也随之增大；而R越大我们则越“相信”系统更新，结果更加平滑但收敛变慢。通常我们忽略各个状态变量之间、测量量之间的影响，认为它们使无关的，这样得到的Q、R阵都是对角阵，更方便我们去调参。 何时该使用卡尔曼滤波器？当系统方程比较清晰，并且单独使用传感器误差难以接受的情况下，使用系统方程辅助获得数据也是一种弥补的方法。与此同时，卡尔曼滤波不仅能够对传感器数据进行平滑，还能够得到完整的状态向量，这意味着我们能够通过一个单独的位置传感器得到速度，加速度等等，这样我们就能对目标进行预测，Robomaster比赛中的视觉目标跟踪，射击预瞄提前量利用的就是这样的原理。 扩展卡尔曼滤波EKF上面提到的最基本的卡尔曼滤波仅适用于线性系统，假设有非线性系统如下，我们该如何处理呢？最简单粗暴的方法就是线性化。如何线性化一个非线性系统，在扩展卡尔曼滤波中，我们使用非线性函数的一阶偏导矩阵来代替线性的系数矩阵，这样来更新那一组方程就可以啦！具体怎么做呢？请看下面的式子：这组方程与上面的有什么区别呢？细心的小伙伴可能发现了，我们合情合理地将先验更新的方程替换为了非线性形式，其他好像都没有改变。但是对于一个非线性系统，我们如何确定这个A矩阵与H矩阵呢？答案上文已经提到了，就是使用（该点处的）一阶偏导矩阵对非线性系统进行一阶线性近似（相当于只取f、h泰勒展开一次项的系数），这个一阶偏导矩阵也就是大名鼎鼎的雅可比矩阵：注意到A一定还是一个nxn的方阵，H的阶数也没有改变（仍取决于状态变量个数与测量量个数）其他步骤均与上面提到的一致。 无迹卡尔曼滤波UKF在实际应用中，对于非线性程度比较大的系统，一阶近似往往效果不是很理想，聪明的人们又想到了一种方法来解决非线性系统的卡尔曼滤波，无迹卡尔曼滤波就这样诞生了。无迹卡尔曼滤波的本质同它的两个兄弟一样，也是通过协方差从概率角度计算卡尔曼增益K进行迭代的，不同的是，不是像线性系统那样仅根据迭代就能计算出协方差，而是在均值周围取sigma点，让这些点真正的去参与系统运算，再使用这几个sigma点的协方差参与运算，进行迭代。这些sigma点的个数与位置的选择也是有要求滴！ 再升级该怎么办？再升级？再升级就是粒子滤波啦！相当于有更多的sigma点来还原系统，效果当然也更好，就是计算量更大了。粒子滤波是什么？看这儿：particle filtering—粒子滤波（讲的很通俗易懂） 总结一下这篇文章带大家十分粗略的了解了三种卡尔曼滤波的形式，其中少了许多数学推导部分，尤其是概率相关的数学推导，这些部分我不是很熟悉，仅能通过定性的方式去说，如果想要了解本质，大家可以看这篇文章：Kalman_Intro。最后用一张图总结："},{"title":"初探自抗扰控制（ADRC）","date":"2020-04-14T20:10:00.000Z","url":"/2020/04/15/%E5%88%9D%E6%8E%A2%E8%87%AA%E6%8A%97%E6%89%B0%E6%8E%A7%E5%88%B6%EF%BC%88ADRC%EF%BC%89/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"学习控制的小伙伴们大概都听说过自抗扰控制ADRC，但你未必知晓自抗扰控制的提出者——韩京清先生。是的，自抗扰控制这一理论方法，正是由我们中国科学家发明的。韩京清，系统与控制专家，我国控制理论和应用的早期开拓者之一。用最优控制理论提出了拦截问题中新的制导概念和方法；在国内率先推动控制系统计算机辅助设计软件的开发和研究。这次我们就来初步了解一下自抗扰控制。韩老提出的自抗扰控制由三部分组成： 跟踪微分器（TD） 扩张状态观测器（ESO） 非线性状态误差反馈控制率（NLSEF） 这三部分一起，构成了ADRC自抗扰控制理论，但是，这三部分不仅仅只能用在ADRC技术中，还可以单独提取出来，与其他控制理论相结合使用。例如跟踪微分器TD就可以用来产生平滑信号来跟踪输入，并且还可以计算该平滑信号的微分，扩张状态观测器ES还可用在观测系统除状态变量外的一些扰动上等等。由此可见，自抗扰控制不仅是一种控制方法，同时还为工程师们提供了解决工程问题的方法。下面我们分别讨论ADRC这三个重要组成部分。 跟踪微分器TD在讲跟踪微分器之前，想一想平常我们是怎样对数字信号作微分的？是不是用差分替代呢？常用的几种方法：z变换方法：后向差分法：前向差分法：双线性法：使用这些方法可以将连续系统传函（s域）转化为离散系统传函（z域），这样即可离散地描述微分，但是往往这样面临着局限性，通常由于传感器测量噪声导致微分噪声明显。 再让我们来看一下TD是什么样子的，其中：代码实现： 跟踪微分器的参数主要有两个：快速因子r和滤波因子h。其中，r与跟踪速度呈正相关，然而，随之带来的是噪声放大的副作用； h与滤波效果呈正相关，但当h增大时，跟踪信号的相位损失也会随之增加。简单来讲，可以将TD理解为一个低通滤波器，输出的x1就是滤波后的结果，它是跟踪输入信号的。输出的x2则代表对x1的微分，这样降低了输入信号噪声对微分效果的影响。在自抗扰控制中，使用跟踪微分器获得状态变量的微分，是用来在系统动态跟踪目标时，前馈掉系统输出中关于x的微分项的。比如在电机伺服控制中，可以通过跟踪微分器跟踪x_des的微分，在速度目标中加以补偿，以达到更好的动态效果，这样的方法常称为速度前馈。 扩张状态观测器ESO为了进一步地消除扰动对系统的影响，我们通过扩张状态观测器对扰动进行观测，通过前馈补偿到系统模型中，这样的方法就叫做扩张状态观测器ESO。在系统微分方程中加入扰动项，并且将扰动视作状态变量（通常视扰动的导数为0），这样构造的新的状态方程就叫做扩张（Extend）的状态方程。使用这个状态方程构建观测器，通过测量量来观测状态量，就能得到扰动。这就是扩张状态观测器ESO的中心思想。当然，与此同时，此观测器还可得到其他状态变量的观测值。 非线性状态误差反馈控制率NLSEF非线性状态误差反馈控制器结构如下：韩老论文中这样描述这个状态变量非线性组合：简单理解的话，NLSEF可以看作是一个非线性PID控制器。"},{"title":"中国加油！武汉加油！","date":"2020-04-04T00:32:51.000Z","url":"/2020/04/04/%E4%B8%AD%E5%9B%BD%E5%8A%A0%E6%B2%B9%EF%BC%81%E6%AD%A6%E6%B1%89%E5%8A%A0%E6%B2%B9%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"特别敬佩那些奋战在抗疫一线的战士们，深刻缅怀那些在抗疫战场上逝去的英雄们。作为新时代的中国青年，我会更加努力，致敬时刻保卫中国的最可爱的人们，为祖国奉献自己的生命价值！我为我是中国人而自豪！"},{"title":"揭开积分变换的面纱","date":"2020-03-29T22:26:00.000Z","url":"/2020/03/30/%E6%8F%AD%E5%BC%80%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2%E7%9A%84%E9%9D%A2%E7%BA%B1/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"从刚上大学开始，积分变换就无时无刻地萦绕在我们身旁，什么傅里叶变换。拉普拉斯变换，甚至小波变换等等。这些变换有什么意义？他们又是怎样实现的呢？这次我们多花点时间来理一理。 积分变换即基变换就如同线性代数所说那样，空间中任意一个向量都可由一组完备（个数充满R^n）的正交的基的线性组合来表示。如果把一个函数（信号）看作这个任意的向量（属于R^∞空间），那么这个函数也可以由R^∞空间下的一系列正交的基（也是函数、信号）来表示，这就是信号的基变换，也就是我们说的积分变换。这组正交基的选择，就是积分变换产生区别的地方，如何选择一组好用的基就成了我们要动脑筋的地方。傅里叶、拉普拉斯等人选择到了一系列合适的正交基函数，使得进行基变换后表示的函数有着很好的性质（比如能量集中、方便微积分运算等等），于是成为了一系列经典的积分变换。由此我们看出，积分变换即基变换。 我们以傅里叶变换为例来进行研究 连续周期信号的变换对于连续周期信号，傅里叶选择用一组正交函数基来表示他们，可以获得由时域转移到频域的优秀性质。这组基就是三角函数集（也可以用复指数集来表示）这样我们可以得到一组长度为无穷的级数，就是傅里叶级数。注意到这里选择的基函数的频率为nω0，也就是原周期信号的整数倍，也就是说连续周期信号的频谱是离散的。傅里叶级数这样来表示：也可以表示成复指数形式：cn可通过基正交的性质求得：这个cn也就是输入函数的频谱，它的实数部分代表cos值，虚部代表sin值，也可以看作表示的是幅值与相位，如图：注！对于定义在有限区间的函数，将其进行周期延拓，也可将其看作周期信号，进行傅里叶级数展开。看来基的选择还与原始信号有关，但当我输入一个非周期信号时，应该怎么选择这组基呢？ 连续非周期信号的变换对于非周期信号，我们可以把它看作一个周期-&gt;∞的信号，此时的ω0-&gt;0。由于T-&gt;∞，Fn-&gt;0，不再适合描述频率特性，因此我们选择TFn = F(nω0)作为描述频率特性的函数.这代表什么呢？这代表着非周期信号的频谱间隔很小，也就可以看作是连续的，此时nω0就退化成了ω，就与傅里叶变换如下：同样刻画了输入信号的频率特性。因此得到傅里叶变换与反变换可以看出来，此时的F(ω)不再代表着频谱，而是表示频谱的密度。也就是说，非周期函数不能表示成cos、sin的线性组合（由于系数-&gt;0），但是可以使用傅里叶变换衡量其中各个频率的成分多少。 离散非周期信号的变换上述连续信号的傅里叶变换适用于模拟信号。随着数字控制的普及，我们如果想在一个离散的数字系统中进行傅里叶变换，必须进行离散的采样，采样可以用原信号*冲激序列来表示：注意这个信号仍属于连续的信号，只不过他有了一个可以对应的离散序列也就是x[n]我们当让可以对这个连续的信号进行连续的傅里叶变换：这里交换积分号与求和号，化简可以得到：这里的离散序列x[n]就是由与之对应的冲激序列积分得来的，有x[n] = x(nTs)这样一来我们就得到了离散信号的傅里叶变换，但是这个信号在频域上还是连续的，没办法用在数字处理器中：一是因为这个求和是从-∞到+∞项的求和，需要知道信号时域的全部信息，这对于实时系统是不可能实现的；二是由于频域上这个ω是连续的，也就是得到了频域上的全部信息（由于使用了信号时域的全部信息），离散系统ω是离散的，只能使用其中的一部分信息，造成了信息的冗余。我们既然不能利用频域的全部信息，而却要求知道信号时域的全部信息，能否做一妥协，这时离散傅里叶变换出来救场了。 离散周期信号（有限长信号周期延拓）的变换有限的时域信息表示有限的（离散的）频域信息，我们很自然地想到了周期函数的傅里叶级数。同理，对于一个非无限长的信号（一张图片），或者是无限长信号的一段截取（实时数字系统本时刻的前N个采样周期信号的截取），我们可以对其进行延拓，这样就得到了一个无限长的周期信号。对这个周期信号进行傅里叶展开，就可以得到离散的频域表达了：对这个离散的周期延拓进行傅里叶展开还是一样的计算方法，交换积分号与求和号，且有T = NTs，化简得到：这就是N点离散傅里叶变换DFT的表达式，并且这个离散序列是以N为周期的，我们只取第一个周期即可。其中第k个点表示的是kω0/N频率分量，其中ω0 = 1/Ts。可以看出，这就是DTFT的离散化表示！当然对于本来就是周期序列的信号，可以直接进行离散傅里叶级数展开DFS。 从上面的例子，我们看出，这种信息的守恒十分的美观：时域的信息完备性体现在是否需要知道信号从出生到入死的全部（是否是周期的），而频域的信息完备性体现在频域表示是否是连续的。或许这就是数学之美吧！！！！！ 总结一下时域频域函数的对应关系： 时域连续-&gt;频域非周期 时域离散-&gt;频域周期 时域周期-&gt;频域离散 时域非周期-&gt;频域连续是不是也很美呢？ 二维离散信号（图片）的变换待更新!"},{"title":"重修线代的知识点总结","date":"2020-03-26T05:08:00.000Z","url":"/2020/03/26/%E9%87%8D%E4%BF%AE%E7%BA%BF%E4%BB%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"不知道从哪儿听说，作为一个机器人工程师，一辈子要学5次线代。记得大一学线代，真的是一头雾水，完全不知道学这些有什么用后来慢慢了解了一些应用场景之后，终于发现了线代的重要性（留下了泪水{哇5555555}）于是趁着最近比较闲，我又在B站“重修”了一遍线代，来自MIT的Strang教授为我带来了一场生动形象的线代教学，真的超级推荐MIT线性代数2005这次重修由于有了很多实际应用的经验，学得更有方向性，能把理论与实践联系起来，最终发现“哇！这不就是用在xxx的xxx嘛，原来是这么来的！”。这种感觉真的很舒服！这次我以知识点的形式一条一条地列举线代中最基础也最重要的内容，可能是定理，也可能是一些小Trick，纯粹就是为了第三次学的时候方便回忆，大家尽请期待！ 详情请见《线代笔记》Ⅰ~Ⅳ 作者：闫栋宇。(狗头保命)"},{"title":"俺对卷积的粗鄙理解","date":"2020-03-23T01:35:00.000Z","url":"/2020/03/23/%E4%BF%BA%E5%AF%B9%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%B2%97%E9%84%99%E7%90%86%E8%A7%A3/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"说到卷积，你们首先会想到什么？卷饼？烧鸡？这个卷积可不是吃的啊！写这篇文章契机是上午上网课，第一节是信号与系统，老师讲了一维连续卷积，第二节是数字图像处理，老师讲了二维离散卷积。喂喂喂！你们是约好了吗，一上午老师算是把卷积讲透了，可是我还是一头雾水，这都什么鬼？想起之前DR_CAN也讲过卷积（有空来康康这几个视频：理解卷积的含义、卷积好声音、卷积的拉氏变换），我又双叒叕“预习”了一遍卷积，正好趁这个机会总结一下！ 卷积一——从系统的角度取理解卷积。 大家都知道一个LTI系统，可以完全地由这个系统的冲激响应所描述，这是为什么呢，卷积给了我们答案左边这一列代表系统的输入可以完全由一系列冲激函数平移到τ时刻加权和（即对τ积分）表示，而权重（代表冲激函数的高度）就是输入函数在τ时刻的取值。右边这一列利用了LTI系统的性质（线性组合+时移），在τ时刻的输入是冲激函数的加权和，那么输出就必然是冲激响应的加权和，于是我们得到著名的卷积公式：它表示系统响应等于系统输入卷上系统的冲激响应函数，这也就是为什么冲激响应可以完全地描述系统。由它我们也可以推理得出一些冲激函数的性质，比如说： (1). 与冲激函数的卷积就是输入本身这个很简单就能证明，当系统冲激响应就是冲激函数，系统的传函可以简单地表示为“1”，那么响应自然就与输入相同啦！ (2). 与冲激函数微分、积分的卷积就是输入本身的积分、微分与上文同理，冲激响应为冲激函数的微分、积分，系统的传函也可简单地表示为“s^n”，也就是说，这个系统单纯地对输入做n阶的微分（或-n阶的积分），自然能得出这个结论 (3). 时移特性：f(t-τ)与δ(t-τ)的卷积就是f(t-τ)同同同理，系统相当于纯延时环节“e^(-τs)” 卷积二——换个角度看卷积 重新打量一下这个卷积公式是不是很奇妙，他就是两个函数乘积的积分（注意是对τ进行积分，千万别搞错积分变量），放在离散就叫乘积的和。而这两个函数又有什么特点呢？第一个f(τ)，代表着输入样本，第二个h(t-τ)，是系统冲激响应的反向（这大概就是卷积这个“卷”字的由来）加平移t（注意这里的t看作常数，因为我们只现在需要算出t时刻响应的大小）。 从几何角度来理解更简单一些，先来看一维连续的情况：把h(τ)反转，得到一个新函数h(-τ)（注意是以τ为自变量），我们称之为“卷积核”将卷积核右移t=2个单位，再与f(τ)积分，我们不就得到了所要的公式了吗，所以结果就是t=2时刻的响应y(2)啦！当然如果t从-∞到+∞动起来，我们就能连续地获得这个响应y(t)。（＞人＜；）好想支持动图哇！！！ 那为什么要这么算卷积呢，因为这个角度去计算离散卷积会很方便，比如这个例子：woc竟然能动？？？(☆▽☆)对于连续来讲的积分变成了求和，这下一个一个地计算y[n]是不是很方便呢！ 在数字图像处理、深度学习等课程上，老师将这种操作也叫做了卷积，当时的我们可能会不理解，但是现在来看，这种操作是不是很容易理解呢？终于，我们来看上面这个二维离散卷积的例子，拿它来和我们的一维离散卷积来对比一下Original这张图就相当于输入f[n]，而这个Filter就相当于我们的卷积核h[-n]，当m = 灰色e时（我也不知道为啥有两个e），也就是卷积核移动到了灰色e这个位置，计算一次离散卷积，也就是将对应位置的灰度值相乘再相加，我们就得到了输出图像t = 灰色e位置时的输出eprocessed，相当于y[m = 灰色e]，再对其他位置的像素进行卷积运算就可以得到整张图的最终结果y[m]啦。整个卷积的过程下面这个动图展示的淋漓尽致啦：尤其要注意的有一点：那就是图像处理里面直接拿来用的卷积核，就是已经经过反转的冲激响应了，从下面这个例子也可以看出来：原图中的1就相当于一个冲激函数，它经过卷积核后的响应正好是卷积核反过来，这里也就可以说明卷积核就代表着h[-n]. 至此感觉大家对卷积的理解也应该很深刻了把！"},{"title":"Python爬虫实战！","date":"2020-03-13T22:21:00.000Z","url":"/2020/03/14/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%EF%BC%81/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"老早就有闻爬虫的鼎鼎大名，但一直找不到合适的机会去试一试。正好前几天刚学习了Python的语法，拿爬虫练练手正合适，顺便在网上找到了漫画的资源正好下载下来看一看，省了我几个漫读券了，一举两得，美滋滋！ Python requests库的基础使用爬虫的原理十分简单，就是将程序模拟为浏览器，来快速地获取网络上的资源，包括文字、图片、音频、视频都能被爬取到，也可见即可爬！那么怎样自动化地模拟浏览器进行网络请求呢，答案就是Python第三方库——requests，这个库功能十分强大，提供了get、post等多种http、https请求，我们可以很简单地利用requests库来模拟浏览器的动作。get(url,headers = header)方法用于使用get方法发出一个请求（注意get方法的数据显式地存放在url中，因此我们只需要提供url即可），使用headers参数来提供请求头（也是防反爬最基本的方法之一）；post(url,data = data,headers = header)方法类似，用来发出post请求，数据存放于data中（通常为JSON字符串格式）； 这两个类得到的实例就包含了服务器获得请求后返回的响应，我们称之为response，通过respons的text与content方法，我们就可以获得返回的数据了，而这二者的区别是text方法以字符串形式返回，通常用于我们来做数据分析的，当然也可以用来保存文字内容；而content方法返回二进制数据，通常用于我们保存文件，文字、图片、音频、视频均可。这样我们就通过requests库获得了网页的内容啦！ 内容的保存获得了内容之后我们要将保存为文件，Python的文件操作非常方便使用：with open(filename,method) as f:可以以method所定义的方法打开filename这个文件。一般我们用于保存文件的method就是”w”和”wb”两种，区别在于”w”使用文本形式保存文件，而”wb”使用二进制字节流形式保存文件，我们的多媒体文件以及可执行文件都是以这种形式保存的！打开文件后，我们可以使用f.write(content)方法向文件写入内容，也就是之前我们得到的response.text或response.content，这样，从网络上爬取数据并保存的工作就完成了！ 数据的筛选 正则re与parsel库##互联网上数据众多，为了能够筛选出我想要的内容，比如我们只想要漫画网站上面的图片而不想要底下的评论，我们还需要对获取的数据进行筛选，这该如何是好呢？最简单粗暴的办法，我们可以使用Python正则表达式库re中的findall方法来匹配我们想要的内容用法就是——re.findall(“style”,text)，其中style就是正则要匹配的内容，text就是所要匹配的数据，style中()内的内容就会被返回，这样我们能够简单地提取出我们想要的内容，比如图片url啊、小说标题和文本啊等等，但是由于网站的元素实在过多，我们可能会匹配到错误的内容，需要一种更高级智能的匹配手段！parsel库向我们提供了三种匹配手段，re、xpath与css选择器，我这里就主要解释一下css选择器的使用网页上的html元素都有着不同的css标签，可以通过css标签来选择出我们想要的元素。parsel提供了Selector(text)方法，实例使用css(css_selector).getall()的方法可以获取到所有匹配的元素内容，所以我们只需要知道这一系列元素所共同具有的css选择器就可以了。同理，xpath也是html元素的属性，也可以由浏览器调试获得！我们不过多赘述（好吧其实是因为不会(*￣;(￣ *)） 批量爬取刚刚我们只获取到一页内容的数据，如果我们想翻页，或者想去自动地爬另一个内容，怎么办呢？批量爬取是一只爬虫必备的能力，做到批量爬取，其实就是获取下一个想爬的url在一个循环里来回爬就行啦，获取url成为了我们的首要目标如何获取url呢？最简单粗暴的办法就是，观察网页变化的如果下一页是一个超链接，那就简单了，获取到下一页的url即可如果下一页是get请求，也没啥太大问题，使用get方法，模拟网页发出一个一模一样的请求就行，当然get请求也是包含在url里面的，我们也可以直接获取url如果下一页是个AJAX请求（即动态地在同一个url下面显示不同内容），抱歉目前我还不太会（＞人＜；）获取到下一页内容后，再把他们循环起来，重复上面的工作就行啦！我们的爬虫就可以运行起来啦! 实战：爬取某网站整部漫画话不多说，直接上代码你没有看错，只用了29行（这就或许是Python的魅力吧）原理也很简单 查看是否存在文件夹image，没有则创建 最外面的循环是章节循环，由于每一章网页url上面的数字是连起来的，简单的字符串拼接就可以遍历了 再在image内创建一个名为章节号码的文件夹，用来存放图片 首先请求一次，（注意这个get请求使用一个visitor_header的请求头，目的在于防止被反爬） 这次请求获取当前章节的总页数，然后就可以遍历每一页啦 再次get请求，使用css选择器获得符合要求的img的html元素（也就是漫画图片），再使用正则筛选出图片url（个人网站加个延时防止网站崩溃） 最后按页数保存下来就大功告成啦！ 最后运行的结果：（爬了租借女友的23到27话做个示范） 爬虫真的是一种便捷获取网络数据的利器！但白嫖可耻，也请大家不要学习盗版行为！真的已经在哔哩哔哩漫画补过票了！(❤ ω ❤)"},{"title":"现代控制理论总结2——NonLinear部分","date":"2020-03-08T15:56:00.000Z","url":"/2020/03/08/%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%932%E2%80%94%E2%80%94NonLinear%E9%83%A8%E5%88%86/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"学习完了比较简单的线性部分，我们来进一步探讨非线性系统的特性！本片所讲内容完全可以用在线性系统上，因为线性系统也算是一种特殊的非线性系统，这篇讲的是一种普适的方法！ 李雅普诺夫直接方法也叫做第二方法（第一方法是直接解微分方程）第二方法是这样判断一个系统稳定的：这样可以证明李雅普诺夫稳定（即有界稳定）这样可以证明渐进稳定 可以看到，二者仅仅区别于V_dot是半正定的还是正定的。那么这个V到底是什么呢？他是怎么来的呢？这个V将是贯穿整个非线性控制理论的一个东西。我们把V叫做李雅普诺夫函数，这个V是自己选的，自己选择V来证明稳定，有些微妙呢（￣。。￣）同样，我们也是要判断平衡点，即X_dot = 0 的点，一定要记住，在u = 0的情况下，稳定系统一定会收敛到平衡点上。在加入控制量u之后，我们比较方便的能够把平衡点控制在0，所以当想要移动原来变量平衡点时，一般会转换状态变量到e或delta这样的误差变量上，最终就能达到移动原来变量平衡点的作用。一般我们选择的V是包含需要稳定的量的，即V是e、δ……的函数V(e,δ)V_dot = ，其中f(x)表示x的微分的函数通常设计的V为系统在某个维度的能量，那么就表明能量大于0，能量衰减的系统就是稳定的！这里要注意，x=0，指的是x1、x2、全部=0，这里判断ND、NSD时要注意！ 拉塞尔不变性原理为了扩大直接方法判断渐进稳定的适用条件，引出拉塞尔不变性原理： 满足李雅普诺夫稳定 除了x = 0，没有其他轨迹能够使V_dot = 0判断方法也很简单，直接令V_dot = 0，计算满足的轨迹，如果除了x=0外还有满足的轨迹，那么就不符合，若仅有x=0这一条，则整个系统也是渐近稳定的。 非线性控制中心思想对于x_dot = f(x) + u这种形式，简单粗暴滴构造一个u = f(x) - kx，就可以构造出x_dot = -kx这个线性的，必定稳定的系统。我们称之为反馈线性化（Feedback Linearization），是最简单证明稳定性的方法。但有时反馈线性化不是最佳的，我们可以通过寻找V(x)来设计u，使得V与V_dot满足PD ND的条件即可 反步法对于二阶系统，我们常用反步法（Back Stepping）来解决控制问题。微分表达式x_dot = f(x)，代表着x的变化受到f(x)的控制，这点是我们控制x的重要思想。当二阶系统构成一个Chain of Integrator，即x2在f1中，而u又在f2中，我们就可以通过控制u来控制x2，再通过控制x2来控制x1。（设计控制器时还是用上面的中心思想来实现）反步法则与这个顺序相反，它先设计出x2控制x1的方法，找到一个x2d，再通过设计u来控制x2-&gt;x2d，最终实现目标。在这两步中，第二步同时包含了x1与x2，我们在设计时要同时引入两个状态变量e与δ，而第一步就仅需要一个e，因为我们把其中的x2已经当作了输入量。并且，如果这两步中有一步是线性系统，我们完全可以用线性系统的思路来设计！下面是反步法的具体设计步骤的一个例子： 自适应控制有时我们再设计控制器时，总是要用到一些系统的参数，但当我们很难测得这些参数时，控制器就很难设计。于是我们引入自适应控制（Adaptive Control）用一个p_hat来测量这个参数p（前提要有p_dot = 0），不妨设p_e = p_hat - p，我们把这个p_e也当作一个状态变量，就能够使p_hat-&gt;p，最终我们在u中使用p_hat代替p来做控制即可。（这里要先设计出一个假定已知p的输入u）将含有x与p的f看作是由两个变量组成的系统，最终用包含p_e与e的李雅普诺夫函数V()满足PD ND，同时代入已设计好的u，即可得到a_hat或a_hat_dot的式子，大功告成！ 鲁棒控制上面的自适应控制用于p_dot = 0的情况，但当p不是一个定值，在随时间变换但却有界（ρ(x)，这个界可以是与x有关的，但是在非线性部分整体也有界的情况下通常取为一个常数ρ），我们就不能使用Adaptive的方法，这时就要使用鲁棒控制器（Robust Control）鲁棒控制器有一个通用的形式：u = -ke + xd_dot + uaux最常见的三种鲁棒控制器： Sliding Mode： uaux = ρ(x)sgn(x) （也就是大家经常听说的滑模控制器） High Gain： uaux = 1/(ε)ρ(x)^2 * e High Frequency：uaux = ρ(x)^2e/(ρ(x)abs(e) + ε) 这三个鲁棒控制器各有特点：SMC静差为零，而其他两个控制器都有与k和ε相关的静差HGC收敛是最快的HFC输入是最小的我们也能够很简单地使用直接方法证明这三种控制器的稳定性。 总结一下，非线性控制的思想就是设计合适的u使得选择的李雅普诺夫函数V能够满足稳定条件，就是这么简单！"},{"title":"现代控制理论总结1——Linear部分","date":"2020-03-06T20:34:00.000Z","url":"/2020/03/07/%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%931%E2%80%94%E2%80%94Linear%E9%83%A8%E5%88%86/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"从去年这时候第一次从老余那儿听说到DR_CAN这个人，开始看他的视频，到现在，我已经把这部分内容反复看了4遍了，没有什么额外的原因，纯粹就是因为看不懂，看懂了就忘( ´･･)ﾉ(._.`),所以现在来这里总结一下！这里超级感谢DR_CAN先生，这个up是真真正正的宝藏up，人帅，又有才华（特别推荐爱情中的数学这一期，老少皆宜），他也算是帮助我半只脚进入控制世界的大门的引路人吧ヾ(≧▽≦*)o经典之作——love and math 这期内容分两篇文章，分别对应LTI与Non-Linear，期待期待！ 状态方程与传递函数学过经典控制理论的肯定对传递函数有所了解，传递函数描述了一个系统的性质，系统是否稳定，有没有震荡，收敛的快慢都可以由传递函数分析得出。而在现代控制理论中，和传函同等地位的就数状态方程了，状态方程也可以描述这个系统。状态方程的形式是这样的：状态方程输出方程 其中，决定系统性质的，有着和传递函数分母相同作用的，就是A矩阵，它的特征值就是对应传函的极点，这条性质十分重要！我们以二阶系统为例，若将X进行坐标变化，X=PY,使得Xdot=AX变换为Ydot=P^-1APY,使得P^（-1）AP为一个对角矩阵，这个对角矩阵的两个非零元素就是A的特征值，X变到Y，即完成了一个解耦，方便了我们分析，X，Y变化趋势相同，仅仅相差一个坐标变换，就像下面这样：解耦后的系统相图一般有以下几种形式，对应不同的特征值： 稳定性在了解稳定性之前，我们先来理解一下平衡点的概念——平衡点也是个很重要的概念：Xdot=0，即为平衡点，若系统初始在了平衡点，它的状态就永远不会变换，并且系统若是稳定，最终一定会趋近平衡点等幅振荡——不稳定——最终收敛的情况。 稳定性的数学定义如下：第一种，也就是李雅普诺夫稳定（Lyapunov Stable），简单地理解就是将等幅振荡也算作稳定了，即最终x有界第二种，也就是渐近稳定（Asymptotic Stable），简单地理解就是x最终必须收敛。对于线性系统来讲，判断稳定性的方法很简单，就是观察A阵特征值的正负，全部小于等于0，则可以达到李雅普诺夫稳定，而若是全部小于0，则达到了渐近稳定的要求。而对于非线性系统，就比较麻烦了，分为李雅普诺夫第一方法（解系统的微分方程，比较难）与李雅普诺夫第二方法（直接方法，通过寻找李雅普诺夫函数来判定），这方面我们将在下一篇中仔细理解。 可控性与控制器上面我们讨论了在零输入的状态下，系统的稳定性，可见，对于任意的一个系统，稳定性是不能确定的，即使稳定，平衡点可能也不能满足我们的要求，于是我们就要加入控制变量来使得系统能够稳定，甚至能够改变系统的平衡点。引入最简单的反馈控制器U = -kX，其中k = [k1,k2]，这样我们新的系统就变成了Xdot=(A-Bk)X，我们就可以配置(A-Bk)的特征值，来计算k，使得新的系统满足我们的要求。另外，控制器k的设计不仅能够由特征值配置（在经典理论中称为极点配置）得到，在最优控制（Optimal Control）中，考虑输入的情况下，通过使Cost Function最小而计算出k1、k2的值，我们称这种方法为LQR Control。 但是这样做有一个前提，即保证k有解，这就需要我们的系统满足可控性，系统具有可控性，就是系统状态变量在相平面上可以在输入的作用下达到任意的点，具体推导公式是DR_CAN用离散的方法推出来的，连续的方法我这里也不太会，希望知道的同学能来教教我，(≧∇≦)ﾉ直接给出可控性的条件当Co = [B AB A^2B ……A^nB]满秩时（即Rank = n时），即可证明k有解，也就是系统可控！注意！！在相平面上，可控指的是点对点的可控，而不是轨迹上的可控！ 可以控制系统稳定性之后，我们就想着要控制系统的轨迹，进行轨迹跟踪，也就是改变系统的平衡点！引入误差变量e，有 e = x1d - x1edot = x1ddot - x1dot 用新的状态变量e来表示系统方程则会得到：此时，只需要我们调节输入U，使得BU在抵消最后面一个矩阵后还能够做到反馈控制调节系统特征值的作用，就需要U = -kX - a/e*x1d。须注意三点： 这里的X是新的包含误差的状态变量； 仅有在e、f，a、c成比例，或者对应有0的时候才能完全消去常数，我大胆猜测，这里就对应着经典控制理论中的稳态误差； x1ddot这一项的补偿就相当于速度前馈！这样我们就能够做到轨迹跟踪了！ 能观性与观测器上面内容全部建立在状态向量能够通过传感器测量的前提下，在我们不能够通过传感器获取到一些变量时，我们该如何进行反馈控制？使用观测器！观测器首先构造一个虚拟的系统进行更新：与实际系统做差，可得到如下方程E_dot = (A-LC)E其中E = X_hat - X我们又构造出这样一种形式，同样，只要配置矩阵的特征值，计算出相应的L，即可使E收敛到0，也就是X_hat收敛到X。这样我们成功观测了状态变量X。与控制器相同，观测器也需要满足能观性，就是要使L有解，O = [C CA CA^2 …… CA^n]^T，需要满足O满秩（即Rank = n）根据分离原理，我们可以使用观测到的值来做状态反馈控制，这样做的时候控制器与观测器特征值不互相影响，仍与原本设计相同！（但我们仍希望能使观测器时间常数小于控制器！） 总结下来，现代控制理论要实现的就是通过变换使系统状态方程变为Xdot = AclX 的形式，通过配置Acl的特征值，使系统具有所需性质！"},{"title":"立FLAG专用帖！","date":"2020-03-02T19:04:00.000Z","url":"/2020/03/03/%E7%AB%8BFLAG%E4%B8%93%E7%94%A8%E5%B8%96%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"把想做的事情放到这里来！ 想学的东西 数学基础 Linux驱动开发 Numpy and Matlab 数字信号处理 ROS 概率机器人 想写的文章 高频注入法 MPC FIR与IIR SVM、马尔可夫 强化学习 保证不鸽！！！(oﾟvﾟ)ノ(oﾟvﾟ)ノ(oﾟvﾟ)ノ(oﾟvﾟ)ノ(oﾟvﾟ)ノ加油加油！"},{"title":"网络是个什么东西？","date":"2020-02-29T02:39:00.000Z","url":"/2020/02/29/%E7%BD%91%E7%BB%9C%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F/","categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"假设某一天，世界上没了网络，那就不是你看不到我更新的问题了，生活的各个方面都会受到影响！网络可以说是离我们生活很近，但就是看不见摸不着理解不了的东西——我是怎么浏览到全国各地甚至世界范围的网页并且能够下载文件的？我和同学打游戏时，我们是怎么互相看到对方的？SSH是怎么远程链接上云端的主机的？带着这些 疑问，我粗浅滴浏览了一遍《计算机网络》这本书，做个很简单很简单的总结吧！ 计算机网络！作为个人用户，我们要上网，就需要连接到本地的网络服务供应商ISP才可以，之后本地的ISP一级一级向上连接直到主干ISP，世界主流的主干ISP都是连接在一起的，他们再根据这些信息的目的地将信息传递到目的地。中国主要几个ISP就是中国电信、中国联通、中国移动等。向这些ISP交钱换来的是连接到ISP的网络中的权利（至于如何连接，则是接下来要讲解的），也获得了相当于与世界上所有其他计算机连接的权力（被墙的不算啊( ఠൠఠ )ﾉ）。连接ISP，方式分为ADSL、LAN、FTTH、PON四种。 要研究数据如何传送，就要了解网络传输的结构：按照TCP/IP五层结构，由浅入深，从最底层到最表层地解释信息在网络中的传播首先我们要理解为什么构建一个五层结构，这是因为每层的结构既得到了前面一层的支持，又为后面一层提供了服务，最终每一层看起来就像只在本层互相通信而不受其他层干扰一样。可以说分层是对其他层的一个抽象，使得你不用去管其他层是如何完成任务的。 物理层首先最底层，就是物理层，在这个层次跑的是bit流，也可以理解为表示0与1的物理现象，可以是数字量的高低电平，也可以是被调制后的模拟信号，甚至可以是光信号（光纤网络），这些传播方式作为物理层为上层提供了很完善的信息传播途径。（这些0、1的规范协议也是属于物理层的范畴，类比串口的三根线、TTL电平规范以及传输前后的调制解调）xDSL（数字用户线）技术就是属于物理层面上的，这种技术可以利用原本假设好的电话线进行网络通信，只需在电话线两端接上调制解调器（Modem也就是俗称的“猫”），ADSL也是用户连接到ISP（网络服务供应商）的方法之一。 数据链路层在往上就到了数据链路层，在这一层主要是面对硬件（对网络来说硬件就是网卡）的，主要有两种协议工作在数据链路层，他们是点对点通信的PPP（Peer to Peer Protocol），以及面向局域网（以太网Ethernet）的MAC协议。PPP是最常用的点对点通信协议，通常用在广域网通信上（比如ISP之间的通信？），还有大家经常说的PPPoE（PPP on Ethernet，基于以太网的点对点通讯协议），可以实现以太网中没有的身份验证、加密、压缩的功能，也用于ADSL宽带接入。重点讨论MAC协议。每个硬件生产就被赋予了一个全世界唯一的编号，称之为硬件地址也就是MAC地址，MAC帧仅可被局域网中目标MAC地址对应的主机、路由器接收，达到使用MAC地址传输的作用。 网络层接下来我们来到了网络层（IP层），MAC地址用来访问局域网中的硬件，而IP地址则是整个互联网中独有的身份证。我们想要访问到世界上任意一台联网的计算机，必须使用这个32位的数字来确定目标。然而要确定这个目标就需要以下几个重要协议来支持：ARPA协议，通过IP地址解析下一个目标主机、路由的MAC地址，来添加到MAC帧的首部，所有的设备都应可以从IP解析到MAC，因此ARPA成为数据链路层到网络层的中介；路由表，记录在路由器中，在路由表中记录着本网络下的其他路由的信息，可以通过目标网络IP地址解析出下一跳最佳路由，是IP数据报传输的引导者。路由器作为两个网络的连接者，拥有两个MAC地址和两个IP地址！一个主机要通过局域网发送一封IP数据报，要经历一下步骤：0.若通信双方处于同一网络，则可直接交付，不需经过路由。1.找到本局域网下的默认路由（即网关gateway），把目标IP、本机IP连同数据一同发送给默认路由；2.默认路由根据目标IP查询路由表，寻找下一跳路由的IP，以此类推；3.直到路由器若发现目标IP属于同一个局域网，则进行直接交付，完成一次传输。IP数据报（IPv4）的结构如图所示：上面介绍了局域网中主句的重要参数，IP地址、网关，还有一个重要参数：子网掩码（mask），一般为连续的1与连续的0组合，根据子网掩码可以得到主机所属的网络号和主机号，由此可以判断该主机处在那个网络，进而可以判断是该直接交付还是该查找路由表。由于IP地址的紧缺，不能保证每台主机都能够分配到一个IP地址，我们在家上网使用的都是NAT（网络地址转换）技术产生的本地IP地址（内网IP），而不是互联网上的IP地址（公网IP）。如何区分一个IP是公网还是内网呢？IP在分配时已经作了规定，以下这些段的IP都用作内网使用，因此不会出现内网IP与公网IP冲突的情况。只要本地互联网上的其中一个路由器接入到了公网，也就是其中一个IP地址为公网IP，则这个本地网络都能够访问到互联网，方法就是不同的主机占用那个路由器公网IP的不同端口，远程主机就像是在与这个IP的不同端口通信一样。但由于没有公网IP只能使用端口，这些本地网络中的主机不能作为互联网上的服务器使用，因为互联网上的客户无法请求本地网络中的服务器提供服务。VPN（虚拟专用网）开始并不是用来“科学上网”的，而是通过使用互联网将多个分布在各地而不互相连接（仅通过互联网连接）的局域网虚拟地连接起来，使得这几个局域网好像在同一个局域网下一样，并且通过加密手段使在互联网上传输的数据也很安全。 运输层接着我们来谈运输层，运输层主要讲了两种传输方式，即无连接，尽最大努力交付的UDP与面向连接，可靠交付的TCP。UDP就类似于我们在单片机通信中的协议，二者只管尽力发送，就算发送失败也不会做处理。而TCP则确保每一帧的完整接收，首先双方先建立连接，之后开始数据传送，每一帧数据发送后，接收方回复确认则表明收到，否则重新传送，传输完成后断开连接。由此可见，UDP快但不稳，TCP稳但不快，二者的应用方向不同！运输层作为连接应用与网络的中介，引入了端口这一工具，通过端口，发送数据时IP地址得到了分用，接收数据时IP地址得到了复用，UDP与TCP都使用了端口，并且为了方便建立连接，TCP使用了套接字（socket）作为连接的端点，套接字就是IP+端口的组合。 应用层最后到了应用层，有了前面几层的铺垫，应用层所需要完成的任务很简单，就单纯是建立与目标主机的连接（TCP），将数据封装成UDP或TCP帧，随后发送，就可以完成通信，其余完全是应用程序想干嘛干嘛。常见的应用层协议有FTP、TFTP、HTTP（用于万维网服务）、DHCP（自动配置IP，即插即用网络服务）等等等等。"},{"title":"3D物体是如何旋转滴2","date":"2020-02-28T20:06:00.000Z","url":"/2020/02/29/3D%E7%89%A9%E4%BD%93%E6%98%AF%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E6%BB%B42/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"在上一篇文章中我们已经知道了如何表示旋转，但是现实世界中直接得到四元数或欧拉角的方法少之又少，那么新的问题就是如何通过角速度、加速度甚至地磁计这些我们能够容易测量的量得到旋转呢？本期我们来讨论通过姿态解算的问题！ 旋转的微分我们都知道，使用陀螺仪，可以很轻松地得到物体的角速度，而角速度又是角度的微分，通过角速度我们计算出“旋转的微分”，再解这个微分方程，不就可以得到角度了吗！但是说的轻巧做起来难，到底该使用哪种角度（旋转）表示法才能够计算简便并且容易理解呢？欧拉角在微分时会出现万向节死锁的现象，如图：此时分母上产生了0，在计算时就会出问题，因此我们不能采用这种方法。而轴角法没有办法表示旋转的叠加，就不能进行积分，因此也不可取。最终答案就是四元数！我们能够很方便的通过角速度计算出四元数的微分方程（具体推导省略），就像下面这样:（四元数乘法，转换为矩阵乘法可表示为下式）其中wb代表机体坐标系下的角速度向量，也就是直接从陀螺仪读取的值！接下来初始化一个q（根据需求），然后解微分方程，就能够随时得到世界-&gt;机体的四元数啦！（注：得到的四元数表示的是坐标系的旋转，即从世界坐标系到机体坐标系的旋转，即第一种理解） 四元数、旋转矩阵、欧拉角的互相转换四元数与旋转矩阵的转换很容易完成：突破q0后再依照关系一一突破即可 而旋转矩阵化为欧拉角则比较麻烦，需要先约定好欧拉角的种类（24种之一）详情就不贴了，论坛上一抓一大把的（＞人＜；） 至此，我们已经通过角速度计算出欧拉角！ 但是我们解微分方程的方法是积分，由于传感器零偏，积分就难免会产生漂移，我们需要纠正这个偏移，就需要这种积分传感器以外的绝对传感器，就像SLAM中的里程计+激光雷达的组合一样，我们也常用陀螺仪与加速度计、地磁计的组合进行角度测量！下面介绍一种较为简便的AHRS（航姿参考系）算法，MahonyAHRSMahony的中心思想是陀螺仪更新角度，加速度计与地磁计以较缓慢的方式纠正更新的角度。就拿加速度计来说，静止状态下，加速度计测量为g，方向指向世界坐标z轴负方向，利用上一次计算得到的四元数，我们把世界坐标系中z轴负方向在机体坐标系下的坐标解出来，再将其与加速度计做叉乘来计算误差（产生误差正是由于你从世界转换到机体的这个旋转是不准的），这时我们得到了一个误差向量，要注意它在机体坐标系下的方向可能是任意的，但在世界坐标系下一定是在xOy平面上的（这时由于先叉乘再旋转与先旋转再叉乘得到的结果是一样的），这也是加速度计仅能矫正pitch与roll轴漂移而不能矫正yaw轴的原因，误差向量在世界坐标系下根本没有z轴的分量啊！！误差向量经过PI控制器后可以得到一个矫正向量，这个向量是一个角速度量，把它和陀螺仪所测得的角速度相加，即可得到最终的角速度，具体系统请自行分析一哈，这样一来我们就能够通过加速度计的修正角度漂移！与此同理，若我们知道了地磁计的数据，拿它和机体坐标系下的地磁方向作比较，即可得到存在z轴分量的误差向量，这样一来我们就可以修正yaw轴的零偏啦！（这里存在一个问题，即地磁方向的确定，大家可以想一想如何解决）如此迭代，MahonyAHRS就完成啦！ 与此相类似的算法还有MadgWickAHRS、卡尔曼滤波等，MadgWick是通过加速度计、地磁计计算（使用了梯度下降最优化的思想）的四元数与陀螺仪计算的四元数进行加权得到；Kalman则是使用陀螺仪作为状态方程，加速度计、地磁计作为测量方程进行滤波得到。这俩就不详细讲了（其实是因为我也不懂(￣▽￣)”）"},{"title":"3D物体是如何旋转滴1","date":"2020-02-28T08:46:00.000Z","url":"/2020/02/28/3D%E7%89%A9%E4%BD%93%E6%98%AF%E5%A6%82%E4%BD%95%E6%97%8B%E8%BD%AC%E6%BB%B41/","categories":[["物数","/categories/%E7%89%A9%E6%95%B0/"]],"content":"表示二维物体的旋转十分简单，通过一个旋转矩阵就可以把一个二维向量旋转任意角度（就如同前面文章中所说的Park变换与反Park变换那样），所以二维的旋转可以用一个2X2的矩阵表示。然鹅，三维物体虽然也可用3X3矩阵表示，但它涉及到的运算与限制较二维要更麻烦一些，这次我们来讨论一下三维空间中的旋转（搞控制的和做游戏的都可以留下来康康啊！） 这篇文章借鉴了许多CSDN、知乎上的大佬们，很多图都不是自己画的，侵删侵删！尤其感谢知乎大佬，也是哈工大电气的亲学长FrancisZhao，您在知乎的专栏控制工程师笔记给我带来了很多收获！ 研究物体如何旋转，首先要知道旋转是什么，我理解中的旋转是： 对坐标系的旋转，使其中点在新旧坐标系中的坐标发生变化，并且能够用数学方式表达这个变化； 或者你可以认为是直接对点、向量进行旋转，而坐标系不变。 接下来我们就要研究物体旋转的表示方法，也就是坐标变换的方法，最常用的旋转表示方法有如下几种 轴角法 欧拉角法 旋转矩阵、方向余弦 四元数 我们主要就是来讲解一下这几种旋转表示法———— 轴角表示法轴角表示法，顾名思义，就是使用一个轴（可以认为是一个单位向量，也可认为是一条过原点的直线）加一个角度来表示旋转。三维空间中，轴是二自由度的，角是一个自由度，所以一共三自由度，来表示这个旋转完全没有问题。其实，我们在二维旋转中一直在使用轴角法，只不过轴恰好就是Z轴，而角就是那个角，放到三维也是很好理解滴！ 欧拉角表示法前面提到的轴角法将两个自由度的轴和一个自由度的角结合到了一起，而欧拉角则由三个旋转组成，即三个自由度都由角组成。这三次旋转所绕的轴都是确定的，即坐标轴，根据选择轴的顺序、选择固定轴或者运动轴（即使用上次旋转后得到的新坐标系还是使用最初的坐标系）与选择三轴都转或者只转两轴，一共有24种欧拉角！我们做控制最常用的一种欧拉角就是zxy，也就是在云台指向y轴的情况下先转yaw，再转pitch，再转roll（比如RM的云台角度解算用的就是这种）要注意的是，在做结算之前，一定要先约定好欧拉角的类型，否则无论如何也得不到正确的角度！ 旋转矩阵 方向余弦二维情况——绕Z轴转动，可得到一个2X2的矩阵来表示这个旋转，我们称其为旋转矩阵；三维情况下，如果也是绕坐标轴进行旋转，我们也可利用一个旋转矩阵（3X3）来表示，这就是接下来我们要讨论的旋转矩阵！（注：由于旋转矩阵是正交矩阵，因此它的逆就是变换θ的符号，也就是反向旋转，因此要注意旋转矩阵的形式，顺时针OR逆时针）本文讨论的向量或点都是列向量形式！向量或点左乘旋转矩阵，得到的结果是向量或点旋转过后得到的新向量或点相对于原坐标系的坐标（即第二种理解方式，向量或点的旋转）若要求得在坐标系旋转A后，一个固定的点相对于新坐标系的坐标变化（即第一种理解方式，坐标系的旋转），则需要左乘那个旋转矩阵的逆矩阵也就是A’，即相当于点的反向旋转！上面这些旋转矩阵都是逆时针为正的旋转。 这三次旋转（每次都绕新得到的坐标系旋转，角度即为三个欧拉角）的最终结果可以用矩阵乘法来计算（乘积顺序由对应的欧拉角旋转顺序决定），最终我们可以得到一个总的旋转矩阵：（注意！有时我们在计算中会由于数值原因产生非正交的旋转矩阵，这时就要进行归一化，这点对任何正交矩阵数值计算都适用）旋转矩阵也不是每次必须通过麻烦地三个矩阵乘积来计算，他还可以通过旋转前后坐标系之间的角度关系来推算，这时我们就称它为方向余弦矩阵（DCM），具体算法如下：其中大写字母是原坐标系的坐标轴，而小写字母则是旋转后坐标系的坐标轴。DCM与旋转矩阵是等价的！ 四元数终于到了重头戏四元数！四元数表示法是所有旋转表示法中最完美的，它不受万向节锁（Gimbal Lock）的限制，可以把多个旋转合并，具有唯一性，可以说是融合了前几种方案的所有优点！可能真的是因为用三个数表示三自由度就会出问题所以我们要用四个吧o(￣▽￣)o四元数的形式如下：与轴角法类似，四元数的数学意义也是绕轴旋转特定角度，只不过表示形式发生了变换：一个向量或点 可以用一个纯四元数来表示（θ=0，旋转了0°），而一个非纯四元数则表示一种旋转（θ!=0，旋转了非0°），其实把四元数可以看做是四维空间下的一个向量，而纯四元数则相当于在这个四维空间下的三位超平面上的一个点（很难以置信吧！）四元数的运算与复数的运算十分类似，只不过i、j、k相当于不同的虚数轴，而求逆则相当于转-θ！四元数这样表示一个旋转：这里用的也是对旋转的第二种理解方式，若想旋转坐标系q，则需把q用q^-1替换来得到新的坐标。（注：四元数轴向量u要是一个单位向量！）下面这个图完美解释了为什么要左右都乘且为什么是θ/2： 这次我们主要讨论了坐标表示法，下一篇我们将重点讲解利用四元数进行坐标解算，以及一些常用的互补滤波算法！"},{"title":"技术传承——永磁同步电机驱动3","date":"2020-02-26T05:07:00.000Z","url":"/2020/02/26/%E6%8A%80%E6%9C%AF%E4%BC%A0%E6%89%BF%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A83/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"上回我们讲完了驱动中电流闭环的问题，这次我们讲一下如何将我们得到的控制量输入给电机！也就是SVPWM调制与逆变器的那些事。前方高能，请握紧扶好，准备发车！ 逆变器学过电力电子的同学肯定都听说过逆变器，为什么叫逆变呢？就是因为我们平常说的电的变换都是讨论的交流整流后变直流，而逆变器能将直流电变换为交流电，所以称其为逆变。最常见的三相逆变器结构如图所示：可见，逆变器的电路结构很简单，由三个半桥构成，每个半桥都通过控制开关管的开通关断来控制输出电平高低，通过控制占空比，即可控制输出任意大小的电压，为SVPWM电压调制提供了硬件基础。关于逆变器的能量变化，可以通过忽略开关管压降，近似认为两端功率相同，即直流部分的母线电压*母线电流=交流部分的电功率=alpha、beta轴（同时d、q轴）上的电压电流矢量积=上的电压电流矢量积，注意这个功率可正可负，所以电流反向回灌母线是完全可能的（比如电机回馈制动时）。而通过能量分析得到的这个母线电流的方向仅仅是个最终的表象（平均值），实际上的电流可能在不停地变化（由于电感的作用，电流不能突变，导致切换瞬间电流不变，母线电流方向就可能变化），到底如何变化这方面分析就涉及到电力电子方面的知识了。 SVPWM终于到了永磁同步电机的重头戏：SVPWM首先明确，SVPWM的目的在于将Ualpha、Ubet两输出量输出给电机，需要把他们变成成三相电压；同时，它也是为了把操纵逆变器，把直流电变成交流电。在逆变器上，这两个任务同时完成了。我们先来了解一下SVPWM的调制过程，我们想要输出任意方向、任意大小的电压矢量，就要通过相差120°的三相电压合成的方式来做到三相全部关断，自然是零电压，记为0；三相中一相开通时，会产生一个沿abc轴向的电压，记为1；三相中两相开通时，会产生一个沿abc轴中线方向的电压，记为2；三相全部开通时，互相抵消，则也相当于没有电压，记为3；SVPWM基于软件的调制方式如下图：我们可以看到，这种方法总是按照0-1-2-3-3-2-1-0的顺序打开、关断开关管，这样做的原因是这样可以最低限度地减少开关管开关的次数，提高效率。其中有效的仅有开一个和开两个的时候，只要我们计算出这两段的时间，并将垃圾时间用等长的0与3填充，就可以完成了，1、2的长度由矢量分解的方法来计算，如下图： SVPWM的具体步骤如下：第一步，我们要将360°的电角度分成六份，以方便我们选择合适的输出方式。如何判断一个向量在那个分区呢，我们当然可以麻烦地计算角度，也可以用用的更多的方法——计算特征电压：特征电压是指目标电压向量在三个垂直于abc轴得直线上的投影的长度，这个长度的正负决定了向量在abc三轴的哪一侧，得到了三个正负信息，组合起来就会有六种可能（两种不可能存在），这便对应着分区表的六个扇区。分区表如下：例如，在一号分区中，我们能使用的向量即a（1）与ab和（2）（同时确定能够使用的特征向量是+Uref2和+Uref1，正负号很重要！），我们根据分区就能确定所需要的向量。之后，根据一个几何关系，再次利用特征电压得出占空比的分配，通过电压的值确定占空比的大小，完成一次SVPWM调制。上面提到的几何关系如图，不太好解释："},{"title":"俺滴课表","date":"2020-02-24T17:46:00.000Z","url":"/2020/02/25/%E4%BF%BA%E6%BB%B4%E8%AF%BE%E8%A1%A8/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"欢迎大家按照课表时间来偶遇俺！ "},{"title":"技术传承——永磁同步电机驱动2","date":"2020-02-23T21:25:00.000Z","url":"/2020/02/24/%E6%8A%80%E6%9C%AF%E4%BC%A0%E6%89%BF%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A82/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"万众期待的P2来啦，这次为大家更新电流环与无感部分正好和要申的一个专利相关，就白嫖了一点过来自己白嫖自己应该不算什么侵权吧/笑哭 电流环控制——复矢量解耦首先，电流采样得到电机三相线上的交变电流，依次经过Clark变换、Park’变换，得到相对转子静止的旋转坐标系下电流，即Iq（q轴电流）与Id（d轴电流），通过复矢量解耦与PI控制器的方法计算出当前应加载在q、d轴上的电压Uq与Ud，进一步，再使用反Park变换计算出静止坐标系下交变电压Uα、Uβ，即可通过SVPWM调制得到三相方波占空比，控制永磁同步电机的电流，进而控制电机力矩。复矢量控制器的构造方法如下:对于隐极电机，有Ld=Lq=L可以看到q、d轴电压方程之间互相包含对方的电流，明显是一个耦合的系统。传统控制方法通过前馈的方法进行解耦，即在最终输入电机系统之前在输出电压值上补偿数学模型中这一项，系统就可以得到解耦。然而，前馈解耦的方法过渡依赖于电机参数，即我们必须得到准确的Ld、Lq以及才能够较好地消除耦合影响。由此导致采用前馈解耦控制方法的电机存在电流波动，相应慢的缺陷。本专利采用一种新型的复矢量解耦的方法进行电流环控制：首先构造控制量，构造电流复矢量i_S，其实部由id构成，虚部由iq构成，则有:同理，我们可以构造电压复矢量U_S，其实部u_d由构成，虚部由u_q构成，则有:将上述方程与电机数学模型联立，可得到由电流、电压复矢量构成的新的电压方程如下：由此可见，我们已经将两个互相耦合的系统变为一个整体，此时我们只需输出电压Us，即可控制电流is，在控制is的同时，id与iq也就得到了控制。 采取PI控制器控制:其中PI参数可选取控制系统带宽，有alpha越大，带宽越大，电流响应速度越快。但alpha不可无限制地增加，应考虑控制器输出电压的范围合理设计alpha的值。最后在最终输出的uq部分可以前馈补偿上，使模型更加拟合真实模型。 角度观测——扩张+龙伯格（Extended Luenberger Observer）电流环控制器设计完成后，我们考虑无传感器设计方案。传统无传感器算法通常采用六步换向法，即通过检测三相线上的反电动势来估计转子位置，通过控制逆变器的六种状态来实现电机的无传感器运行。但这种方法无法精确控制电流，且最终电流波形为方波而非正弦波，就可能导致电机运行不平稳，调速不灵活等问题。本专利采取无传感器FOC控制算法，可以精确控制电流，实现电机平稳运行。使用龙伯格观测器观测电机的位置与速度，为FOC算法提供位置参考。无传感器算法运行原理如下：启动前首先通过控制恒定的A相电流，电流产生的磁场使得电机转子转动到固定的启动位置，随后开启开环启动流程。开环启动时通过控制电流矢量的转动带动转子进行旋转，其中电流矢量旋转的速度与我们想要控制电机的速度相同当电机达到一定速度时，停止增大电流适量转速，此时电机会保持恒定的转速，此时产生的转矩与阻力相等，电流矢量一部分是q轴电流，一部分是d轴电流。适当降低电流大小使得转子角度更接近设定的电流矢量的角度。最后开启观测器，待观测器收敛，FOC算法使用观测到的角度，再由速度开环切换到速度闭环即可完成一次无传感器启动。龙伯格观测器算法原理：首先建立静止坐标系下电机模型:其中:把扰动E当作一个状态变量，则得到状态向量为:扩张后的状态方程为:其中：此处假设了的倒数均为0，即变化率为零。构建龙伯格观测器:其中K为观测器增益，是一个四行一列的矩阵，且应该有的形式。在满足能观性的前提下，通过调节K的值，可以设定观测器的带宽。最终即可得到的观测值。根据电机数学模型，有:，可由反三角函数计算出电角度的值:微分可计算出电角速度:观测器模型的改进:此前我们假设了变化率为零，但由上式我们得知，存在明显的微积分关系，可进一步改进观测器模型为可以进一步提升观测器跟随效果。 框图具体的系统框图如下： 下期应该会出SVPWM和逆变器部分！计网也在好好看啦（才怪）"},{"title":"技术传承——永磁同步电机驱动1","date":"2020-02-21T04:16:00.000Z","url":"/2020/02/21/%E6%8A%80%E6%9C%AF%E4%BC%A0%E6%89%BF%E2%80%94%E2%80%94%E6%B0%B8%E7%A3%81%E5%90%8C%E6%AD%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A81/","categories":[["控制","/categories/%E6%8E%A7%E5%88%B6/"]],"content":"记得当时是2018年寒假，加入机器人队不满半年，老余前辈开发出了机器人队历史上第一款好用的永磁同步电机驱动，当时的我也是真的懵，电机种类也不懂，电机原理也不会，恰巧哨兵需要一款新的yaw轴云台电机，而我又是哨兵控制的负责人，顺理成章的我就成了这款驱动的第一个实验品。一开始我是把他当作一个产品来用的，但是在使用过程中难免不会产生一些问题，我要到了源码，开启了我无刷驱动研究的大坑在这一年间，我从开始的一点也不会，到中间的 啥都懂一点，啥都不明白，到现在的初识foc算法，逆变器原理等基础知识，真的是历尽千辛万苦，十分感谢老余带我走上了这条控制的不归路。这次我主要讲一下 永磁同步电机中坐标变换的部分，有错误希望大家指出！首先问大家个问题：为什么要坐标变换？ Clark变换是为了将三相电流变换为两相正交电流，为Park变换做准备 Park变换是为了将定子电流坐标变换到转子上，最终我们的所有控制都是在转子上的 反Park变换时为了将控制量（电压）反推回定子端，以便进行SVPWM调制由此可见，坐标变换体现在驱动的方方面面。Clark变换Clark变换又分为两种形式：1、等幅值变换；2、等功率变换为什么会这样分呢，我们先来看一下他们俩的不同。等幅值变换等功率变换 原来只是矩阵前面的系数有差别啊！我们能发现，Clark变换大体就是把三相电流都向alpha、beta两正交轴投影，再将其相加。但是这前面这个系数又是怎么来的呢？但实际上，这个变换就是把原本存在三相上的电流抽象成了两项正交电流，而且为了保证抽象前后幅值不变，它带了一个系数2/3（由三相脉振磁场合成的旋转磁场幅值是原来的3/2），这就是等幅值变换等功率变换又是什么呢？为了使变换前后功率相等，即电压*电流相等，最终变换的系数变为了sqrt(2/3),这就是等功率变换。等幅值变换与等功率变换仅仅是两种不同的坐标变换，得到的电流有着不同的比例，其中等幅值变换拥有与测量电流同样的比例，所以我们一般使用等幅值变换。还要注意的是，使用两种变换由于电流比例不同，得到的力矩常数也不同，甚至永磁体磁链也不同，它们之间的都差一个常数sqrt（2/3）！ Park变换相对于Clark变换，Park变换就更加容易理解了!如上图所示，Park变换仅仅就是把定子坐标系变换到转子坐标系上，方便我们做控制（直接在定子上做其实也不是不行。。。），随后再用反变换变换到定子来输出电压。要注意的一点是公式中的theta指的是电角度thetaP，即实际机械角度的p倍（p为电机极对数）为什么要用thetP做变换呢？对于p对极的电机，磁场的变化是每360°/p的机械角度变化一周期，也就是360°电角度变化一周期，所以，永磁体磁链总是相对于转子静止的，力矩、强弱磁也仅仅是与q、d轴上的电流有关，所以我们要把电流变换到转子上。 今天这期我们主要讨论了基础的坐标变换理论，下期我们来讲解一下永磁电机中转子坐标下的控制方法。"},{"title":"计算机网络基础","date":"2020-02-20T23:02:00.000Z","url":"/2020/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"感谢林哥分享给我这本书（知道我被计算机网络困扰好久(✪▽✪)）计划在之后一周内读完，写一篇总结吧！文件存在我的另一个域名下：待会儿上传"},{"title":"对比ARM与x86的boot过程","date":"2020-02-20T02:30:00.000Z","url":"/2020/02/20/%E5%AF%B9%E6%AF%94ARM%E4%B8%8Ex86%E7%9A%84boot%E8%BF%87%E7%A8%8B/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"大家都应该熟悉x86架构cpu的启动方式首先是BIOS芯片，是一个固化了程序的CMOS芯片：作为设备上电第一个被执行的程序，无论是BIOS还是UEFI都会先取得设备的硬件信息，其中重要的就包括启动设备的查找顺序！下一步，BIOS会按照这个顺序检测到第一个设备的MBR区（BootSector），其中就存放着bootloader，BIOS会把bootloader加载到内存运行。bootloader：最常见的bootloader就是grub了，bootloader的最重要的作用是识别操作系统的文件系统格式，并且加载到内存中去运行，每个操作系统都应该有对应的bootloader。另外，bootloader还有另外一个作用，就是可以将启动管理的功能交给其他系统的bootloader，这也就是我们能在同一台电脑上同时安装Windows和Linux两个操作系统的原因了。当然加载完内核后还有初始化虚拟根目录，配置驱动程序，挂载根目录和systemd服务开启的诸多任务。 而对于经常玩STM32的我，bootloader一般是芯片厂商固化在芯片中的一段程序。由于STM32不需要把程序加载到内存中运行，而是在flash中直接被运行，bootloader可以被直接执行。bootloader的作用就是：1、选择启动方式；2、初始化芯片的一些基本功能能保证程序在flash中运。，之后，就可以把cpu使用权转交给程序了。当然，如果厂商提供的内嵌bootloader不能满足你的需求（比如需要在线升级固件的产品，即IAP），你也可以自己写 bootloader，将其烧在flash的某个特定区域，用自己的bootloader去引导程序执行。同时，我们熟知的startup启动文件也属于这个bootloader 最近一段时间看到了嵌入式Linux的启动方式，正是结合了上面两种启动方式的来的，最长用的嵌入式Linux的bootloader是U-Boot，相当于一段裸机程序，链接到第一个执行的位置，当然在启动时会被拿到ram中第一个执行。它的作用也是为Linux开路，配置Linux所需外设，初始化DDR，并且把Linux内核程序加载到ram中。之后的过程就与x86架构大同小异了。 由此可见，U-Boot可以说是发挥了BIOS与boootloader的作用，主要作用就是1、配置；2、加载内核。"},{"title":"11月3日东北大学交流感想","date":"2020-02-19T01:46:08.000Z","url":"/2020/02/19/11%E6%9C%883%E6%97%A5%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A6%E4%BA%A4%E6%B5%81%E6%84%9F%E6%83%B3/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"第一天晚上在没有提前说明的情况下来到了东大校园，正巧走到了Action的实验室门口。来不及感叹周围环境多高大上，首先吸引我的就是实验室周围的展板。不得不说，宣传方面我们做的技不如人，更重要的是，看到东大实验室许多产品都已经在华为、京东等公司有了应用，不得不感叹一句，人家的东西，是产品化的，是可以直接拿来用的，想想是多么精致啊。 第二天一早，我们第一次进入了Action实验室，第一项是各战队的介绍，在介绍中，对东京大学的介绍印象尤为深刻。不仅讲解了自己队伍的架构，还详细说明了Robocon2019，MR1与MR2的详细设计，控制策略等等很深入的东西。不得不说，Robocon这个比赛，虽然没有RoboMaster宣传多，沟通渠道多，但它根本真，更纯正，更像是一个技术交流平台。开源精神和研究的精神都有很多，让我们这些做过RM但是没做过RC的人不得不感到惊叹。 下午则是与东北大学等其他高校的深入交流。看到了东大四冠王的车，就像是随着时代进化一般，一代更比一代强。反观我们的技术水平，除了老余这一年驱动技术的进步，仿佛就像是停滞不前一样。我甚至觉得我们的车还停留在东大2017年的水平，深感惭愧。看到了Action2019赛季的轮式，做的精致的像是一辆超跑，无论是电机驱动，线路布置，机械结构，都称得上是完美的。再看到足式，方案确定、电机选型、包括那四台轰鸣的陀螺，真的是令人印象深刻，深感：“想出和做出这些方案的都是神仙吧！“ 这次去东大交流，不仅得到了知识与技术点，更重要的是让我认清了现实：一山更比一山高，不要认为自己已经做到极限了，世界上的某些地方，还存在着不知多少个和你同样在做着这个比赛，技术比你好，比你更努力的人！永远不要被自己所处的环境所制约。希望这次交流能够激励我以更加努力，更加渴望的态度去继续做下去，完成自己的愿望。"},{"title":"ARM裸机开发实战1","date":"2020-02-19T01:45:27.000Z","url":"/2020/02/19/ARM%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%981/","categories":[["开发","/categories/%E5%BC%80%E5%8F%91/"]],"content":"本科阶段的学习是应该学深还是学广呢，在我看来，应该学广，但是，也应该有自己特别擅长的一两个方向，其他的，浅尝辄止即可。 近几天又开了ARM Corrtex-A的新坑，明明连M系列都没怎么学明白的我胆子还真是大呢~，嵌入式老本行的我当然要把这部分死死地往深学。 废话不多说，总结一下Cortex-A系列裸机开发的容易懵逼的小知识点 本次使用的是正点原子Alphak开发板，搭载的是 I.MX6ULL芯片，单核Corex-A7。没有库，几千多页文档，看的我是着实头很大。不过在左神的带领下还是慢慢地摸清了它的门路，而且对STM32有了更深的理解，你说神不神奇！ 编译与链接： 编译会检查.c或.S文件的语法错误，并根据文件生成 对应的.o文件，即object文件 链接会根据.o文件之间的引用关系，找到文件之间、变量之间的联系，将其链接成一个二进制文件，.elf文件，这是一个Linux的二进制文件，其中除了包含机器码，还包含着其他额外的信息，我们由.elf生成.bin文件，就是可以让单片机看懂的文件了。 链接 时还要注意链接脚本的编写，链接脚本确定了程序的链接地址，即程序存放到内存的哪一片区域。程序还分为text、bss、data、等静态程序段，还有堆、栈等动态单元，这些都要放在不同的地址上去。 生成.bin文件后，还需要在前面添加IVT、Bootdata以及DCD等信息，这些信息是芯片启动时Bootram内程序会参考的信息，用于初始化DDR、MMU等设备，锁定运行地址，还可以初始化一些寄存器。添加完成之后就可以烧写进SD卡了。 启动流程： Bootram程序会检查几个IO以确定是串行烧写还是存储设备启动，是哪类存储设备，之后配置一些设备，然后会从运行地址开始运行程序。 汇编里要配置的东西： STM32的初始化由ST官方提供的STARTUP.S完成，而我们的I.MX6ULL只能由我们自己来完成了，大体步骤如下： 首先我们的链接脚本决定了我们的_start:标号被链接到了0X87800000这个地址，我们的header又决定了我们的执行也是从0X87800000这个地址开始所以第一个执行的语句就是_start咯！ 在_start:后，我们要手动配置中断向量表 原理就是改PC寄存器的值，是不是很简单。 复位中断这个很有意思，我们每次上电、复位都会使pc指向最一开始，也就是复位中断的位置，所以你说他没有也行"},{"title":"嗯，新的页面！","date":"2020-02-19T00:33:00.000Z","url":"/2020/02/19/%E5%97%AF%EF%BC%8C%E6%96%B0%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%81/","categories":[["日常","/categories/%E6%97%A5%E5%B8%B8/"]],"content":"欢迎新用户加入Star Blog！这里有注册地址–&gt;在这里注册登录哦！这里有注册地址–&gt;在这里注册登录哦！这里有注册地址–&gt;在这里注册登录哦！这里有注册地址–&gt;在这里注册登录哦！ 入坑Blog两周之后，我学了CSS，HTML，JS，PHP，但是都只学了个皮毛，为了能快速把Blog搭起来，我放弃了！因为这个开源博客框架真是太好用了！在这里强烈吹一波Typecho，可以说是能和WordPress比肩的开源网站框架也感谢这个Typecho主题Cuckoo的作者Bhao，向大佬学习！中国创造，轻量化，社区建设的也很好，源码开放供大家学习，简直良心！分享我的日常：雪中哈工大RoboMaster实况大家要是还想看我自制的旧的，丑的不要命的网站，欢迎访问  "}]