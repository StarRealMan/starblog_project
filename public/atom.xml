<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarBlog!</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-13T08:40:23.872Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Star YDY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕设开坑，欢迎大家关注</title>
    <link href="http://example.com/2020/11/29/%E6%AF%95%E8%AE%BE%E5%BC%80%E5%9D%91%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8/"/>
    <id>http://example.com/2020/11/29/%E6%AF%95%E8%AE%BE%E5%BC%80%E5%9D%91%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8/</id>
    <published>2020-11-28T23:14:00.000Z</published>
    <updated>2020-12-13T08:40:23.872Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新，这次开了毕设坑，欢迎大家关注我的github项目：<br><a href="https://github.com/StarRealMan/SSVIO">SSVIO</a><br><img src="/old_images/2020/11/1735837242.png" alt="2020-11-29 15-12-45 的屏幕截图.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没更新，这次开了毕设坑，欢迎大家关注我的github项目：&lt;br&gt;&lt;a href=&quot;https://github.com/StarRealMan/SSVIO&quot;&gt;SSVIO&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/old_images/2020/11/1735837242.p</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>从支持向量机到拉格朗日乘子对偶问题</title>
    <link href="http://example.com/2020/09/18/%E4%BB%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/09/18/%E4%BB%8E%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E5%88%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-17T19:11:00.000Z</published>
    <updated>2020-12-13T08:42:26.948Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就在林哥那儿听过支持向量机这个神奇的名字，是用来识别（分类）装甲板数字的，当时觉得很高深，很硬核。<br>最近在研读周志华老师所著的《机器学习》，又看到了这个熟悉而又陌生的名词——支持向量机。这次终于能够更深入地了解它了。写此文章来记录。</p><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><p>首先考虑一个二分类问题，我们有一组有标记的样本，分布在样本空间中，假设是一个二维的样本空间，那么它们看起来可能是这样的：<br><img src="/old_images/2020/10/3898272400.jpg" alt="2019-04-29-134021.jpg"><br>其中我们可以认为三角代表正类而圆圈代表反类。<br>怎样找到一条直线能够最大程度上地区分正类和反类呢？很容易想到我们需要一条直线（超平面），使它的一侧全是正类，另一侧全是反类。这种情况叫做线性可分的情况，等一会儿我们会讨论基本线性可分与非线性情况。<br><img src="/old_images/2020/10/3032572949.png" alt="1.1.png"><br>不过这样的直线（超平面）有很多，哪一条更好呢？这里的更好代表着对于新来的样本也能有很好的划分能力，所以我们启发式地想，找一条能够划分样本，并且两边样本到直线最近距离最大且相等的直线。<br><img src="/old_images/2020/10/4055019828.png" alt="2.1.png"><br>这些据直线最近的样本的位置（向量）就叫做支持向量。<br>用更严谨的数学表示就是：<br><img src="/old_images/2020/10/1161417211.jpg" alt="Snipaste_2020-10-05_21-09-28.jpg"><br><img src="/old_images/2020/10/513067831.jpg" alt="Snipaste_2020-10-05_21-09-43.jpg"><br>不要忘记我们能够划分样本的条件：<br><img src="/old_images/2020/10/2013533644.jpg" alt="Snipaste_2020-10-05_21-09-17.jpg"><br>细心的我们可以发现，我们定义的这个直线理应具有dim(w)个自由度，而实际上却有dim(w)+1个参数（别忘了截距b），我们很容易想到，同时放大缩小w与b，直线是不变的，但是对于直线wx+b=1，却是在变化的，因此我们仅仅优化|w|²看似不合理，实际上整条直线已经在条件中进行了限制，所以b也会被考虑进去的。</p><p>于是我们使用支持向量机把二分类模型训练问题转化为了一个带不等式约束的优化问题。<br>我们知道对于等式约束的优化问题我们可以用拉格朗日乘子法进行解决，但是对于不等式约束，我们又该怎样解决呢？<br>我们称这个优化问题为原始问题，解决办法就是使用拉格朗日乘子法找到一个对偶问题，解决对偶问题并且在满足KKT条件的情况下，我们就能解决原始问题。<br>那么具体怎么做呢？<br>首先还是使用拉格朗日乘子法，找到拉格朗日函数：<br><img src="/old_images/2020/10/3422282407.jpg" alt="Snipaste_2020-10-05_21-27-07.jpg"><br>为了把不等式约束消解掉，我们分情况讨论：<br>如果求得的直线不满足不等式约束，则L取得max只需要α-&gt;∞，就有：<br><img src="/old_images/2020/10/2634073253.jpg" alt="Snipaste_2020-10-05_21-28-01.jpg"><br>如果满足不等式约束，则有L取得max发生在α=0的情况下，即：<br><img src="/old_images/2020/10/1816268613.jpg" alt="Snipaste_2020-10-05_21-28-08.jpg"><br>所以我们把不等式约束的优化问题化为双重最值的优化问题：<br><img src="/old_images/2020/10/2296969013.jpg" alt="Snipaste_2020-10-05_21-28-13.jpg"><br>根据对偶原理，它的对偶问题为：<br><img src="/old_images/2020/10/270394888.jpg" alt="Snipaste_2020-10-05_21-34-33.jpg"><br>同时还要满足KKT条件：<br><img src="/old_images/2020/10/2604642185.jpg" alt="Snipaste_2020-10-05_21-35-19.jpg"><br>解得最终的超平面为：（具体方法略）<br><img src="/old_images/2020/10/1506103335.jpg" alt="Snipaste_2020-10-05_21-35-19.jpg"><br>我们还得到一个结论，就是最终发挥作用的样本点只有支持向量，这点我们也能直观地感受到。</p><h2 id="还有一些没解决的问题"><a href="#还有一些没解决的问题" class="headerlink" title="还有一些没解决的问题"></a>还有一些没解决的问题</h2><p>上面一节我们只讨论了线性可分的情况，如果遇到基本上线性可分的情况（有有限个点被分错），或者非线性可分的情况<br><img src="/old_images/2020/10/1768418527.jpg" alt="2019-03-08-010339.jpg"><br>我们该怎么办呢？</p><p>1.软间隔法<br>对于基本上线性可分的情况，我们可以改进优化参数，使其允许一些错误出现，但是要尽最大可能避免这些错误，比如这样：<br><img src="/old_images/2020/10/2773680925.jpg" alt="Snipaste_2020-10-05_21-41-57.jpg"><br>在优化函数中引入惩罚项，惩罚那些超过界限的样本点。<br>2.核方法<br>对于非线性的方法，软间隔就不能用了，比如这种情况：<br><img src="/old_images/2020/10/2447629851.jpg" alt="Snipaste_2020-10-05_21-44-07.jpg"><br>但是我们可以使用一个映射将样本转换到另一个空间中<br><img src="/old_images/2020/10/2420399875.jpg" alt="Snipaste_2020-10-05_21-45-04.jpg"><br><img src="/old_images/2020/10/3031661130.png" alt="下载.png"><br>这样就能解决非线性可分的问题了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很早以前就在林哥那儿听过支持向量机这个神奇的名字，是用来识别（分类）装甲板数字的，当时觉得很高深，很硬核。&lt;br&gt;最近在研读周志华老师所著的《机器学习》，又看到了这个熟悉而又陌生的名词——支持向量机。这次终于能够更深入地了解它了。写此文章来记录。&lt;/p&gt;
&lt;h2 id=&quot;支</summary>
      
    
    
    
    <category term="控制" scheme="http://example.com/categories/%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>第二次硬件尝试之开关电源</title>
    <link href="http://example.com/2020/09/13/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A1%AC%E4%BB%B6%E5%B0%9D%E8%AF%95%E4%B9%8B%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/"/>
    <id>http://example.com/2020/09/13/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%A1%AC%E4%BB%B6%E5%B0%9D%E8%AF%95%E4%B9%8B%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/</id>
    <published>2020-09-12T19:45:00.000Z</published>
    <updated>2020-12-13T08:40:41.743Z</updated>
    
    <content type="html"><![CDATA[<p>为了能使树莓派脱离有线的束缚，我这次就做一个简单的锂电池充放电电路来练练手(●ˇ∀ˇ●)<br>（第一次做了更为简单的STM32-UARTHUB）<br>电源芯片选择的是珠海智融科技有限公司的SW6124，SW6124是一款高度集成的电源管理IC，适用于快速充电移动电源应用。 它集成了4A开关充电器，18W同步升压，PD / QC / FCP / PE / SFCP快速充电协议，电量计和电源控制器。 SW6124借助简单的外部组件，为快速充电电池管理提供了交钥匙的高效解决方案。</p><p>手册最后给出了电池管理充放电应用电路图：<br><img src="/old_images/2020/09/2522050574.jpg" alt="Snipaste_2020-09-13_15-05-50.jpg"><br>已经比较符合我们的需求了，我们在其之上稍作更改，去掉了USB-A和Micro USB的接口，仅保留USB Type-C接口。并且使用一个单刀双置开关切换USB供电与电池供电。<br>原理很简单，在插入USB TypeC时，使用开关将5V输出直接与TypeC电源连接，直接向树莓派供电，与此同时，TypeC电源也向电池充电。在未插入USB时，使5V输出与Boost电路输出端相连接，使用电池进行供电。<br>画出原理图：<br><img src="/old_images/2020/09/1356202506.jpg" alt="Snipaste_2020-09-13_15-10-15.jpg"><br>TypeC接口部分；<br><img src="/old_images/2020/09/2234319971.jpg" alt="Snipaste_2020-09-13_15-10-54.jpg"><br>开关，树莓派插针部分；<br><img src="/old_images/2020/09/2393108645.jpg" alt="Snipaste_2020-09-13_15-11-29.jpg"><br>芯片电量显示部分；<br><img src="/old_images/2020/09/2995037215.jpg" alt="Snipaste_2020-09-13_15-11-48.jpg"><br>芯片Boost电路（3.7V-&gt;5V）及控制部分。<br>这个电路最重要的部分就是开关电源部分，好在SW6124集成了开关管以及控制电路，我们只需要外加一个电感就能实现Boost升压的功能。</p><p>最后就是PCB绘制：<br>首先进行布局布线。简单的PCB布局可以按照原理图的分布进行，并且要合理设计接口位置，注意芯片手册上的说明和注意事项。布线过程中注意根据线所流经的电流大小调整线的粗细，上层下层横纵交错，GND网络使用覆铜进行连接。<br><img src="/old_images/2020/09/2369037501.jpg" alt="Snipaste_2020-09-13_15-23-20.jpg"></p><p>接下来是覆铜。对于信号要求较高的板子，最好分离信号地与电源地，并且在覆铜结束后检查是否留有未接通的GND网络，进行微调（比如打过孔）。<br>最终一个简单的锂电池充放电电路板就绘制完成了，接下来就是焊接和调试啦！<br><img src="/old_images/2020/09/1988211125.jpg" alt="Snipaste_2020-09-13_15-27-03.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了能使树莓派脱离有线的束缚，我这次就做一个简单的锂电池充放电电路来练练手(●ˇ∀ˇ●)&lt;br&gt;（第一次做了更为简单的STM32-UARTHUB）&lt;br&gt;电源芯片选择的是珠海智融科技有限公司的SW6124，SW6124是一款高度集成的电源管理IC，适用于快速充电移动电源应用</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ROS入门</title>
    <link href="http://example.com/2020/08/28/ROS%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2020/08/28/ROS%E5%85%A5%E9%97%A8/</id>
    <published>2020-08-28T06:08:00.000Z</published>
    <updated>2020-12-13T08:47:32.196Z</updated>
    
    <content type="html"><![CDATA[<p>进入大四，终于要开启我的ROS之旅。<br>接触了几天ROS，越发发觉它的便利，今天来记录一下最基础的ROS操作。（大部分来自<a href="https://www.ros.org/">ROS官网</a>，俗话说官网是学习的最佳路径）</p><h2 id="ROS项目管理机制"><a href="#ROS项目管理机制" class="headerlink" title="ROS项目管理机制"></a>ROS项目管理机制</h2><p>ROS使用Workspace+Package的方式来管理一个项目。比如以一个机器人为例，机器人的每一个功能（比如传感器数据接收，运动控制，导航感知，决策）都会对应一个Package，这些Package之间可能互相依赖，他们共同构成一个Workspace，就构成了这个机器人整体。<br>从零开始构建一个项目，首先需要构建一个Workspace，使用：</p><pre><code>$ mkdir -p ~/catkin_ws/src        #用来存放Package$ cd ~/catkin_ws/$ catkin_make</code></pre><p>在家目录构建一个空的，名为catkin_ws的Workspace，使用<strong>catkin_make</strong>可以自动生成一些所需的配置文件和目录（这个命令也充当着ROS管理工程中CMake的作用）。<br>如果想让ROS命令认识这个包，需要把他的位置加入到环境变量中去，这时我们就需要使用source（用来执行命令行脚本）执行～/catkin_ws/devel/中的 setup.bash命令了。这时$ROS_PACKAGE_PATH变量就包含了我们的工作区/src/目录。<br>如果想要使用官方的一些Package，他们的初始化脚本是/opt/ros/<distri>/setup.bash。（也可将其放入~/.bashrc中，在启动终端后自动执行）<br>对ROS的Package的一些操作：</p><pre><code>$ rospack find [package_name]$ roscd [locationname[/subdir]]$ roscd log$ rosls [locationname[/subdir]]</code></pre><p>如何创建一个Package？<br>一个Package由一个独立的文件夹内的package.xml和一个CMakeists.txt文件（以及其他必要文件）组成，如下所示：</p><pre><code>workspace_folder/        -- WORKSPACE  src/                   -- SOURCE SPACE    CMakeLists.txt       -- &#39;Toplevel&#39; CMake file, provided by catkin    package_1/      CMakeLists.txt     -- CMakeLists.txt file for package_1      package.xml        -- Package manifest for package_1    ...    package_n/      CMakeLists.txt     -- CMakeLists.txt file for package_n      package.xml        -- Package manifest for package_n</code></pre><p>如何自动创建这些文件？在~/catkin_ws/src目录中使用</p><pre><code>$ catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code></pre><p>创建一个依赖于dependx的Package。<br>使用</p><pre><code>$ catkin_make$ . ~/catkin_ws/devel/setup.bash</code></pre><p>build这个Workspace（内的所有Package），并且将其（内的所有Package）加入环境变量。</p><p>这些Package都有着各自（直接）依赖的Package，catkin_create_pkg命令中的dependx会体现在package.xml中。<br>直接的依赖Package使用以下命令查看：<br>$ rospack depend1 [Package name]<br>间接的依赖Package使用以下命令查看：<br>$ rospack depends [Package name]<br>对于你自己的项目，可以通过修改package.xml和CMakeLists.txt来进行定制化的操作。（详细略）</p><p>就如同CMake管理的项目一样，ROS管理的项目使用catkin_make进行项目的编译构建。<br>在～/catkin_ws/中使用：</p><pre><code>$ catkin_make$ catkin_make install  # (optionally)</code></pre><p>这个命令会build整个Workspace下的所有Package，与cmake命令有相同作用。</p><h2 id="ROS通信机制-1"><a href="#ROS通信机制-1" class="headerlink" title="ROS通信机制 1##"></a>ROS通信机制 1##</h2><p>ROS不仅为我们提供了一种项目管理的功能，还提供了一种便利的多进程通讯机制。<br>要启用这个多进程通讯机制，首先我们要启动ROS内核，使用：</p><pre><code>$ roscore</code></pre><p>这个roscore进程是ROS进程间通讯的核心，起到了中继站的作用。一切ROS应用都少不了它。<br>ROS中，node代表一个可以进行通讯的节点，使用以下命令查看node属性：</p><pre><code>$ rosnode list$ rosnode info /[node name]$ rosnode ping /[node name]</code></pre><p>使用rosrun来运行一个Package中的node。</p><pre><code>$ rosrun [package_name] [node_name]$ rosrun turtlesim turtlesim_node __name:=my_turtle</code></pre><p>node之间通讯是通过node-msg-topic机制，两个或多个node向同一个topic发送消息msg，并接收其他node的特定的消息msg，就能实现通讯。<br>使用以下命令可以图形化查看当前运行中的node和topic：</p><pre><code>$ rosrun rqt_graph rqt_graph</code></pre><p>为了查看运行中topic中传递的数据和一些其他信息，使用：</p><pre><code>$ rostopic echo [topic]$ rostopic list -h$ rostopic list -v$ rostopic type [topic]$ rosmsg show [msg type]$ rostopic hz$ rosrun rqt_plot rqt_plot</code></pre><p>手动上传msg到指定的topic，使用：</p><pre><code>$ rostopic pub [topic] [msg_type] [args]</code></pre><p>（注意，我们在命令行中使用的一些命令也是通过创建节点来实现功能的）</p><h2 id="ROS通信机制-2"><a href="#ROS通信机制-2" class="headerlink" title="ROS通信机制 2##"></a>ROS通信机制 2##</h2><p>除了node-msg-topic的通信方式，我们还可以通过service实现通信。<br>rosservice的基本使用方法：</p><pre><code>$ rosservice list         print information about active services$ rosservice call         call the service with the provided args$ rosservice type         print service type$ rosservice find         find services by service type$ rosservice uri          print service ROSRPC uri</code></pre><p>总而言之，每个Package会包含一些service，使用rosservice call可以调用这些service（可以理解为调用方法），实现某些功能。</p><p>使用rosparam可以存储某个Package参数，调整Package的功能：</p><pre><code>$ rosparam set            set parameter$ rosparam get            get parameter$ rosparam load           load parameters from file$ rosparam dump           dump parameters to file$ rosparam delete         delete parameter$ rosparam list           list parameter names</code></pre><p>使用图形化界面管理ROS，使用如下命令：</p><pre><code>$ rosrun rqt_console rqt_console$ rosrun rqt_logger_level rqt_logger_level</code></pre><p>使用.launch文件一键启动整个项目：</p><pre><code>$ roslaunch [package] [filename.launch]&lt;launch&gt;  &lt;group ns=&quot;turtlesim1&quot;&gt;    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;  &lt;/group&gt;  &lt;group ns=&quot;turtlesim2&quot;&gt;    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;  &lt;/group&gt;  &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;    &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;    &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;  &lt;/node&gt;&lt;/launch&gt;</code></pre><p>使用rosed进行编辑：</p><pre><code>$ rosed [package_name] [filename]</code></pre><p>创建Package_dir/msg/Num.msg文件，来规定传递的msg。<br>创建Package_dir/srv/AddTwoInts.srv文件，来规定service的类型。<br>（需要在package.xml和CMakeists.txt声明该文件）</p><pre><code>$ rosmsg show [message type]$ rosmsg -h$ rossrv show &lt;service type&gt;</code></pre><p>最后，我们可以在C++程序中使用ROS的库来实现msg和service的操作。<br>（对于我们添加的msg和srv，make后会自动生成对应的头文件，便于对其进行操作）</p><pre><code>#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &quot;Package_dir/AddTwoInts.h&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进入大四，终于要开启我的ROS之旅。&lt;br&gt;接触了几天ROS，越发发觉它的便利，今天来记录一下最基础的ROS操作。（大部分来自&lt;a href=&quot;https://www.ros.org/&quot;&gt;ROS官网&lt;/a&gt;，俗话说官网是学习的最佳路径）&lt;/p&gt;
&lt;h2 id=&quot;ROS项目管</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>利用ANSYS进行叶轮动态流场仿真分析实例</title>
    <link href="http://example.com/2020/08/15/%E5%88%A9%E7%94%A8ANSYS%E8%BF%9B%E8%A1%8C%E5%8F%B6%E8%BD%AE%E5%8A%A8%E6%80%81%E6%B5%81%E5%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2020/08/15/%E5%88%A9%E7%94%A8ANSYS%E8%BF%9B%E8%A1%8C%E5%8F%B6%E8%BD%AE%E5%8A%A8%E6%80%81%E6%B5%81%E5%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-15T07:37:05.000Z</published>
    <updated>2020-12-13T08:40:50.999Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是Albert！没错，我又来了！最近题主正在做一个小项目，其中一个功能就是利用一个半开离心泵进行对一个有限固定水域（就是一个小泳池）进行水循环，我们都知道洗衣机滚筒就是一个典型的离心泵，所以有很大可能将离心泵开口后，里面的水有可能流不出来，或者说达不到预期参数，为了直观快速地看到整个流场情况以确定下一步迭代方向，题主选择了ANSYS中的Fluent作为仿真平台，借着这个项目正好分享一下动态仿真如何进行。下图是离心泵模型图和简化模型图（因为是几小时出的初稿，很丑）。</p><p><img src="/old_images/2020/08/615084051.png" alt="离心泵模型图.PNG"></p><p><img src="/old_images/2020/08/1060845710.png" alt="简化模型图.PNG"></p><p><strong><em>一、模型前处理及导出</em></strong></p><p>从上面两张图可以看出，简化模型主要保留了离心泵特征和开口尺寸等关键信息，这样的处理是为了减少计算量，突出问题主要矛盾。除此之外呢，可能比较注重细节的同学看到了简化模型有些许不同，在叶轮外加了一个圆柱体，这部分叫做仿真的前处理，在进行动态流场仿真的时候，流体的传递并不是像真实物理世界连续传递那样，那样的计算量过于庞大，效率很低，Fluent的解决方式是通过interface连接动域和静域，将流动流体（interior）交互到静止流体（interior）中，所以在前处理就是要建立流动域和静止域，方便后面几何处理，从简化模型中可以看出，圆柱体作为旋转域，外部的几何体为静止域，通过圆柱外表面作为interface进行交互。将简化后的模型导出为STEP格式、igs格式或Parasolid格式均可，即可进行下一步操作。</p><p><strong><em>二、ANSYS中几何处理及划分网格</em></strong></p><p>题主使用的版本是ANSYS 17.0，下一步就是打开Workbench，将Geometry模块拖入工作区然后打开Geometry后，将刚刚导出的模型文件导入Geometry中，结果就像下图所示，可能不同格式文件导入会出现一些不同，比如题主使用的是STEP格式，会导致圆柱面分离，即图中看到的圆柱壁面分成了两个面，这时候使用Tools下面的merge指令选择需要合并的面，合并一些面，做成连续面，这样处理也是为了减小运算量和避免一些玄学BUG。</p><p><img src="/old_images/2020/08/2072954433.png" alt="1.PNG"></p><p><img src="/old_images/2020/08/3016259840.png" alt="2.PNG"></p><p>基本上模型处理成这样就可以了，下一步就要建立旋转域和静止域，这里用到的是Tools下的Enclosure指令，因为我们是自己创建的几何体，所以类型选择User Defined，这里面有一个点是需要关注，以旋转域为例，所谓旋转域就是由于叶轮运动而旋转的水，所以旋转域应当是圆柱体与叶轮实体的差集，在类型选择上，User Defined Body选择圆柱体，即基本几何轮廓，Target Body选择叶轮，即内部实体，两者取差集得到流动域。如下图所示。</p><p><img src="/old_images/2020/08/3614482147.png" alt="3.PNG"></p><p><img src="/old_images/2020/08/1639294894.png" alt="4.PNG"></p><p>静止域的处理方法与旋转域相同，题主只把最后得到的效果放出来，这一步处理之后我们就可以close Geometry了，然后进入下一步了。</p><p><img src="/old_images/2020/08/4046785801.png" alt="5.PNG"></p><p>此时返回Workbench主界面，将Fluid Flow（Fluent）拖入界面连接到Geometry上，并双击打开mesh进行网格划分。这里的mesh是ANSYS自带的网格划分软件，一些基本处理是可以完成的，是基于ICEM，所以和ICEM界面一样感人。</p><p><img src="/old_images/2020/08/482966380.png" alt="6.PNG"></p><p>当我们进入mesh后，第一步在左侧结构树中先找到叶轮，将其suppress掉，方便后续处理，接下来是设置一下进出口面（inlet和outlet），目的是方便观察，还有就是气动仿真中会用到计算起点，对于液体来说就是方便观察。第二步是最关键的，即在旋转域中建立动力交互面interface，我们先把刚刚得到的旋转域独立出来（即将其余body隐藏掉），将光标选择换为Box Select。</p><p><img src="/old_images/2020/08/1083781610.png" alt="7.PNG"></p><p>然后长按鼠标左键框选旋转域中的叶轮表面，记住此时的叶轮形状并不属于叶轮实体，而是旋转域的内壁表面，然后右键绿色区域，并Create Named Selection，这样导入Fluent就可以自动生成interface了。</p><p><img src="/old_images/2020/08/2373904712.png" alt="8.PNG"></p><p>下一步就是自动划分网格了，直接点击mesh，generate即可，因为是自动划分的网格，所以网格尺寸较大，可根据需要调整尺寸大小，在Body Sizing中调整element size。</p><p><img src="/old_images/2020/08/350215919.png" alt="9.PNG"></p><p><img src="/old_images/2020/08/1791974604.png" alt="11.PNG"></p><p> 网格划分完毕后，我们的前处理就完成了，即可进入Fluent里进行计算了。</p><p><strong><em>三、仿真计算</em></strong></p><p>我们close meshing后返回Workbench主界面，先update一下mesh文件，然后双击打开Setup，这里设置一下计算方式换为并行计算，将核数改为6，增加一个GPU，提高计算速度。</p><p><img src="/old_images/2020/08/437577698.png" alt="10.PNG"></p><p>将General设置如下图，我们这次选择的是瞬时分析，由于流体是水，一定要加上重力加速度。</p><p><img src="/old_images/2020/08/3976439614.png" alt="12.PNG"></p><p>粘性模型选择K-omega下的SST模型，在Model下的Viscous选项中选择，并在材料中，将液态水添加进流体类型中，关键步骤，设置旋转域旋转，旋转域转轴及转速，如下图所示，选择mesh motion，右侧是旋转轴方向，左侧是旋转轴相对于世界坐标系的偏移量，由于我的叶轮旋转轴与世界坐标系Y轴重合，即无需偏移，转速设置为25rad/s。</p><p><img src="/old_images/2020/08/502004202.png" alt="13.PNG"></p><p>下一步就是进行初始化，选择Hybrid Initialization，初始化后的步骤就是preview，及观察叶轮是否转动，保证我们的计算是有效的。在preview中，设置步长0.01s，先跑10步。</p><p><img src="/old_images/2020/08/4228770977.png" alt="14.PNG"></p><p>preview验证 - 知乎<br><a href="https://www.zhihu.com/zvideo/1277979482393960448">https://www.zhihu.com/zvideo/1277979482393960448</a></p><p>从preview的视频中看出，叶轮的转动是正常，我们就可以开始仿真了，由于仿真时间太长，收敛后是十分密的锯齿曲线，直接上结果，速度场变化的动画。从仿真视频中可以看出，水是可以从离心泵中流出来，但是流域不是很理想，这就需要后面慢慢改导流机构啦！（由于这个Blog添加不了视频，我就把视频放到了知乎上，后面的连接复制打开一下就能看到结果啦！）</p><p>速度场结果 - 知乎<br><a href="https://www.zhihu.com/zvideo/1277981000899616768">https://www.zhihu.com/zvideo/1277981000899616768</a></p><p>下次看个人情况更新机器人学或者SLAM十四讲的学习笔记吧！希望对你有用，bye！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，我是Albert！没错，我又来了！最近题主正在做一个小项目，其中一个功能就是利用一个半开离心泵进行对一个有限固定水域（就是一个小泳池）进行水循环，我们都知道洗衣机滚筒就是一个典型的离心泵，所以有很大可能将离心泵开口后，里面的水有可能流不出来，或者说达不到预期参数，为</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>从双网卡——到路由表</title>
    <link href="http://example.com/2020/08/13/%E4%BB%8E%E5%8F%8C%E7%BD%91%E5%8D%A1%E2%80%94%E2%80%94%E5%88%B0%E8%B7%AF%E7%94%B1%E8%A1%A8/"/>
    <id>http://example.com/2020/08/13/%E4%BB%8E%E5%8F%8C%E7%BD%91%E5%8D%A1%E2%80%94%E2%80%94%E5%88%B0%E8%B7%AF%E7%94%B1%E8%A1%A8/</id>
    <published>2020-08-13T02:18:00.000Z</published>
    <updated>2020-12-13T08:44:37.791Z</updated>
    
    <content type="html"><![CDATA[<p>现在的电脑一般都拥有双网卡，但这是否是一件好事呢？对于某些小白来说，可能并不是（比如我(●ˇ∀ˇ●)）。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>拿到刚到手的树莓派，首先要做的肯定是配环境！但是在VNC连接树莓派时遇到了问题：<br>当我使用WIFI连接树莓派时，由于带宽限制，界面很卡，影响体验。<br>当我使用有线连接树莓派时，由于有线网卡的优先级高于无线网卡，导致树莓派只能浏览内网（也就是我笔记本的网络），如果使用笔记本共享外网的话只能使用DHCP自动分配IP，这样则会导致IP变化不方便我们连接 树莓派。<br>但是我明明有一个无线网卡连接外网啊！！！怎样才能把它利用起来，成了我要解决的问题。</p><h2 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h2><p>找了好久，终于发现了路由表这个神奇的东西，<br><a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E8%A1%A8">百度百科</a>这样说道：<br>在计算机网络中，路由表（routing table）或称路由择域信息库（RIB, Routing Information Base），是一个存储在<strong>路由器</strong>或者<strong>联网计算机</strong>中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。</p><p>简单来讲，路由表可以规定发往何处的信息使用哪一个路由，也就是决定要发出的信息（对于计算机）或收到的信息（对于路由器）的下一跳是哪里。</p><p>在linux中配置路由表很简单，因为它全部被集成到了route这一个指令中。<br>首先我们来看路由表长什么样。<br>拿我的服务器举例，在终端中输入（sudo）route，可以看到：<br><img src="/old_images/2020/08/75184131.jpg" alt="Snipaste_2020-08-13_17-38-05.jpg"><br>其中Destination表示目标的IP地址；<br>Gateway表示选择下一跳网关IP地址（所有跨网段传输的信息均需要通过该网段的网关传输）；<br>GenMask代表掩码，用于确定一个网段；<br>Flags是用于区分的标志位；<br>Iface是网卡设备的名称（可以使用（sudo）ifconfig来查看）；<br><img src="/old_images/2020/08/1049549032.jpg" alt="Snipaste_2020-08-13_17-44-12.jpg"><br>Flags标志位确定了一系列的路由类型，主要有以下几种：<br><strong>主机路由：</strong><br>顾名思义，主机路由表示单独指向某个特定主机（IP）的路由，所有目标为该主机的信息都发送到所设定的网关，同时也确定了用哪个网卡设备传输信息。<br>主机路由除了Flags的区别，最明显的特征就是它的Destination是一个完整的IP地址，并且它的GenMask是255.255.255.255。这说明了它的目标不是一个网络而是一个特定的主机（IP）。</p><hr><p><strong>网络路由：</strong><br>理解了主机路由 在来理解网络路由并不是很难。网络路由指向一个特定的网段，因此它的GenMask不全是 1（比如是255.255.0.0）。它的Destination中也包含0（比如192.168.0.0），0的含义就是任意，这个网段表示整个192.168.*.*的网络。<br>同理，所有目标为该网络的信息都发送到所设定的网关。</p><hr><p><strong>默认路由：</strong><br>剩下最简单的就是默认路由了，没有特殊指明的主机（IP），就发送到默认路由设定的网关。默认路由最明显的特征是它的Destination是default，GenMask是0.0.0.0（表示全部网段）。</p><p>想要改变路由表，就要使用route命令，它的基本操作如下：</p><p>添加路由：route add</p><ol><li>route add -host 192.168.1.2 dev eth0 添加设备eth0为主机路由，主机IP为192.168.1.2</li><li>route add -host 10.20.30.148 gw 10.20.30.40 添加网关10.20.30.40为主机路由</li><li>route add -net 10.20.30.40 netmask 255.255.255.248 eth0 添加网络路由，网段为255.255.255.248 </li><li>route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41 同上，使用网关添加</li><li>route add -net 192.168.1.0/24 eth1 添加网络路由，使用目标IP段/MASK位数形式</li><li>route add default gw 192.168.1.1 添加默认路由</li></ol><p>删除路由：route del</p><ol><li>route del -host 192.168.1.2 dev eth0 原理同上</li><li>route del -host 10.20.30.148 gw 10.20.30.40</li><li>route del -net 10.20.30.40 netmask 255.255.255.248 eth0</li><li>route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41</li><li>route del -net 192.168.1.0/24 eth1</li><li>route del default gw 192.168.1.1</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>了解了基础知识，我们来解决一下实际问题！<br>首先删除所有默认网关：</p><pre><code># sudo route del default gw 192.168.20.1# sudo route del default gw 192.168.21.1</code></pre><p>添加eth0（有线网卡）仅进行内网访问，即仅在Destination为192.168.*.*的时候使用它。</p><pre><code># sudo route add -net 192.168.0.0 netmask 255.255.0.0 eth0（或gw 192.168.21.1）</code></pre><p>添加wlan0（无线网卡）进行全网络的访问，即在非内网情况下，使用wlan0进行访问。</p><pre><code># sudo route add default wlan0（或gw 192.168.20.1）</code></pre><p>需要注意的是，如果使用网关确定，需要设置两个网卡的 默认网关不同；<br>这样设置还有一个弊端就是在访问外网时不能使用有线网卡，可能在没有WiFi的情况下还需要切换。</p><p>这样设置下来，双网卡内外分工就大功告成了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在的电脑一般都拥有双网卡，但这是否是一件好事呢？对于某些小白来说，可能并不是（比如我(●ˇ∀ˇ●)）。&lt;/p&gt;
&lt;h2 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h2&gt;&lt;p&gt;拿到</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>轨道交通领域的差速问题&amp;amp;我与轨交</title>
    <link href="http://example.com/2020/07/16/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%AE%E9%80%9F%E9%97%AE%E9%A2%98&amp;amp;%E6%88%91%E4%B8%8E%E8%BD%A8%E4%BA%A4/"/>
    <id>http://example.com/2020/07/16/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E5%B7%AE%E9%80%9F%E9%97%AE%E9%A2%98&amp;amp;%E6%88%91%E4%B8%8E%E8%BD%A8%E4%BA%A4/</id>
    <published>2020-07-16T08:07:40.000Z</published>
    <updated>2020-12-13T08:38:48.538Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是那个喜欢火车的Captain。<br>有人说，一个男人不成熟的标志是可以为了一项事业英勇地死去，而一个男人成熟的标志是可以为了一项事业卑贱地活着。我可能是成熟了。在上个周末，从7月10号到13号的四天时间里，我经历了两场专业课考试，一个夏令营，外加一篇恶心的硕士毕业设计级别的论文（我正在和这个课的老师对线，祝我成功）。可喜的是，夏令营的结果还不错，优营在手，只可惜没有推免资格，不能很有底气地去跟想考的导师聊，虽然现在也有别的方向的导师要我。可能不满足和缺陷才是人生的真正形态吧。<br>今天拿到了结果其实挺高兴的，听栋宇说明天考完试打算给这个blog做个宣传，我说那我不如今晚出一篇文章，开始。<br>我是学电气的，或者说我本科是学电机的，就是那个会动的大铁疙瘩，但我今天想跟大家聊聊偏机械方面的内容。<br>我们日常生活中最常见的交通工具应该就是汽车了。无论以什么能源方式驱动，汽车在行驶过程中都会遵循相同的规律，我转动方向盘，前轮的方向就会变化带动汽车曲线运动。对于轨道交通（传统轮轨）而言，这样的过程发生在铁轨与走行部之间。<strong>走行部，理解字面即可，用于列车在铁轨上走行的部分。</strong>通俗一点讲，就是转向架。如果你不知道转向架是什么，没关系，你可以理解为是火车的车轮以及和它配套的一系列起到固定、缓冲减震、传动作用的机械系统。<br>可能很多人大概知道转向架是什么，但并没有真正地去研究过。的确，很惭愧地讲，在准备这个夏令营之前我也没有好好研究过，我关注的往往是与电有关的内容，机械部分的我一般都会很礼貌地跳过。转向架就是铁路车辆转弯的作动装置，它的上部与车厢相连接，并可以以垂直道面的方向为轴做小角度转动。<strong>注意，这里说的是“垂直道面的方向”，而不是竖直方向或者重力方向，</strong>一会儿会说为什么。一个转向架大概长这样。<br><img src="/old_images/2020/07/623017393.jpg" alt="装箱架.jpg"><br>我们可以看到它有两对车轮。同轴的一对车轮我们称之为一个“轮对”，有几个轮对就称几轴。例如，我们最常见的25系列客车，也是现在普铁最广泛使用的列车，每节车厢有两个二轴转向架，车辆本身是四轴车。有兴趣的小伙伴可以去B站等平台搜一下C64K，神华十二轴电力机车，那可是机车届的扛把子，全世界功率最大的机车，单机功率达到了14400kW。14400是什么概念呢，这么说吧，感兴趣的朋友可以去看我的上一篇投稿，CRH2A非统型两列加一起差不多也就这配置。<br>我们来简单了解一下转向架的构造。传统的转向架有一类叫做“三大件式转向架”，三大件指的是两个侧架和一个摇枕。摇枕指的就是转向架中央与车体接触的条状或盘状或长条形的机械结构，承担车体重量，同时能够像刚才说的那样转动。摇枕本身是和车体相对静止的，转动时是二者共同相对于转向架其他机构轴向转动。转向架的另一个比较重要的点就是悬挂系统，分为一系悬挂（轴箱和轮对之间）和二系悬挂（摇枕或车体与构架之间）。要命的是，我买的两本教材其中一本把一二系悬挂的定义写反了，我还先看的写错的这一本，导致我现在依旧分不清一二系悬挂，每次提到都要翻书看一眼。随着技术发展，更多的转向架也慢慢出现，在转向、减震缓冲等方面的性能有着很大的提升，像摆式列车这样的转向架也更为复杂，那就是另一回事了。<br>怎么样，听迷糊了没，如果没有咱就继续。刚才提到汽车转弯的过程。转弯势必会带来一个问题，那就是两个轮子如果保证角速度相同，则线速度也应该相同，但转弯时相同时间内外侧轮子滚过的距离显然是比内侧轮子长的，这个差不可以忽视。我们知道汽车是通过差速器解决的这个矛盾，那么火车也没有差速器或者类似差速器的装置呢？没有。道理很简单，第一，轮对两侧的轮子是同轴的，能保证绝对的角速度相同，不存在差速的条件；第二，从操作的角度讲，我个人认为差速器是一个主动作动部件，你给方向盘一个转动信号差速器才会发挥作用，而你给出转向信号是因为你希望人为地使车辆转弯。但火车不是这样，火车的导向是靠轨道对轮缘的限制实现的。如果问我轮缘是什么，这里放一张图大家自己看吧，我懒得讲。看的时候顺便也了解一下踏面是什么。<br><img src="/old_images/2020/07/2822560807.jpg" alt="TIM图片20200716235932.jpg"><br>好了，我们来讲火车转弯时发生了什么。可能大家高中学物理的时候做过这样类型的题，说火车转弯，转弯半径给你了，车辆质量给你了，速度给你了，轨道面倾角也给你了，让你求对内侧轨道的压力。当时做这题我就觉得这是纯扯，你把火车当质点系？闹呢？不过话说回来，这个模型其实很大程度上真实还原了火车过弯时候的情况。如果大家有兴趣，可以下次坐高铁动车的时候体验一下，看看过弯的时候火车是不是倾斜的（普速列车也存在这个现象，但设计速度越快的线路越明显，所以动车是最优解）。这其实是为了保护铁轨和车轮，在转弯时人为将外侧铁轨垫高，使重力的一个分量先行充当向心力（效果力），尽量不让轮缘和轨道之间发生摩擦。实际上，新建的铁路大多是无砟铁路（有砟铁路就是底下是石头子儿的铁路），对于这个垫高的高度会有很精确的控制，但既有线等有砟铁路还依赖人工修正，工人师傅会定期到转弯处，测量垫高是否符合技术手册的标准，如果不够，就用工具往外侧铁路地下推石子儿，强行垫高。很有趣其实。<br>扯远了，说回到转弯过程。这里各位应该就明白上文中我提到的并不是竖直方向而是垂直于道面了吧。到这里，还是没解决差速的问题，火车的解决思路就很巧妙，真的。如果你们仔细看上面那个图，你会发现其实踏面不是柱面，而是<strong>锥型面</strong>（不知道柱面和锥型面的小伙伴自己去补高数和线代去），越靠近轮缘半径越大。这就好办了。当火车进入弯道，铁轨开始倾斜，于是车厢向一侧倾斜，重力分量充当向心力带着车厢开始画圆。由于离心效果，车辆整体会有向外侧移动的趋势，也就是车辆本身会往外侧（垫高一侧）甩，就像你家的洗衣机或者你那热爱蹦迪的男朋友/女朋友一样。甩完之后的结果是，车辆的中轴线和轨道的中心线不再在竖直面内平行，而是错开一定的距离，此时接触轨道的踏面也会向外移，那么<strong>实际接触到外侧轨道的踏面滚转半径就要比内侧大了。</strong>在严格的角速度相等的时候，两侧的线速度就会不相等，外侧比内侧大，也就不存在差速的问题了。多巧妙，是不是，这就是轨道交通的魅力。<br>本来想继续讲讲轨道和道岔的，内容都想好了，忽然有些感慨想说点别的，那这部分内容就留到下一篇吧。有人说能让一群男人为止奋斗的从来不是金钱而实梦想，我觉得同济轨交就是我的梦想。我在哈工大电气，也不错，但我能学到的终究还是电气的东西，即便是与轨道交通有关，也仅仅是“有关”罢了。要想真正走入这个行业，还是要跟着专业的人学专业的东西，坐专业的事情。中国铁路，无论是国铁还是地方铁路、城市轨道交通，其实一直在风口浪尖上。有人说中国的高铁技术都是国外引进的，中国技术不行，有人说中国修铁路太浪费钱。实际上真的是这样吗？我还没有走入这个行业里。我的前脚已经搭在门槛上了，等我进去看看便知分晓。但我想说，任何一种技术都是从无到有从零到一的，十几年前我们没有技术的时候引进了国外的技术，也是花了大价钱的，后来我们慢慢在发展，到今天我们有了自己标准的动车组，我们开始向国外出口中国生产的轨道交通车辆，作为一名向往轨道交通的人，我是很自豪的。我们的第一艘航母也是买的前苏联的，后面经过我们的研究还是造出了自己的航母。一样的，我们的C919是以A320为模板的，阿娇（ARJ21）也是从模仿开始一步一步提升的。中国的技术现在行不行，我们去看看中车的海外订单就知道了。那天我看了一个纪录片，超级工程第一季，其中一集讲到了北京地铁网络的建设，有一个片段让我热泪盈眶，我截了下来，放在这里。<br><img src="/old_images/2020/07/1405371260.gif" alt="TIM图片20200717000541.gif"><br><img src="/old_images/2020/07/3520035333.gif" alt="TIM图片20200717000707.gif"><br>写这篇文章的时候，脑海里多次会想起这个画面，每当我看到这个动图我都忍不住落泪。可能这就是热爱，可能这就是我热爱一项事业的方式。我希望自己能够进入到这个行业中去真正做一些事情。我们没有西门子那样将近两百年的发展历程，我们真的要做很多努力去超越和创新。对于轨道交通，我很自豪地讲我是有自己的想法的，也希望有朝一日我也能够再次热泪盈眶地说一句：<br>“为了搞我们国家自己的轨道交通事业，我们那代轨交人，可以说是付出了辛苦的，很自豪。”<br>谢谢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，我是那个喜欢火车的Captain。&lt;br&gt;有人说，一个男人不成熟的标志是可以为了一项事业英勇地死去，而一个男人成熟的标志是可以为了一项事业卑贱地活着。我可能是成熟了。在上个周末，从7月10号到13号的四天时间里，我经历了两场专业课考试，一个夏令营，外加一篇恶心的硕士</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>新人报到！虚拟样机在机器人领域的应用（入门篇）</title>
    <link href="http://example.com/2020/07/13/%E6%96%B0%E4%BA%BA%E6%8A%A5%E5%88%B0%EF%BC%81%E8%99%9A%E6%8B%9F%E6%A0%B7%E6%9C%BA%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2020/07/13/%E6%96%B0%E4%BA%BA%E6%8A%A5%E5%88%B0%EF%BC%81%E8%99%9A%E6%8B%9F%E6%A0%B7%E6%9C%BA%E5%9C%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/</id>
    <published>2020-07-13T05:33:00.000Z</published>
    <updated>2020-12-13T08:45:40.977Z</updated>
    
    <content type="html"><![CDATA[<p>Hello！大家好呀，我是你们的新朋友，也是宇哥的搭档。先自我介绍一下子哈，我的名字是冯宸，跟栋宇一样是哈工大竞技机器人队的现役队员，大家可以叫我Albert，主要是从事机械方向的工作，当然嵌入式和视觉方面也有（cai）所（de）涉（yi）猎（pi）。前几天偶然发现了栋宇的Blog，就想着抛砖引玉写一篇科普小文章，奈何才疏学浅再加上这几天事情比较多，就搁置了下来，不过今天刚好有时间，就尝试把自己之前弄的一些基础的小东西来支持一下我宇哥。好啦！废话不多说上才艺！</p><ol><li>虚拟样机技术简介<br>虚拟样机技术一般在大型复杂系统的产品设计中应用，虚拟样机技术 (Virtual Prototyping Technology)是指在产品开发设计过程中，将分散的零部件设计和分析技术融合在一起,在计算机上建造出整体模型,并针对该产品在投入使用后的各种工况进行仿真分析，预测产品的整体性能，通过仿真结果指导改进设计、提高产品性能。<br>一般流程是在仿真软件中搭建一个动力学模型来模拟系统工作时的工作状态,通过数据输出(位移、速度、加速度)或者仿真动画输出来观察和分析系统的可靠性，分析结果用来指导物理样机 的版本迭代。<br>在RoboMaster 比赛中,如果能搭建正确的战车一些核心模块的虚拟样机,在方案试验阶段能节省很大一部分的人力成本资金成本和时间成本.并且能在分析问题时有一定说服力的依据而不是只停留在经验层面上,解决问题一针见血。</li><li>常用虚拟样机软件<br>自然界广泛存在四种物理场：温度场、电磁场、结构(位移、应力、应变)场、流场 。<br>不同的工程所分析的物理场不一样,不同的物理场所应用的公式理论和仿真软件也不一样.本文主要针对robomaster 比赛中机械仿真案例进行阐述.目前来看主要是运用结构场和流场 进行建模分析.其中涉及到多体动力学分析和静力学分析以及流体力学分析。一般涉及到软件Solidworks、Adams、Ansys workbench、Fluent… 等。<br>Solidworks 主要进行三维建模设计也可进行关键零件的静力学分析(Simulition静力学模块)和动力学模型搭建(motion模块)。<br>Adams 是多体动力学仿真计算中最常用的软件,也是本文的中点阐述对象.可以进行动力学模型搭建(View模块)仿真求解(Solver模块)以及数据处理模块(Postprocessor模块)<br>Ansys 是有限元仿真中常用软件，可以进行静力学分析(Static Structural模块)也可以进行碰撞分析(LS-dyna模块)还有流场分析(Fluid Flow模块)，Workbench集成了很多有限元模块，可以共享各自的结果数据使Ansys的功能异常强大。<br>结构场是最主要的分析场.本文是在结构场中以步兵拨弹模块 为例进行展开系统的虚拟样机搭建过程.研究Adams虚拟样机中17mm子弹在弹仓中的运动状态和拨轮受力情况，指导拨弹模块的改进，进而提高射频满足比赛要求。</li><li>搭建虚拟样机的动力学模型<br>简单的机械系统可以搭建数学模型进行动力学分析,但是像拨弹这中多自由度的复杂系统很难或者无法直接搭建整个拨弹过程的数学模型,只能通过多体动力学软件搭间接搭建数学模型进行迭代计算和过程动画模拟来分析问题。<br>虚拟样机其实包括建模、仿真、后处理.建模即创建样机添加工况,仿真即是求解方程,由计算机幕后完成,后处理主要是查看动画以及输出一些感兴趣的物理量,复杂的由专业后处理模块Adams/PostProcessor进行。<br>在Solidworks中的motion模块和Adams View中均可搭建动力学模型。Solidworks中操作比较简单，对于大多数同学来讲上手比较快。可以把模型在SW中搭建好之后导入到Adams进行求解计算，这样可以在短时间内完成一个简单系统的仿真工作，不过如果需要更精确的求解计算建议还是使用Adams搭建模型比较好，求解更精确。</li></ol><p>4.在Solidworks中简化模型导入Adams计算和后处理<br>（1）在solidworks中简化拨弹模块，压缩不影响本次研究问题的无关零件(发射模块、弹舱盖、其他保护壳等)。并添加上子弹,子弹是阵列生成,需要右键解散阵列 .所有零件应赋材料(子弹材料TPE,用PA代替)如图4-1到图4-2的简化。<br><img src="/old_images/2020/07/1225674126.png" alt="1.PNG"></p><p>图4-1简化前    图4-2简化后<br>（2）打开【motion】插件,进入motion模块(如没有在→插件中勾选motion),在左下角将页面切换至【运动算例1】 ,将下拉菜单【动画】切换到【motion分析】 ,依次添加各个实体间的接触力contact(球与球之间、球与拨轮之间、球与弹舱之间),检查弹舱为固定状态,最后设置重力 .到此为止,模型搭建完毕,驱动马达可以不添加,放在Adams 中操作.图4-3是各按钮位置。<br><img src="/old_images/2020/07/51341367.png" alt="2.PNG"></p><p>图4-3 motion模块的操作界面<br>在动力学模型中每个实体之间的接触是靠添加两个物体间的接触力实现的,在Adams和Solidworks中每个接触均有8个参数(图4-7中标出),四个碰撞参数:Stiffness(刚度系数)、Force Exponent(刚度指数)、Damping(阻尼系数)、Penetration Depth(最大穿透值),四个库仑摩擦参数:Static Coefficient(静摩擦系数)、Dynamic Coefficient(动摩擦系数)、Stiction Transition Vel(静摩擦过渡速度)、Friction Transition Vel(动摩擦过渡速度), 表3-1给出大致参数确定方法，也可参考附件data文件夹下《ADAMS中接触的定义及参数设置》.图4-4和图4-5方便理解各个参数的意义。<br><img src="/old_images/2020/07/1260733011.png" alt="3.PNG"></p><p>表3-1 Impact接触参数与Coulomb摩擦参数</p><p><img src="/old_images/2020/07/4243678235.png" alt="4.PNG"></p><p>图4-4 Impact接触参数参考图    图4-5 Coulomb摩擦参数参考图</p><p><img src="/old_images/2020/07/3134056928.png" alt="5.PNG">    </p><p>图4-6 各球之间接触    图4-7各球之间的接触参数设置<br>图4-6为添加球和球接触中实体选择操作,可以看出不勾选接触组时,添加的是所选择各实体间的接触,17颗球之间一共有136个接触.图4-7为球和球之间的接触参数设置(推荐)。</p><p><img src="/old_images/2020/07/3001651570.png" alt="6.PNG"></p><p>图4-8球和各个弹舱零件的接触    图4-9 球与弹舱之间的接触参数设置<br>图4-8使用【接触组】添加接触,球和拨轮以及球和弹舱的接触需要使用接触组,即球为一组与另外三个零件分别添加接触,各球之间接触不会被重复添加,在图中看出17个子弹与四个零件间分别添加接触,共68个接触. 图4-9为球和弹舱之间的接触参数设置(推荐)。<br>另外拨轮和球之间的接触同样使用接触组,系数设置中将图4-9中【Stiffness】(刚度)系数改为400即可。<br>使用Solidworks 方便交互式批量添加各实体间的接触力,Adams 中接触力的添加比较难操作.多个实体之间只有用脚本命令进行添加比较方便。<br>最后添加上重力。<br>（3）导入到Adams中,检查模型,稍作修改,一些复杂的约束用简单约束来替换,在Solidworks 中的互相固连的零件可以进行两种操作①两个零件用Fixed约束锁死②使用Boolean运算进行零件合并,给拨轮添加Revolute铰接约束,在铰接约束上添加motion驱动.打开求解器进行运算即可。</p><p><img src="/old_images/2020/07/2541934723.png" alt="7.PNG"></p><p>图4-10计算按钮    图4-11 Solidworks与Adams的接口<br>把模型按照第一第二步搭建完之后,点击【计算】按钮(图4-10),计算结果一般都会报错可以忽略,Solidworks中的求解器计算很容易失败,所以只用motion做模型搭建这种前处理工作.右键模型名称输出Adams(图4-11),输出英文命名的.adm文件和一些.xmt_bin以及.res文件均保存在英文路径下.附件中例程保存在 adams_file\project\model\adams_1中。</p><p><img src="/old_images/2020/07/723480778.png" alt="8.PNG"></p><p>图4-12导入.adm文件    图4-13 MKS单位制设置<br>打开Adams导入.adm文件,新建模型“loader_1”,设置单位制。</p><p><img src="/old_images/2020/07/962343059.png" alt="9.PNG"></p><p>图4-14 Connectors约束    图4-15 添加Fixed约束</p><p><img src="/old_images/2020/07/2140554824.png" alt="10.PNG"></p><p>图4-15 Fixed(固定)和Revolute(旋转)约束<br>在Adams中删除【Connectors】中所有约束,将几个固定零件间添加Fixed约束(固定锁死)。</p><p><img src="/old_images/2020/07/4097717059.png" alt="11.PNG"></p><p>图4-16 右键→Appearance    图4-17 Appearance→Color<br>更改拨轮颜色为Red,方便观察和操作,如图4-16和图4-17.也可以根据需要更改其他零件颜色.图4-17中【Visibility】点选off即可隐藏该零件,该操作同样适用于其他类型信息,如Connectors、Motion、Force等。</p><p><img src="/old_images/2020/07/551017501.png" alt="12.PNG"></p><p>图4-18添加Revolute(旋转)约束    图4-19 Revolute(旋转)约束结果<br>在拨轮和弹舱中间添加旋转副,操作如图4-18结果如图4-19。</p><p><img src="/old_images/2020/07/3819593002.png" alt="13.PNG"></p><p>图4-20 Rotational Joint motion(旋转驱动)</p><p><img src="/old_images/2020/07/3351283967.png" alt="14.PNG">    </p><p>图4-20 motion结果    图4-21 motion参数<br>    将旋转驱动添加到拨轮的旋转副上。<br>在joint_4上添加motion_1,参数设置如图4-21。<br>17mm子弹材料为TPE,密度970 kg/m³弹性模量3.4GPa,泊松比0.32(近似)。</p><p><img src="/old_images/2020/07/1559317015.png" alt="15.PNG"></p><p>图4-22 新建材料    图4-23 TPE材料参数<br>【body】树下右键其中一个球单击【Modify】, 出现对话框如图4-22在【Define Mass By】下拉菜单选择【Geometry and Material Type】,在【Material Type】中右键出现图中对话框,依次选取【Material】→【Create】会跳出对话框如图4-23，按照TPE参数设置单击【Apply】→【ok】,然后单击图4-22中【Apply】即发现图中材料参数刷新至新建TPE材料.依次添加剩余球的材料和弹仓材料(【Material】→【Guesses】→【aluminum】)。模型搭建完毕,进入simulation进行求解计算。</p><p><img src="/old_images/2020/07/3888322204.png" alt="16.PNG"></p><p>图4-24仿真参数设置<br>如图4-24仿真正在进行中,左上角为仿真计算过的模型时间,右下角为仿真进程百分比,在Simulation Control对话框中【End Time】为仿真总时长,【Step Size】为仿真步长根据模型复杂程度给定,合理的步长节省仿真时间、提高仿真精度.如果计算报错则检查模型有无物理干涉和严重死点,调整仿真时间继续进行仿真计算,多次仿真计算应勾选【Reset before running】保证每次仿真计算前参数重置.仿真时间由模型复杂度和电脑CPU以及内存而定,如果模型复杂则仿真时间会十几个小时甚至几天，电脑配置稍好些会加快运算效率.另外合理的模型化简和模型搭建也能影响仿真时间。<br>关于充分利用电脑性能加快仿真速度,可以开从多线程运算和增大可调用内存两个方面入手。<br>多线程运算途径&gt;在Adams/View界面下通过“settings&gt;solver&gt;Executable”菜单打开设置窗口，并勾选More选项，在Thread Count位置输入参与计算的线程数(128).如图4-25。</p><p><img src="/old_images/2020/07/2310258600.png" alt="17.PNG"></p><p>图4-25<br>增大调用内存途径&gt;开始–程序–MSC.software–MSC.ADAMS–ADAMS settings分别打开Aview和Asolver中的Preference，在右侧memsize一栏中选择huge点击ok保存。重新运行ADAMS即可.如图4-26。</p><p><img src="/old_images/2020/07/291067937.png" alt="18.PNG"></p><p>图4-26<br>（4）进入后处理模块Postprocessor,观察动画可以看到子弹在拨轮中的运状态,进行子弹轨迹追踪和一些感兴趣物理量的测量.比如输出电机的驱动扭矩值,进行电机选型.通过仿真动画和数据指导版本迭代改进。<br>5.Solidworks提供三维模型,Adams中进行模型搭建和计算及后处理<br>（1）Solidworks简化模型,操作过程和流程和4.1中相同,最后将装配体另存成Parasolid(*.x_t)格式如图5-1,导入Adams做前处理.注意:Adams不支中文路径和中文文件名。</p><p><img src="/old_images/2020/07/755844939.png" alt="19.PNG"></p><p>图5-1导出x_t<br>打开Adams View,新建模型导入.x_t文件.单击【New Model】输入自定义模型名称(英文),单击【ok】会新建一个空白模型,【主菜单】&gt;【File】&gt;【import】下拉菜单第一个【File Type】中选择Parasolid,在【File To Read】中右键&gt;【Browse】浏览到目标.x_t文件,在【Model Name】右键选择新建的模型名称.单击【Ok】.模型导入完成.如图5-2。</p><p><img src="/old_images/2020/07/270229372.png" alt="20.PNG"></p><p>图5-2 .x_t导入Adams<br>（2）在Adams里面搭建动力学模型.在此之前应掌握Adams图形界面基本操作和工具栏的分布.模型需要用cmd脚本搭建,准确高效,所以要求能读懂简单的编程语言.本章节均用一些简单的命令语言来实现建模操作.这里的脚本编辑器使用的是VScode,桌面新建.txt英文命名后缀改为.cmd,用VScode打开编辑后保存即可。<br>【主菜单】&gt;【View】&gt;【Command Window】打开命令窗口,每一步界面操作的命令都会在命令窗口中滚动.可以复制出来修改后使用。<br>Cmd脚本对拨弹部分建模流程如下①修改Bodies Name②布尔运算操作③定义材料④添加约束⑤添加驱动⑥定义接触力(部分步骤的先后顺序可调)。<br>①基本设置<br>设置单位制(MKS)和重力方向(-Z)。<br>!————-setting———————-!<br>default units length=mm mass=kg force=newton &amp;<br> time=Second angle=degrees frequency=hz!units_MKS!</p><p>int dia disp dia=gravity_panel!打开对话框重力设置对话框!<br>force modify body gravitational gravity = ACCGRAV_1 &amp;<br>      x_comp = 0 &amp;<br>      y_comp = 0 &amp;<br>      z_comp = -9806.65!-Z轴gravity!<br>!—————–end————————!<br>②修改Bodies Name<br>在模型树中【Bodies】下可以查看各个实体.如果在Solidworks中是中文命名,导入后会重新命名,但是命名均有规律.现需要修改实体名字,方便查看和操作。<br>图形界面操作按钮如图5-3,【模型树】&gt;【Bodies】&gt;【任意一组件右键】。</p><p><img src="/old_images/2020/07/3548240241.png" alt="21.PNG"></p><p>图5-3 Rename按钮</p><pre><code>图形界面操作按钮如图5-3,【模型树】&gt;【Bodies】&gt;【任意一组件右键】，根据模型树中的信息,编写modify_name命令如下,</code></pre><p>!————-modify_part_name—————!<br>entity modify entity =____002    new = wheel_loader<br>entity modify entity =<strong>__       new = magazin_1<br>entity modify entity =_______2   new = sheet<br>entity modify entity =____</strong>     new = magazin_2</p><p>entity modify entity =<em>17mm____  new = <em>17mm_____1<br>for variable_name=ip  start_value=1  end_value=17 !for循环批量修改球的name,ip为变量名!<br>entity modify entity =(eval(“<em>17mm__</em></em></em>“//rtoi(ip))) new =(eval(“ball_”//rtoi(ip)))<br>end</p><p>entity modify entity =<strong>____</strong>   new = _________1<br>for variable_name=ip  start_value=1  end_value=2<br>entity modify entity =(eval(“_________”//rtoi(ip))) new = (eval(“pipe_”//rtoi(ip)))<br>end<br>!——————-end———————-!<br>根据模型树中的信息,编写modify_name命令如下,通过【主菜单】&gt;【File】&gt;【import】导入.cmd实现对模型的操作如图5-4，</p><p><img src="/old_images/2020/07/2308466294.png" alt="22.PNG"></p><p>图5-4 .cmd导入Adams<br>操作前后的对比如图5-5和图5-6</p><p><img src="/old_images/2020/07/3991564688.png" alt="23.PNG"></p><p>图5-5 Bodies Name修改前    图5-6 Bodies Name修改后<br>③布尔运算操作<br>在三维模型为DFM(面向制造的设计),不影响功能情况下,使用布尔运算将多个零件合成一个。<br>图形界面操作按钮如图5-7,【功能区】&gt;【Bodies】&gt;【Booleans】。</p><p><img src="/old_images/2020/07/162826487.png" alt="24.PNG"></p><p>图5-7 Booleans操作按钮<br>根据模型,编写Booleans命令操作如下,<br>!————-Booleans_parts—————–!<br>part merge rigid_body part_name=pipe_2 into_part=pipe_1!将pipe_2合并到pipe_1!<br>!——————-end———————-!<br>操作前和操作后的区别如图5-8和图5-9</p><p><img src="/old_images/2020/07/995794732.png" alt="25.PNG"></p><p>图5-8 布尔合并前</p><p><img src="/old_images/2020/07/1501298663.png" alt="26.PNG"></p><p>图5-9 布尔合并后<br>④定义材料<br>图形界面操作按钮,【模型树】&gt;【Bodies】&gt;【任意一个构件右键】&gt;【Modify】接下来的操作设置如图5-10和图5-11</p><p><img src="/old_images/2020/07/3087868713.png" alt="27.PNG"></p><p>图5-10 新建材料    图5-11TPE材料参数<br>材料参数:①密度(Density)②弹性模量(Youngs Modulus)③泊松比(Poissons Ratio)<br>根据模型,编写Material命令操作如下,<br>!————-modify_material—————–!<br>material create  &amp;                !新建材料TPE!<br>      material_name = .materials.TPE  &amp;<br>      density = 0.97e-6 &amp;<br>      youngs_modulus = 3400  &amp;<br>      poissons_ratio = 0.32<br>for variable_name=ip start_value=1 end_value=17!for循环批量修改!<br> part modify rigid mass_properties  &amp;<br>      part_name = (eval(“ball_”//rtoi(ip)))  &amp;<br>      material_type = .materials.TPE<br>end</p><p>part modify rigid mass_properties  &amp;<br>      part_name = pipe_1  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = magazin_1  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = sheet  &amp;<br>      material_type = .materials.aluminum<br>part modify rigid mass_properties  &amp;<br>      part_name = wheel_loader  &amp;<br>      material_type = .materials.aluminum<br>!——————-end———————-!<br>修改前后对比如图5-12和图5-13</p><p><img src="/old_images/2020/07/2048957230.png" alt="28.PNG"></p><p>图5-12 新建材料    图5-13 TPE材料参数<br>⑤添加约束<br>在此模型中每个子弹都有6个自由度,不存在约束,剩余零部件都有自己的固定方式.如图5-14中,wheel_loader和ground有个旋转约束,其余零件和ground都是固定约束。</p><p><img src="/old_images/2020/07/1700994165.png" alt="29.PNG"></p><p>图5-14 模型树中需要约束的零部件<br>图形界面操作按钮如图5-15</p><p><img src="/old_images/2020/07/2612196784.png" alt="30.PNG"></p><p>图5-15 Fixed(固定)和Revolute(旋转)约束<br>·固定约束(Fixed Joint)<br>根据模型,编写Fixed_joint命令操作如下,<br>!—————Fixed_Joint——————!<br>marker create marker=.ground.MAR_fixed_1 &amp; !在ground上创建marker点命MAR_fixed_1!<br>location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置重合!<br>orientation=0.0,0.0,0.0                          !MAR_fixed_1和ground.cm坐标重合!<br>marker create marker=.sheet.MAR_fixed_1 &amp;!在ground上创建marker点命名MAR_fixed_1!<br>  location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;!MAR_fixed_1和ground.cm位置合!<br>  orientation=0.0, 0.0, 0.0                       !MAR_fixed_1和点ground.cm坐标重合!<br>constraint create joint Fixed &amp;           !在上述创建的两个marker间创建一个固定约束!<br>    joint_name=fixed_1 &amp;                   !Fixed约束的名称!<br>    i_marker_name=.sheet.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1</p><p>marker create marker=.ground.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>marker create marker=.magazin_1.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0, 0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>constraint create joint Fixed &amp;                     !创建固定约束!<br>    joint_name=fixed_2 &amp;<br>    i_marker_name=.magazin_1.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1</p><p>marker create marker=.ground.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>marker create marker=.pipe_1.MAR_fixed_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},ground.cm)) &amp;<br>    orientation=0.0, 0.0, 0.0<br>constraint create joint Fixed &amp;                     !创建固定约束!<br>    joint_name=fixed_3 &amp;<br>    i_marker_name=.pipe_1.MAR_fixed_1 &amp;<br>    j_marker_name=.ground.MAR_fixed_1<br>!——————-end———————-!<br>创建Fixed后如图5-16</p><p><img src="/old_images/2020/07/2817136246.png" alt="31.PNG"></p><p>图5-16 固定约束的结果图<br>·旋转约束(Revolute Joint)<br>需要在拨盘(wheel_loader)和ground之间添加旋转约束，根据模型,编写Revolute_joint命令操作如下,<br>variable create variable_name=wheel_name string_value=”wheel_loader” !定义变量”wheel_name”,string_value代表字符串类型!<br>marker create marker=.ground.run_MAR_1 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp;!<br>    orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))<br>marker create marker=.wheel_loader.run_MAR_2 &amp;<br>    location=(LOC_RELATIVE_TO({0,0,0},(eval(wheel_name//“.cm”)))) &amp;<br>    orientation=(ORI_RELATIVE_TO({90,90,0},(eval(wheel_name//“.cm”))))<br>constraint create joint Revolute &amp;              !创建Joint_Revolute!<br>    joint_name=run_1 &amp;            !约束名称!<br>    i_marker_name=.ground.run_MAR_1 &amp;<br>    j_marker_name=.wheel_loader.run_MAR_2<br>variable delete variable_name=wheel_name                    !删除变量!<br>Adams中建模命令均是对是通过对Marker点的操作来完成的,拿创建旋转副举例(固定约束同理),分为三步：<br>i.创建一个坐标点run_MAR_1,该点在ground上,与wheel_loader.cm重合。<br>ii.创建另外一个坐标点run_MAR_2,该点在wheel_loader上,依旧与wheel_loader.cm重合。<br>iii.创建一个转动副,转动副名字为.loader_2.run_1,他是由于两个坐标点发生相对转动构成的,这两个坐标点分是上述两步创建的坐标。<br>此外上述脚本开头定义了一个字符串变量wheel_name,在创建Joint中使用,结尾删除.使用变量可以方便代码移植。<br>⑥添加驱动<br>Adams中驱动一般添加在旋转副或者移动副上,拨弹模块只需添加拨盘旋转，图形界面操作按钮如图5-17</p><p><img src="/old_images/2020/07/3860621436.png" alt="32.PNG"></p><p>图5-17 Rotational Joint motion(旋转驱动)<br>根据模型,编写Joint Motion命令操作如下，<br>!————-Revolute_Joint—————-!<br>variable creat variable_name=MC_run_1 string_value=”step(time,0.1,0,0.3,-360d)”!电机转速!<br>constraint create motion motion_name=.loader_2.motion_1 &amp;<br>           joint=.loader_2.run_1 &amp;                 !motion添加在run_1上!<br>           type=rotational &amp;                       !类型是转动!<br>           time_derivative=velocity &amp;              !驱动类型为velocity(速度)!<br>           function=(eval(MC_run_1))               !调用定义的变量MC_run_1!<br>!——————-end———————-!<br>使用step函数定义驱动,step函数：<br>STEP（time，1，0d，2，20d）+STEP（time，6，0d，12，-40）<br>意义：1秒到2秒：从0递增至20d；<br>2秒到6秒：保持电机输出数值为20d不变；<br>6秒到12秒：由20d递减40d，结果为-20d<br>旋转约束和驱动添加之后的结果如图5-18</p><p><img src="/old_images/2020/07/3240034142.png" alt="33.PNG"></p><p>图5-18添加旋转约束和驱动<br>⑦定义接触力<br>在Adams中所有的碰撞接触的均应添加接触力。<br>该模型中接触力的添加操作要稍微复杂,每个球都有6个自由度,所以每两个球之间都要有添加接触力,第四节中已经说明球之间需要添加136个接触力,需要使用命令批量添加，准确高效。<br>图形界面操作按钮如图5-19【功能区】&gt;【Forces】&gt;【Special Forces】&gt;【Create a contact】。</p><p><img src="/old_images/2020/07/2422714402.png" alt="34.PNG"></p><p>图5-19 添加实体间接触力按钮<br>根据模型,编写Create contact命令操作如下<br>!————create_contact_between_solids————–!<br>variable create variable_name=MODEL_name string_value=”loader_2”!模型名称!<br>variable create variable_name=part_box string_value=”CSG_4”!被接触对象!</p><p>variable create variable_name=add_1 integer_value=6!子弹Body名称和SOLID名称的序号差!</p><p>variable create variable_name=MC_stiffness  real_value=164 !刚度系数,计算公式参考stiffness.m!<br>variable create variable_name=MC_damping    real_value=0.5 !阻尼系数!<br>variable create variable_name=MC_exponent   real_value=2 !指数!<br>variable create variable_name=MC_dmax       real_value=0.00005!最大实体入侵!</p><p>variable create variable_name=MC_mu_static  real_value=0.7 !静摩擦系数!<br>variable create variable_name=MC_mu_dynamic real_value=0.65!动摩擦系数!<br>variable create variable_name=MC_sti_tra_vel real_value=0.1!静摩擦过渡速度!<br>variable create variable_name=MC_fri_tra_vel real_value=10 !动摩擦过渡速度!</p><p>!—————sheet————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID2                           !修改part_box为sheet的Solid!<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————magazin_1————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID1<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.3<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>variable modify variable_name=part_box &amp;<br>      string=SOLID3<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————pipe_1————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID4<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“<em>“//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>variable modify variable_name=part_box &amp;<br>      string=SOLID5<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con_”//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————wheel_loader————-!<br> variable modify variable_name=part_box &amp;<br>      string=SOLID6<br>variable modify variable_name=MC_stiffness  real_value=4.4e8<br>variable modify variable_name=MC_damping    real_value=5e4<br>variable modify variable_name=MC_exponent   real_value=1.5<br>variable modify variable_name=MC_dmax       real_value=0.01<br>for variable_name=ipp  start_value=1  end_value=17<br>contact create &amp;<br>  contact_name = .(eval(MODEL_name)).(eval(“con</em>“//rtoi(ipp+add_1)//“_”//(eval(part_box)))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(ipp+add_1))) &amp;<br>      j_geometry_name = (eval(part_box))  &amp;<br>      stiffness = (eval(MC_stiffness))    &amp;<br>      damping =(eval(MC_damping))         &amp;<br>      exponent =(eval(MC_exponent))       &amp;<br>      dmax =(eval(MC_dmax))               &amp;<br>      coulomb_friction = on               &amp;<br>      mu_static =(eval(MC_mu_static))          &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic))         &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>end<br>!—————contact_between_balls——————-!<br>variable modify variable_name=MC_stiffness  real_value=1.64e8<br>variable modify variable_name=MC_damping    real_value=2e4<br>variable modify variable_name=MC_exponent   real_value=2<br>variable modify variable_name=MC_dmax       real_value=0.1<br>variable modify variable_name=MC_mu_static  real_value=0.35 !静摩擦系数!<br>variable modify variable_name=MC_mu_dynamic real_value=0.3!动摩擦系数!<br>!—————————————!<br>variable create variable_name=ipp   integer_value=1<br>variable create variable_name=a      integer_value=1!第一颗子弹的序号!<br>variable create variable_name=b      integer_value=17!最后一颗子弹的序号!<br>variable create variable_name=add_2  integer_value=1</p><p>for variable_name=num_1 start_value=(eval(a)) end_value=(eval(b-1))!两个for循环,依次添加子弹之间的各约束!</p><p>for variable_name=num_2 start_value=(eval(a))  end_value=(eval(b-ipp))<br>contact create &amp;<br>  contact_name =.(eval(MODEL_name)).(eval(“con_”//rtoi(num_1)//“_”//rtoi(num_1+add_2))) &amp;<br>      i_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1))) &amp;<br>      j_geometry_name = (eval(“SOLID”//rtoi(num_1+add_1+add_2)))  &amp;<br>      stiffness = (eval(MC_stiffness)) &amp;<br>      damping =(eval(MC_damping)) &amp;<br>      exponent =(eval(MC_exponent))&amp;<br>      dmax =(eval(MC_dmax))  &amp;<br>      coulomb_friction = on  &amp;<br>      mu_static =(eval(MC_mu_static)) &amp;<br>      mu_dynamic =(eval(MC_mu_dynamic)) &amp;<br>      stiction_transition_velocity =(MC_sti_tra_vel) &amp;<br>      friction_transition_velocity =(MC_fri_tra_vel)<br>variable modify variable_name=add_2  integer_value=(eval(add_2+1))<br>end<br>variable modify variable_name=ipp integer_value=(eval(ipp+1))<br>variable modify variable_name=add_2 integer_value=1<br>end</p><p>variable delete variable_name=ipp<br>variable delete variable_name=a<br>variable delete variable_name=b</p><p>variable delete variable_name=MODEL_name<br>variable delete variable_name=part_box</p><p>variable delete variable_name=add_1<br>variable delete variable_name=add_2<br>!———————–end——————————!</p><p>到此为止动力学模型已经搭建完毕,其中一些参数设置一般指接触力参数和仿真步长参数,尤其使接触力参数中的刚度系数和阻尼系数需要查询资料来确定,作者在这一块也没有太明确的方法,文献中显示stiffness标准值是在1.0<em>e+7~1.0</em>e+9(N/m)之间，阻尼系数一般取stiffness的0.01%。<br>材料参数如表5-1</p><p><img src="/old_images/2020/07/81368647.png" alt="35.PNG"></p><p>表5-1</p><p>⑧设置仿真时长和步长开始仿真<br>本模型中有17个子弹,200个接触,如果40个子弹,各部分接触达到1000个.仿真时长取决于具体物理场景，仿真步长取决于模型复杂度，步长越小，计算结果越容易收敛，模型越精确，步长过大结果发散后就会报错。但是步长过小计算就变慢，合适的步长有利于模型仿真计算。<br>本案例中步长给0.0005~0.001比较合适，时长给2s既可以说明问题如图。</p><p><img src="/old_images/2020/07/249903794.png" alt="36.PNG"></p><p>图5-21仿真细节参数<br>⑨查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。<br>⑩一般的搭建过程如图,徐要验证和迭代框图5-21。</p><p><img src="/old_images/2020/07/489071846.png" alt="37.PNG"></p><pre><code>虚拟样机的需要按照上述的流程循环迭代,不能凭空搭建样机,要有实验数据做基础,有样机迭代使虚拟样机模型越来越精确,模型越精确越有利于实际工程的分析。当一个模型搭建正确之后,类似的机构搭建周期将会缩短。</code></pre><p>⑪查看仿真结果输出物理量曲线或者动画,细化模型参数,模型正确即可指导方案迭代。<br>（3）后处理模块将样机的虚拟数据输出成曲线或者生成直观的动画来查看。<br>后处理数据需要在模型中调用，采用measure命令即可调取其中的参数，本例中关心拨弹电机的扭矩是够用，故在【模型树】&gt;【motions】&gt;【右键motion_1】&gt;【measure】按照如图5-22设置&gt;【apply】。</p><p><img src="/old_images/2020/07/2066845163.png" alt="38.PNG"></p><p>图5-22 Measure按钮<br>输出的扭矩图如5-23</p><p><img src="/old_images/2020/07/1264423062.png" alt="39.PNG"></p><p>另外可以通【功能区】&gt;【Results】&gt;【Postprocessor】进入后处理模块【空白页右键】&gt;【Load Animation】进行动画输出如图5-33，红色框中是播放暂停好和录制按钮。</p><p><img src="/old_images/2020/07/3794064227.png" alt="40.PNG"></p><p>还有其他感兴趣的任意物理量均可输出，通过对数据和动画的分析寻找结构优化的突破点，事半功倍。<br>6.结论<br>所提到的Solidwoks搭建动力学模型导入Adams中进行计算,对于新手来讲比较容易上手,能在短时间内搭建出动力学模型,并且简单的机械系统的仿真计算结果是可信的.而一些复杂些的系统求解精度就很低,和实际情况不太相符.在做拨弹仿真中就出现实体实体间的互相侵入太多的情况,目前还没找到原因.故复杂模型建议使用以下叙述的模型搭建方法。<br>虚拟样机需要在建立后，根据物理样机修改才能得到更精确的仿真结果。<br>各种仿真软件都只是工具，建模的关键还在于正确的工况分析与合理的参数设置，这些都是在仿真过程中逐渐完成的。如何把建立正确的物理样机以及仿真后数据的分析与改进方向是需要人工分析完成的。<br>7.写在最后的预告<br>各位朋友们，如果大家觉得这部分比较有趣的话，下一次可以和大家分享机器人学的部分知识，先从运动学和动力学开始吧，比如D-H法，拉格朗日方程，牛顿-欧拉方程，以及这些数理知识是如何应用在机器人设计中的，有机会的话下次见啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello！大家好呀，我是你们的新朋友，也是宇哥的搭档。先自我介绍一下子哈，我的名字是冯宸，跟栋宇一样是哈工大竞技机器人队的现役队员，大家可以叫我Albert，主要是从事机械方向的工作，当然嵌入式和视觉方面也有（cai）所（de）涉（yi）猎（pi）。前几天偶然发现了栋宇的</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>LCD vs OLED</title>
    <link href="http://example.com/2020/07/11/LCD%20vs%20OLED/"/>
    <id>http://example.com/2020/07/11/LCD%20vs%20OLED/</id>
    <published>2020-07-11T06:41:00.000Z</published>
    <updated>2020-12-13T08:38:13.322Z</updated>
    
    <content type="html"><![CDATA[<p>转载以下知乎大佬们为我们带来的LCD与OLED大比拼：</p><p>链接：<a href="https://www.zhihu.com/question/22263252">OLED 和 LCD 有什么区别？</a></p><p>来源：知乎</p><p><img src="/old_images/2020/07/3074664648.jpg" alt="Snipaste_2020-07-11_22-41-15.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载以下知乎大佬们为我们带来的LCD与OLED大比拼：&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/22263252&quot;&gt;OLED 和 LCD 有什么区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>轨道交通领域的牛顿特斯拉之战和你坐地铁听到的“防空警报声”</title>
    <link href="http://example.com/2020/06/30/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E7%89%9B%E9%A1%BF%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E6%88%98%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%B0%E9%93%81%E5%90%AC%E5%88%B0%E7%9A%84%E2%80%9C%E9%98%B2%E7%A9%BA%E8%AD%A6%E6%8A%A5%E5%A3%B0%E2%80%9D/"/>
    <id>http://example.com/2020/06/30/%E8%BD%A8%E9%81%93%E4%BA%A4%E9%80%9A%E9%A2%86%E5%9F%9F%E7%9A%84%E7%89%9B%E9%A1%BF%E7%89%B9%E6%96%AF%E6%8B%89%E4%B9%8B%E6%88%98%E5%92%8C%E4%BD%A0%E5%9D%90%E5%9C%B0%E9%93%81%E5%90%AC%E5%88%B0%E7%9A%84%E2%80%9C%E9%98%B2%E7%A9%BA%E8%AD%A6%E6%8A%A5%E5%A3%B0%E2%80%9D/</id>
    <published>2020-06-30T09:21:11.000Z</published>
    <updated>2020-12-13T08:38:52.706Z</updated>
    
    <content type="html"><![CDATA[<p>好了，我不是鸽子，我只是最近突然开始考试了。再一个，闫栋宇这博客的影响力太低，划了半天才遇到这样一个问题。<br> <img src="/old_images/2020/07/1028634298.png" alt="233.png"><br>感谢这位同学，好样的。你的问题我在后面解答了，记得查收。<br>今天考完了信号与系统，下午忽然看到中车长客下线了哈尔滨地铁2号线的第一列电客车，外形样子很有JR的味道，内部LCD很像港铁。挺帅的，可以期待一下。<br>所以挺高兴的，忽然想起来自己应该看看这个博客里面也没有人提问题了，就点进来看了一下。遂琢磨写一篇推送，说点轨交的小东西。开始。<br>提到轨道交通，大家想到的可能是和谐号，复兴号，白色车身，蓝色肩带的钢铁巨龙；或者是拉着汽笛咣啷啷前行的绿皮车。事实上我对轨道交通的兴趣，大概来自于我从小就住在铁路边上，绥满铁路哈尔滨段，也是中东铁路最靠近哈尔滨站的这一段。那时候也没有啥娱乐手段，每天最大的快乐就是看火车。我家门口的铁路桥往北走一点就是著名的滨洲铁路桥，现在已经是个景点了。高中想考同济轨交，没考上，现在换了个地方继续考，我就不信了我还治不了你了。<br>扯远了，说回来。目前的轨道交通是以电气化发展为主的，你们看看自己城市的地铁，没有在用内燃机车或者蒸汽机车的吧，都是电客车。电客车，以电为能源的载客列车，字面意思即可。通常我们认为火车是车头带着一溜车厢走，动力来自于车头，也就是所谓的机车。机车通过电能驱动电机，或者内燃机燃烧燃料带动车轮（这里要注意，为了更好地控制运行速度，相当一部分内燃机车采用电传动，简单来说就是燃烧燃料是为了发电，，电能驱动列车前进，本质上还是电机带动车轮转动），机车通过车钩把力传给后面的车厢，再传给再后面的车厢，一节一节套娃即可。这种模式成为机辆模式，只有机车有动力，后面全是没有动力的拖车。这样的车坐起来的体验比较差。我们可以把一列火车想象成一个高中学动量定理时候常用的简单的物理模型，就是若干物块通过弹簧串联起来。列车停放时，弹簧是松弛的（有空的时候可以给你们讲讲制动的原理，制动靠的是空气，很有意思），机车带动第一节车厢从零加速，第一个弹簧绷直，第一节车厢有速度之后，第二个弹簧绷直，第二节车厢受力开始加速。落实到乘坐体验上，就会在启动的时候忽然觉得自己所在的车厢被一个很大的力撞了一下，车迷俗称“咣一声”。不同车型的体验是不一样的，减震缓冲做的越好这种感觉越微弱，但再微弱也会有。同理，制动的时候也一样。但如果你坐的火车在站内停车的时候忽然向运行反方向抖了一下，紧接着又向运行方向抖了一下，不要慌，这是在进行更换机车的机车连挂作业，也就是换车头。<br>传统的机辆方式很传统，但会带来一些问题。刚才说的乘坐体验是一方面，另一方面就是运行方面的问题了。这样的方式限制了列车的加速性能，毕竟要一节一节地去把车厢从静止“拽”成有速度，且一节机车能提供的总功率有限，很难把运行速度进一步提升，目前普速列车最高的速度等级是Z，最高运行速度也就160左右，拉的越多速度还越慢。这倒也好解决，你一辆机车不够我就加一个呗，俩不够就来仨，是可以的。这样的运行模式下，负责总控制的机车称为本务，剩下那些来帮忙的都叫做补机。这样的方法行倒是行，但也仅仅是“凑合着用”。这里我们引入一个不是很严谨的概念，叫动拖比。为什么不严谨暂且不表，先说它是什么。动拖比，字面意思是动力车和拖车的数量比。比如ICE3，很经典的德国高速动车组，我国CRH3C和CRH380B系列都是以ICE3为原型车的。ICE3为8节编组，4动4拖，即4节车上有电机，其余4节轮子上没有驱动装置（但是制动装置是都有的，安全起见），动拖比就是50%，注意动力车本身也算在拖车总数里。一个数据告诉你德国货多牛逼，50%动拖比的ICE3的总牵引功率，比同样是8辆编组且动拖比75%的CRH2A（以新干线为原型车）要高出将近三分之一，这才叫真正的强劲动力。介绍完动拖比的概念，我们不难理解，对于相同水平的动力配置，动拖比越高的列车功率越高。这就为上述问题提供了一个思路，我能不能把动力单元分散到几个车厢中去，让更多的拖车变成动力车，这样起动性能会更好（因为打破了机辆模式），最高运行速度也会更高（动拖比增加，功率增加）。于是，动车组诞生了（这里暂且不谈动力集中型动车组，也就是垃圾桶，机破之王CR200J）。<br>我们现在看到的动车组都觉得很常见，但这个分散动力单元的思想是很具有跨时代意义的。就像当年被魔改的波音737，把发动机从尾部挪到了大翼悬臂梁下面一样，开创了一个时代。按照这样的定义，其实我们平时坐的地铁也是动车吗？是的。举一个很简单的例子，哈尔滨地铁今天下线的2号线首列电客车，它的动力配置是4动2拖六节编组（1号线也一样，所以我才觉得他俩是一个模子扣的），两端是带控制室的拖车，符号是Tc，第二节和第五节是带受电弓的动车，符号是Mp（p代表受电弓pantograph），第三节第四节则是普通动车，符号是M。提到受电弓，大家可以理解为无轨电车的大辫子，跟它原理上没有任何区别。同理，有些地方可能有轻轨，重庆的单轨，还有一些有轨电车（北京的西郊线，车迷称西溜线，这个故事很有意思，以后可以单拿出来写一篇）等，都可以算是动车的范畴。<br><strong>以下划重点，我来讨论一下图里的问题。先说交流直流。</strong><br>我们知道输电的时候有两种形式，交流和直流。其实这两种电轨道交通都在用，只不过国铁（普速铁路或者高铁动车）用的是交流电（惭愧啊，忘了电压是多少了，好像是3000V吧），城市轨道交通一般用的是直流电。注意是一般，不是全部，这个和设计有关系。区别主要在于用的电机不同，国铁的电力机车或者电力动车组用的都是交流电机，感应电机或者永磁同步电机，而城市轨道交通一般用的是无刷直流电机。有人可能会说无刷直流电机和永磁同步电机本质上没有差别。是的，说的没错，但是用在这个场合里的区别在于，国铁主要承担的是大运量、远距离的运输，需要电机长时间稳定高速运行，而城市轨道交通的站间距相对较短，需要频繁的起动制动，所以在这个语境下把这个电机当成一个直流电机来控制，可以得到很好的快速启动、快速制动特性，加速度可以很大。这就是为什么地铁起动的时候，我们一定好扶好坐稳，因为加速度很大，而坐高铁动车的时候，列车起动可能都没什么感觉，加速很慢，但是加速过程很长。此外，发电厂发出来的电可是交流电，荒山野岭的地方隔几公里就要给高铁修个变电站，咱也得考虑成本啊，修个变压器就得了，再整个整流装置太费钱，干脆你就用交流电吧。但城市轨道交通不同，在城市里一条线路可能也就需要一两个主变电站，对于每公里3亿到7亿的成本，两个大容量整流装置应该用不了几个钱。这就是一种相克相生的关系，我需要长时间稳定高速，就用交流电，但起动性能就差；我需要快速起动快速制动，就用直流电，加速很快，但就麻烦点。这里说一下，这么大功率的电机基本没有用有刷电机的。要是用了我估计得天天换电刷。<br>其实直流交流的区别，上述是业内主要考虑的方面。看到问题里的那个朋友说损耗问题，也有一定道理，确实国铁的线路比较长，高压的交流输电能减少不少损耗，但要知道3000V并不算很高（直接输给受电弓的电压可不是超高压或者特高压的），整个线路的电压都是这个数值，这个电压等级的长距离输电损耗应该也不小，毕竟电压低，所以我个人认为这不是一个主要方面。而且交流和直流相比，如果考虑电缆的集肤效应，同等电压等级的情况下是不是交流的损耗还要高一些？这也是个很有意思的问题，有空可以探讨一下。这个交直流的问题并没有定论，其实也是电客车运用的长期经验反馈给设计者的一种信息。就像舌尖上的中国里的大自然给人类的馈赠一样，倒逼着我们去改进设计，这可能也是工科特有的魅力。<br><strong>好了，现在说说那个“防空警报声”。</strong><br>其实我不说你可能觉得它很陌生，但我要是说“唱歌电机”，你可能就恍然大悟了。是的，就是VVVF，variable voltage variable frequency，变压变频调速，就是那个声音。电机嘛，启动过程中一定要调速控制的，我接触到的电力机车或者电力动车组都是VVVF调速。<br>事实上，不同厂家生产的变流装置发出的声音是不一样的。说到这就不得不提一下三个龙头企业——西门子，阿尔斯通，庞巴迪。这三家企业生产的相关半导体器件制成的变流装置在进行VVVF调速的时候发出的声音是不一样的。防空警报一样的是西门子平台，阿尔斯通和庞巴迪的声音有独特的变化规律，这个区别很明显，每一家公司的产品都很独特，还有其他企业的（比如日立，南车等），但用语言不可描述，感兴趣的话可以来找我，我给你几个B站链接。<br>车迷中有一个群体很喜欢听VVVF声音，有些人可能把它当成asmr了吧。我也喜欢，但我喜欢只是因为我是学电的。再一个，我觉得它很好听。也许工科生不懂浪漫，但工科也有自己的美吧，即使是一段并不具有太大欣赏价值的VVVF声音。<br>今天就说到这吧，我还在等同济轨交院的短信和邮件，不知道我能不能进夏令营。<strong>这篇文章放在这，感谢栋宇给我这个平台，也感谢提问题的这位兄弟，我真的是看见有人提了个问题才决定今天无论如何也要写一篇出来。</strong>轨道交通是一个很冷门的行业，它融合了机械，车辆，空气动力学，能源动力，电气，控制，土木，材料等等很多学科。我自己预测至少30年内传统轮轨还有发展的余地，传统轮轨会向着智能化、自动化、无人化、绝对安全化、绿色节能化、高速和高效化发展。还有一个，就是磁悬浮，那就是另一个故事了。最近胡志强跟我说了有一些想法，觉得轨交这个行业也挺好的。如果可能的话，我也挺希望他能跟我一起去轨交领域开创一片天地出来。<br>调研和问题招募长期有效，欢迎大家对轨道交通领域有什么问题都可以来栋宇的博客下面找我的文章留言，不定期给大家做点硬核科普。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好了，我不是鸽子，我只是最近突然开始考试了。再一个，闫栋宇这博客的影响力太低，划了半天才遇到这样一个问题。&lt;br&gt; &lt;img src=&quot;/old_images/2020/07/1028634298.png&quot; alt=&quot;233.png&quot;&gt;&lt;br&gt;感谢这位同学，好样的。你的问题</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>数字图像处理-课程设计</title>
    <link href="http://example.com/2020/06/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2020/06/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-06-24T01:47:00.000Z</published>
    <updated>2020-12-13T08:46:09.555Z</updated>
    
    <content type="html"><![CDATA[<p>这是2020年春季学期我选的外专业课“数字图像处理”的课程设计，觉得比较有趣，故拿来记录留念。<br>在这门课程中，我第一次对图像处理进行实践，老师讲得非常好，推荐大家选这门课，能学到不少知识。</p><h2 id="课设题目"><a href="#课设题目" class="headerlink" title="课设题目"></a>课设题目</h2><p>天文摄影师常常用照相机对夜晚的天空进行拍摄。v1.avi和v2.avi是两段持续几秒的夜晚天空景象的视频。可以注意到，夜晚较暗的光照使得视频中有明显的噪声。设计一个算法用于去除这两组图像数据中的噪声。<br>根据学过的图像处理知识可知，为了实现通过多帧图像数据获取一幅去除噪声后的图像，一种常用的方法是平均去噪法，即计算多帧图像的平均值。<br>分别计算这两组多帧图像数据的平均值，获得两幅去噪图像。<br>用上述方法可以发现去噪结果并不令人满意，原因是各帧图像间存在一定的偏移。请设计一个算法克服这种偏移同时获得较好的平均法去噪结果。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>以视频中的第一帧为基准，逐帧遍历视频图片，由于图片位移间隔时间小，位移小，可以通过特殊方法获得当前帧图片与第一帧基准图片的相对运动大小，求出变换矩阵，通过变换的逆矩阵反向平移当前帧，即可认为观察者未运动，再使用平均值法去噪即可。<br>由于运动时间短，我们忽略运动的旋转部分，仅考虑平移运动。平移运动为二自由度，因此我们只需要找到两张图中一个对应的特征点，即可求得变换矩阵。</p><h2 id="涉及的-MATLAB-函数"><a href="#涉及的-MATLAB-函数" class="headerlink" title="涉及的 MATLAB 函数"></a>涉及的 MATLAB 函数</h2><p><strong>VideoReader</strong>;<br>用于读取视频中的内容，将其每一帧都读出来。<br><strong>im2double</strong>；<br>将读入的图像转换为浮点形式，便于后期处理。<br><strong>rgb2gray</strong>；<br>将rgb图像转化为灰度图，便于后期处理。<br><strong>strel</strong>；<br>创建形态学操作的构造元素。<br><strong>imerode</strong>；<br>图像形态学腐蚀处理。<br><strong>edge</strong><br>边缘检测。<br><strong>find、max</strong>；<br>求得数组最大值并确定最大值的位置。 </p><h2 id="实验内容与方法"><a href="#实验内容与方法" class="headerlink" title="实验内容与方法"></a>实验内容与方法</h2><p>首先观察两个视频，可以看出，视频中图像含有许多噪声：<br><img src="/old_images/2020/06/2065354894.jpg" alt="Snipaste_2020-06-24_17-44-11.jpg"><br><img src="/old_images/2020/06/1235922839.jpg" alt="Snipaste_2020-06-24_17-44-38.jpg"><br>这些噪声分布均匀且均值基本为0，可以通过均值滤波的方法消除噪声。但是，由于视频拍摄的抖动导致直接进行多帧均值滤波会使运动物体产生模糊，导致滤波效果变差：<br><img src="/old_images/2020/06/4291764818.png" alt="3.png"><br><img src="/old_images/2020/06/4074491988.png" alt="4.png"><br>因此，想到了使用特征点的方法求出前后两帧的相对运动关系，将后一帧移动到前一帧对应的位置，以消除运动产生的影响。<br>首先使用im2double与rgb2gray将图像处理为浮点型的单值图，之后对两段视频分别选择寻找特征点的方法。<br>对于第一个视频，使用缩小范围的寻找特征点的方法，在原图中找到一个sector区域，作为特征点运动的范围。选取这个位置要保证范围内有且仅有一个比较明亮的点，并且在运动过程中这个点不会跑出这个范围。<br>sector = frame(421:472,681:728);<br>处理前的sector<br><img src="/old_images/2020/06/2270251422.png" alt="5.png"><br>对其进行处理，首先进行形态学的腐蚀处理<br>形态学操作可以改变物体形状<br><img src="/old_images/2020/06/3183017928.png" alt="6.png"><br>形态学腐蚀就是求局部最小值的操作<br>se = strel(‘disk’,1);<br>sector = imerode(sector,se);<br>之后使用find函数找到图片中幅值最大的像素，以这个点的位置作为特征点。<br>[x_1,y_1] = find(sector == max(max(sector)));<br>处理后的sector<br><img src="/old_images/2020/06/3043677073.png" alt="8.png"><br>选择这个点作为特征点进行唯一判断。<br>对于第二个视频，我们使用图中月亮的圆心作为特征点。<br>首先对图像进行canny边缘检测：<br>result_frame = edge(frame,’canny’,[0.3,0.5]);<br><img src="/old_images/2020/06/1460216437.png" alt="9.png"><br>Canny边缘检测包含以下四个步骤：<br>1.高斯滤波<br>滤波的主要目的是降噪，一般的图像处理算法都需要先进行降噪。而高斯滤波主要使图像变得平滑（模糊），同时也有可能增大了边缘的宽度。<br>2.计算图片梯度<br>边缘一定就是图像中像素变化较快的区域，因此使用梯度就可以检测出边缘。我们使用sobel算子对图片进行滤波，就可以计算出它的梯度。<br><img src="/old_images/2020/06/385346141.png" alt="10.png"><br>3.过滤非最大值<br>在高斯滤波过程中，边缘有可能被放大了。这个步骤使用一个规则来过滤不是边缘的点，使边缘的宽度尽可能为1个像素点：如果一个像素点属于边缘，那么这个像素点在梯度方向上的梯度值是最大的。否则不是边缘，将灰度值设为0。这样就可以使检测到的边缘始终是一个像素。<br>4.使用上下阈值确定边缘<br>通过给定的上下阈值确定最终哪些地方属于边缘，哪些地方不是。梯度过小的地方不应该是边缘，而梯度过大的地方也不应被视为边缘 。</p><p>想要检测图片中的圆首先想到，可以使用Hough圆变换来求解圆的圆心：<br>首先理解霍夫线变换。霍夫线变换的基本理论，就是二进制图片中每一个点都可能属于某些线。如果将过(x0,y0)的这些条线参数化为一个斜率为a，截距为b的线，由于这条线过这一点，可以将a，b作为变量，画出这个点对应的所有直线参数，在a，b平面中的形式：<br><img src="/old_images/2020/06/2947829010.jpg" alt="Snipaste_2020-06-24_17-49-13.jpg"><br>也是一条直线，并且斜率与截距都是确定的。对于每一个图像中的非零点，都进行这样的操作，并且在a，b平面表示出来。当所有的非零点都表示出来，并进行累加后，a，b平面上数值比较大的点就是原图中可能的直线的参数。<br>同理，霍夫圆变换与直线变换的原理相同，先将圆参数化，只不过这时需要三个参数，得到的参数平面将会是一个三位体中的坐标。这样也是可行的，只不过运算缓慢，通常使用霍夫梯度法来检测圆。圆心是圆所有法线的交汇点，通过梯度，确定这些法线，并求出他们的交点中最有可能的那一个，就能检测到圆心。随后再判断圆心到圆周上点的距离，相同或相近距离数量多，就能确定圆的半径，并且也能检验圆心选择的正确性。<br>在思考过程中，又发现进行完canny边缘检测后，这张图像十分完美，故使用运算更为简便的方法进行圆检测。<br>使用扫描算法检测这个圆的圆心，具体方法为：<br>逐<strong>列</strong>遍历整个图像，若在每一<strong>列</strong>检测到两次白点，计算两个白点之间的距离，所有距离中最长的距离就是圆的直径，这时两个点中间的的那个点就是圆的圆心。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>实验所使用代码（Matlab）如下：<br>对于第一个视频：</p><pre><code>clear,clc;vidobj = VideoReader([&#39;v1&#39; &#39;.avi&#39;]);numFrames = vidobj.NumFrames;sum_frame = zeros(533,800,3);origin_frame = im2double(read(vidobj,1));frame = rgb2gray(origin_frame);sector = frame(421:472,681:728);se = strel(&#39;disk&#39;,1);sector = imerode(sector,se);[x_1,y_1] = find(sector == max(max(sector)));sum_frame = origin_frame;for i = 2:numFrames    origin_frame = im2double(read(vidobj,i));    frame = rgb2gray(origin_frame);    %find offset    sector = frame(421:472,681:728);    se = strel(&#39;disk&#39;,1);    sector = imerode(sector,se);    [x,y] = find(sector == max(max(sector)));    x_offset = x - x_1;    y_offset = y - y_1;    if x_offset &gt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(1:533-x_offset,1:800-y_offset,:) = origin_frame(x_offset+1:533,y_offset+1:800,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(-x_offset+1:533,1:800-y_offset,:) = origin_frame(1:533+x_offset,y_offset+1:800,:);    elseif x_offset &gt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(1:533-x_offset,-y_offset+1:800,:) = origin_frame(x_offset+1:533,1:800+y_offset,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(-x_offset+1:533,-y_offset+1:800,:) = origin_frame(1:533+x_offset,1:800+y_offset,:);    end    sum_frame = sum_frame + origin_frame;endsum_frame = sum_frame/60;imshow(sum_frame);</code></pre><p> 对于第二个视频：</p><pre><code>clear,clc;vidobj = VideoReader([&#39;v2&#39; &#39;.avi&#39;]);numFrames = vidobj.NumFrames;sum_frame = zeros(600,800,3);origin_frame = im2double(read(vidobj,1));frame = rgb2gray(origin_frame);result_frame = edge(frame,&#39;canny&#39;,[0.3,0.5]);%find x,yfor j = 1:600    n = 0;    for k = 1:800        if result_frame(j,k) == 1            n = n+1;            if n == 1                startpoint = k;            else                if k - startpoint &gt; 10                    maxVal(j,1) = k - startpoint;                    maxVal(j,2) = startpoint;                else                    n = n-1;                end            end        end        if k == 800 &amp;&amp; (n == 1 || n == 0)            maxVal(j,1) = 0;            maxVal(j,2) = 0;        end    endendr = max(maxVal(:,1));xpos = find(maxVal(:,1)==r);xpos = int16(median(xpos));ypos = maxVal(xpos,2) + int16(r/2);baseX = xpos;baseY = ypos;sum_frame = origin_frame;for i = 2:numFrames    origin_frame = im2double(read(vidobj,i));    frame = rgb2gray(origin_frame);    result_frame = edge(frame,&#39;canny&#39;,[0.3,0.5]);   %find x,y    for j = 1:600        n = 0;        for k = 1:800            if result_frame(j,k) == 1                n = n+1;                if n == 1                    startpoint = k;                else                    if k - startpoint &gt; 10                        maxVal(j,1) = k - startpoint;                        maxVal(j,2) = startpoint;                    else                        n = n-1;                    end                end            end            if k == 800 &amp;&amp; (n == 1 || n == 0)                maxVal(j,1) = 0;                maxVal(j,2) = 0;            end        end    end    r = max(maxVal(:,1));    xpos = find(maxVal(:,1)==r);    xpos = int16(median(xpos));    ypos = maxVal(xpos,2) + int16(r/2);    x_offset = xpos - baseX;    y_offset = ypos - baseY;     if x_offset &gt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(1:600-x_offset,1:800-y_offset,:) = origin_frame(x_offset+1:600,y_offset+1:800,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &gt; 0        origin_frame(-x_offset+1:600,1:800-y_offset,:) = origin_frame(1:600+x_offset,y_offset+1:800,:);    elseif x_offset &gt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(1:600-x_offset,-y_offset+1:800,:) = origin_frame(x_offset+1:600,1:800+y_offset,:);    elseif x_offset &lt; 0 &amp;&amp; y_offset &lt; 0        origin_frame(-x_offset+1:600,-y_offset+1:800,:) = origin_frame(1:600+x_offset,1:800+y_offset,:);    end    sum_frame = sum_frame + origin_frame;endsum_frame = sum_frame/60;imshow(sum_frame);</code></pre><p>运行结果：<br><img src="/old_images/2020/06/142298572.png" alt="11.png"><br><img src="/old_images/2020/06/2236493176.png" alt="12.png"><br>可以看到，经过处理的图像噪声明显减少，并且并未受到观察者视角移动而出现动态模糊的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是2020年春季学期我选的外专业课“数字图像处理”的课程设计，觉得比较有趣，故拿来记录留念。&lt;br&gt;在这门课程中，我第一次对图像处理进行实践，老师讲得非常好，推荐大家选这门课，能学到不少知识。&lt;/p&gt;
&lt;h2 id=&quot;课设题目&quot;&gt;&lt;a href=&quot;#课设题目&quot; class</summary>
      
    
    
    
    <category term="控制" scheme="http://example.com/categories/%E6%8E%A7%E5%88%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>由LIT MOTORS平衡车获得的理力知识</title>
    <link href="http://example.com/2020/06/18/%E7%94%B1LIT%20MOTORS%E5%B9%B3%E8%A1%A1%E8%BD%A6%E8%8E%B7%E5%BE%97%E7%9A%84%E7%90%86%E5%8A%9B%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2020/06/18/%E7%94%B1LIT%20MOTORS%E5%B9%B3%E8%A1%A1%E8%BD%A6%E8%8E%B7%E5%BE%97%E7%9A%84%E7%90%86%E5%8A%9B%E7%9F%A5%E8%AF%86/</id>
    <published>2020-06-18T04:02:00.000Z</published>
    <updated>2020-12-13T08:41:46.481Z</updated>
    
    <content type="html"><![CDATA[<p>第一次听到Lit Motors平衡车，是在东大四足机器人研讨会上，东大向我们介绍四足平衡的灵感，正是源于Lit Motors。<br>第一次看到，实在是震惊！于是今天再次补习了一下理论力学的知识，希望能给大家讲明白其中的原理。</p><h2 id="角动量与力矩"><a href="#角动量与力矩" class="headerlink" title="角动量与力矩"></a>角动量与力矩</h2><p>根据牛顿第二定律，物体不受力就会保持原有动量，物体受力就会改变动量。<br>在描述刚体平动时，这时十分好用的，因为所有的力都作用在质点上，不会产生旋转，此时刚体每一个微元具有相同的运动形式，所以我们可以把它们看作整体，使用牛顿第二定律进行分析。<br>但是我们发现，当其中有些力作用在质点上时，物体就（可能）会旋转，这时，如果还使用牛顿第二定律，由于每一个微元有不同的运动（速度的大小与方向），再使用牛顿第二定律时会变得十分麻烦（并不是说它就不成立了），物理学家们将旋转的部分单独拿出来，就出现了角动量、力矩的概念：（X代表向量叉乘）<br>角动量：L = J*ω；<br>力矩：  M = r X F；<br>旋转起来的牛顿第二定律就成了物体不受力矩就会保持角动量，物体受到力矩就会改变角动量。</p><p>假设我们有一块土豆，我们怎么对它进行动力学分析呢？<br>首先，这块土豆可能受很多个力，它们大小不同，方向各异。<br><img src="/old_images/2020/06/2328185984.jpg" alt="Snipaste_2020-06-18_20-24-53.jpg"><br>（红色代表质心，蓝色代表力）<br>作用在刚体上的力，在考虑了旋转的情况下，是不能够轻易移动的！我们通过力的合成原理，移动一个力，就会产生一个力偶，也就产生了一个力矩:M = r X F（r为位移向量）<br>我们把力全都移动到土豆的质心，并且将力矩叠加（力矩是可以叠加的！）<br><img src="/old_images/2020/06/679760522.jpg" alt="Snipaste_2020-06-25_19-45-31.jpg"><br>（粉色是合成之后的力矩）<br>作用在一点的力，也可通过力的合成原理，得到一个合力（大概）<br><img src="/old_images/2020/06/2743383745.jpg" alt="Snipaste_2020-06-18_20-41-47.jpg"><br>这个作用在质心的力，确定了质心的平动运动，而这个作用在物体上的力矩，决定了物体的转动运动，我们把土豆的运动<strong>解耦</strong>了！<br>注意，这个旋转是绕质心的旋转，如果旋转时偏心旋转，如下面这个被插了的土豆：<br><img src="/old_images/2020/06/334535609.jpg" alt="Snipaste_2020-06-18_20-46-38.jpg"><br>本身并没有绕着质心旋转，只是质心本身在绕着转轴旋转，这时就只需要考虑质心平动就行了(每个质点都在做圆周运动)。</p><h2 id="角动量守恒与Lit-Motors"><a href="#角动量守恒与Lit-Motors" class="headerlink" title="角动量守恒与Lit Motors"></a>角动量守恒与Lit Motors</h2><p>大家先看一段视频感受一下：<a href="https://www.bilibili.com/video/BV1Ps411U7dM?from=search&seid=13553174638326717597">神奇的自平衡两轮汽车 Lit Motors</a><br>是不是很神奇？学过理论力学的人一定明白它的原理——角动量守恒。</p><p>首先我们来考虑一个简单的问题，为什么陀螺不会倒？<br>静止的陀螺，受到重力与支持力合成产生的力矩，最终一定会倒下：<br><img src="/old_images/2020/06/1785132415.jpg" alt="Snipaste_2020-06-18_20-52-48.jpg"><br>究其根本，正是力矩改变角动量，使其产生了旋转。<br>但是，当陀螺转起来，事情变得有点不一样了!<br>难道转了起来，它的角动量就不变了吗？不是的，无论如何，牛二是不会出错的！<br>只不过，角动量大小没有变（忽略损耗），而是方向变化了，这样也会有一个ΔL！<br><img src="/old_images/2020/06/1821389100.jpg" alt="Snipaste_2020-06-18_20-57-29.jpg"><br>这样，力矩的作用没有使陀螺倒下，而是让陀螺产生了进动！<br>这个例子生动形象地展现了三维世界中角动量定理为我们带来的无限可能与不可思议！</p><p>接着，我们来看Lit Motors的例子<br>先让我们看一看它的主要结构：<br><img src="/old_images/2020/06/3567944637.jpg" alt="Snipaste_2020-06-18_21-00-47.jpg"><br>两个反向旋转的陀螺（飞轮），构成了使其平衡的主要结构。<br><img src="/old_images/2020/06/1955986387.jpg" alt="Snipaste_2020-06-18_21-03-10.jpg"><br>由角动量守恒我们知道，在不受外力矩的情况下，整个系统的角动量是不变的。<br>当我们用内力改变系统某些部分的角动量时，必然会产生另外一个力矩，维持这个角动量不变！<br>我们是用内力（电机）偏转其中一个飞轮，就会产生一个飞轮力矩：<br><img src="/old_images/2020/06/2792304263.jpg" alt="Snipaste_2020-06-18_21-31-16.jpg"><br>两个反向旋转的飞轮同时反向偏转，则抵消掉竖直方向上的力矩，和力矩在前进方向上，就可以防止Roll轴的倾覆！<br><img src="/old_images/2020/06/3236832836.jpg" alt="Snipaste_2020-06-18_21-33-32.jpg"><br>通常使用角度反馈进行闭环控制，实现平衡的功能。<br>这样一想，稚晖君做的这个动量轮倒立摆，其中的原理（动量轮），也是通过内力改变角动量（只不过这次是改变角动量的大小而不是方向），来产生力矩，实现平衡的。<br><img src="/old_images/2020/06/2780367333.jpg" alt="Snipaste_2020-06-18_21-16-14.jpg"><br>只不过这个方法只能抵御周期性扰动，如果扰动带有直流分量，那么系统会一直旋转（加速）。</p><p>东大的四足机器人，则是使用了正交的两套Lit Motors的飞轮装置，使其可以同时保持Roll、Pitch两轴的平衡：<br><img src="/old_images/2020/06/1911627333.jpg" alt="Snipaste_2020-06-18_21-24-03.jpg"></p><p>角动量定理真的能为我们带来许多意想不到的点子，又发现了下面这个好玩的东西，也是这个原理：<br><a href="https://www.bilibili.com/video/BV1qW411i7Mj/?spm_id_from=333.788.videocard.1">神奇立方体 - 可以跳起来、保持平衡和自我运动 @柚子木字幕组</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次听到Lit Motors平衡车，是在东大四足机器人研讨会上，东大向我们介绍四足平衡的灵感，正是源于Lit Motors。&lt;br&gt;第一次看到，实在是震惊！于是今天再次补习了一下理论力学的知识，希望能给大家讲明白其中的原理。&lt;/p&gt;
&lt;h2 id=&quot;角动量与力矩&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="物数" scheme="http://example.com/categories/%E7%89%A9%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>欢迎新的小伙伴加入Star Blog，这里有注册方法哦！</title>
    <link href="http://example.com/2020/06/11/%E6%AC%A2%E8%BF%8E%E6%96%B0%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%8A%A0%E5%85%A5Star%20Blog%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%93%A6%EF%BC%81/"/>
    <id>http://example.com/2020/06/11/%E6%AC%A2%E8%BF%8E%E6%96%B0%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%8A%A0%E5%85%A5Star%20Blog%EF%BC%8C%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%93%A6%EF%BC%81/</id>
    <published>2020-06-11T03:14:00.000Z</published>
    <updated>2020-12-13T08:38:57.578Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎新的小伙伴加入，在这里成为贡献者，分享自己的学习历程，心得体会，感想感言，任何人都可以在这里注册发文哦!<br>当然身为网站管理员，我也会定期检查站内违法言论进行封禁，请大家注意语言文明！<br>由于这是一个阿里学生服务器搭起来的网站，可能会面临资金问题<br>（没错，就是我供不起了（＞人＜；）），到时候会把服务器硬盘内的数据存为硬盘快照分享出来，大家不必担心数据丢失的问题。<br>还有就是本人学识尚浅，对这些问题仍处于学习阶段，在文章中难免有错误之处，如果大家认为内容有误，欢迎前来指正，如果大家在学习中遇到问题，欢迎与我一起讨论。</p><p>大家记得在文章中写出文章的作者是谁哦o(<em>￣▽￣</em>)o</p><p>之后就是最重要的注册方式，看这里！！</p><p><a href="http://www.starydy.xyz/admin/">点我注册！(❤ ω ❤)</a><br><a href="http://www.starydy.xyz/admin/">点我注册！(❤ ω ❤)</a><br><a href="http://www.starydy.xyz/admin/">点我注册！(❤ ω ❤)</a><br><a href="http://www.starydy.xyz/admin/">点我注册！(❤ ω ❤)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎新的小伙伴加入，在这里成为贡献者，分享自己的学习历程，心得体会，感想感言，任何人都可以在这里注册发文哦!&lt;br&gt;当然身为网站管理员，我也会定期检查站内违法言论进行封禁，请大家注意语言文明！&lt;br&gt;由于这是一个阿里学生服务器搭起来的网站，可能会面临资金问题&lt;br&gt;（没错，</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>一个并不无聊的人的加入和调研</title>
    <link href="http://example.com/2020/06/11/%E4%B8%80%E4%B8%AA%E5%B9%B6%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E5%8A%A0%E5%85%A5%E5%92%8C%E8%B0%83%E7%A0%94/"/>
    <id>http://example.com/2020/06/11/%E4%B8%80%E4%B8%AA%E5%B9%B6%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E4%BA%BA%E7%9A%84%E5%8A%A0%E5%85%A5%E5%92%8C%E8%B0%83%E7%A0%94/</id>
    <published>2020-06-10T23:30:33.000Z</published>
    <updated>2020-12-13T08:39:44.257Z</updated>
    
    <content type="html"><![CDATA[<p>嗨！朋友们你们好。<br>因为疫情，我们可能已经有半年没见了。也是因为疫情，好多同学开始开发研究新的技能，比如有些人去学了做饭，而闫栋宇这个B就去搞了个blog自己运营。<br>当他第一次把网址发给我的时候，我还以为是个黄片网站，或者是那种，点开就，是吧，发出不可描述且不可关闭的声音的那种。<br>他说是博客，自己做的blog，当时我的表情大概就像2018年他被抢了回来敲我门一样，满脸写着“忽悠”二字。<br>但后来我还是点开了，心里想着万一是黄色网站，我也不亏（虎狼之词狗头保命）。结果发现真是一个blog，很真实，跟闫栋宇的风格有点不搭，除了满屏的二次元。但有什么事是他干不出来的呢？<br>可能是新年新气象吧。<br>之后的日子里，很偶尔的也打开看一眼，发现这家伙搞的这玩意儿有点东西哦。<br>今天他来找我问了点有关磁场的事情，因为我是电机方向的，就胆战心惊地讲了讲，发现还行没讲错什么东西。<br>他邀请我把这个过程记录下来做成像样的东西发到这个博客上来。我说害，我干嘛写这个，我写我擅长的不好吗。<br>他说也行啊，很欢迎。<br>于是我就来了——<br>大家好，我是Captain，微信和QQ名字是5033，如果你加过我你就会知道我是谁。极其业余的轨道交通和民用航空爱好者，目前在准备同济大学轨交专业的夏令营和考研。收到闫栋宇的邀请，今天开始成为此blog的用户，VIP中P。<br>我目前的专业是电气工程及其自动化，当然我就住在闫栋宇隔壁。如果顺利的话明年这个时候我就是同济的研究生了，铁道与轨道交通研究院或者磁浮中心的某个专业（可能是车辆/机械/交通/载具运用）。如果再顺利一些，可能考虑读个博再。<br>所以我是很忙活的。之所以答应他来写这个，是因为我实在想在复习之余找点事情做。人不能总做一件事情，不然就会变傻。像闫栋宇那样，一直学习，就被劫匪盯上了。<br>今天写这篇文章，是想调研一下各位闫栋宇的用户，也给他做个广告，大家有没有关于轨道交通或者民航方面想知道的东西，或者有没有坐火车坐地铁坐飞机（别跟我抬杠地铁轻轨什么的，这里就是个总称。具体的区别我应该也知道）的时候有什么看见觉得很神奇但又解释不了的事情，请在评论区留言，我会考虑写进我的投稿里。<br>给大家提一些思路吧。比如，为什么铁路下面有的有石头有的没有，为什么地铁供电是直流的而高铁是交流的，为什么地铁起步的时候会有像防空警报一样的声音，为什么铁路还是不能完全的自动驾驶，为什么有的铁路旁边会有一个牌子，上面写着“断”或者“合”。再或者，为什么我的微信QQ名字叫5033，这个数字有什么梗，等等吧。欢迎大家多提问题，能解答的我写进文章里，解答不了的我就去研究。<br>近期也在准备同济轨交的夏令营，这一个月期间会集中去看轨交的知识和专业英语，所以第一篇投稿应该不会很晚问世。<br>如果写得好，我就问闫栋宇要一个专属标签。<br>来吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嗨！朋友们你们好。&lt;br&gt;因为疫情，我们可能已经有半年没见了。也是因为疫情，好多同学开始开发研究新的技能，比如有些人去学了做饭，而闫栋宇这个B就去搞了个blog自己运营。&lt;br&gt;当他第一次把网址发给我的时候，我还以为是个黄片网站，或者是那种，点开就，是吧，发出不可描述且不可</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>电磁学中的物理量</title>
    <link href="http://example.com/2020/06/11/%E7%94%B5%E7%A3%81%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E9%87%8F/"/>
    <id>http://example.com/2020/06/11/%E7%94%B5%E7%A3%81%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E9%87%8F/</id>
    <published>2020-06-10T23:11:00.000Z</published>
    <updated>2020-12-13T08:37:02.619Z</updated>
    
    <content type="html"><![CDATA[<p>感谢6系电机专业的<strong>刘逸舟</strong>同学用生动形象的例子为我讲解了电磁学的基础知识，没有他就没有这篇文章。</p><p>电路中的物理量我们十分熟悉，在电阻上施加电压，就会形成电流。<br>但是对于磁场的各种物理量，能否用类似的“磁路”来进行描述呢？答案是肯定的！</p><p>首先，电能来源于电场，是电子具有的电势能（这个电势能可能来自于化学能——电池，也可能源自于机械能——发电机……等等）进行的释放所产生的能量。那么磁场的能量来自于哪里？<br><img src="/old_images/2020/06/2730705132.jpg" alt="Snipaste_2020-06-11_19-05-22.jpg"><br>由安培环路定律，我们可以发现，电流是产生磁场的方法之一，我们把这个产生磁场的能力定义为磁动势F（永磁体当然也能够产生磁场，因此也具有磁动势），磁动势在磁路中的定位就如同电动势在电路中的定位，具有给予磁场应力的属性。<br><img src="/old_images/2020/06/3332546483.jpg" alt="Snipaste_2020-06-11_18-16-23.jpg"><br>其中I表示电流，N表示线圈匝数，它的单位是 安*匝。<br><img src="/old_images/2020/06/4143798911.jpg" alt="Snipaste_2020-06-11_18-26-45.jpg"><br>有了磁动势，磁场中就会产生出类似电路中电流的东西，这就是磁通Φ；同样能够描述的还有磁感应强度B，它表示单位面积的磁通，更能够描述磁场的散布情况，磁通的单位是韦伯Wb，磁感应强度的单位是特斯拉T。<br><img src="/old_images/2020/06/3579642186.jpg" alt="Snipaste_2020-06-11_18-27-07.jpg"><br>有了电压（磁动势）电流（磁通），磁路中电阻的概念就是磁阻，与电阻类似，可表示成：<br>其中L表示磁路长度，μ表示磁场的，S表示磁通流过的面积。<br><img src="/old_images/2020/06/275706257.jpg" alt="Snipaste_2020-06-11_18-39-42.jpg"><br>又由于介质的存在，实际磁<strong>场</strong>强度H与磁<strong>感应</strong>强度B相差一个系数μ（正是之前的μ），H=μB<br>这样一来，磁动势方程又可以写成：<br><img src="/old_images/2020/06/3831150800.jpg" alt="Snipaste_2020-06-11_18-41-34.jpg"></p><p>磁路是怎样向外界回馈能量的呢？这就涉及到一个电机中经常说到的量了——反电动势<br>我们知道一根通有电流的导线在磁场中会产生力的作用，事实上大部分电机的工作原理就是这个简单的原理。<br><img src="/old_images/2020/06/1085139085.jpg" alt="Snipaste_2020-06-11_18-49-27.jpg"><br>但是如果这根导线仅拥有电流就能产生能量，那岂不是能量不守恒了？为了能让能量守恒，磁场会在移动中的导线（也就是常说的切割磁感线）两端加上一个反电动势，这样一来电流与电动势所产生的功率就是导线受力运动所消耗的功率。<br><img src="/old_images/2020/06/3795421197.jpg" alt="Snipaste_2020-06-11_18-50-15.jpg"><br>后来我们进一步拓展这个公式，就变成了人们熟知的反电势公式：<br><img src="/old_images/2020/06/1930281352.jpg" alt="Snipaste_2020-06-11_18-53-47.jpg"><br>（未归定方向，按一般规定的正方向的话确实应该加一个负号）<br>这个公式说明了反电动势取决于磁通变化率，N代表的仍是线圈匝数，在多匝线圈中，产生的电动势叠加起来，就会产生N倍的效果。<br>研究电机的人觉得这很麻烦，于是就把匝数与磁通合体，就有了我们常提到的磁链ψ。<br><img src="/old_images/2020/06/348952594.jpg" alt="Snipaste_2020-06-11_18-57-42.jpg"><br>于是反电势就与磁链变化率相等了。<br>磁链与电流成正比，这个比例关系就是我们熟知的电感。<br><img src="/old_images/2020/07/3570375741.jpg" alt="Snipaste_2020-07-15_11-24-28.jpg"></p><p>总结一下！<br>磁动势由电流而产生   ————   外界产生磁场的方法（安培环路定律）</p><p>经过磁路中的磁阻生成了磁通  ————  磁场内部的磁芯特性</p><p>磁场与导线相对运动  ————  外界感受磁场存在（法拉第电磁感应定律）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感谢6系电机专业的&lt;strong&gt;刘逸舟&lt;/strong&gt;同学用生动形象的例子为我讲解了电磁学的基础知识，没有他就没有这篇文章。&lt;/p&gt;
&lt;p&gt;电路中的物理量我们十分熟悉，在电阻上施加电压，就会形成电流。&lt;br&gt;但是对于磁场的各种物理量，能否用类似的“磁路”来进行描述呢？答</summary>
      
    
    
    
    <category term="物数" scheme="http://example.com/categories/%E7%89%A9%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>让编译不再麻烦——CMake使用</title>
    <link href="http://example.com/2020/06/10/%E8%AE%A9%E7%BC%96%E8%AF%91%E4%B8%8D%E5%86%8D%E9%BA%BB%E7%83%A6%E2%80%94%E2%80%94CMake%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2020/06/10/%E8%AE%A9%E7%BC%96%E8%AF%91%E4%B8%8D%E5%86%8D%E9%BA%BB%E7%83%A6%E2%80%94%E2%80%94CMake%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-09T21:41:00.000Z</published>
    <updated>2020-12-13T08:46:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家在进行C/C++开发时，经常会遇到项目管理的问题。如果你只有一个源文件，那么这将不是什么难事，一条gcc/g++指令，配合上合适的参数，就能够做得很好。但是对于像这样庞大的工程：<br><img src="/old_images/2020/06/3640866494.jpg" alt="Snipaste_2020-06-10_13-40-06.jpg"><br>每个源文件需要一行编译命令，之后还需要链接，才能编译成二进制可执行文件与库，想着想着，我人都傻了Σ(っ °Д °;)っ<br>幸好有的IDE已经很智能地帮我们做了这一点，我们只需要用图形界面配置好工程中文件的组织形式，引用路径，库的位置，就能够一键编译了。（比如交叉编译IDE 我们熟知的Keil）<br>但是IDE灵活性不足，并且有平台的局限性，不能做到轻量化，在使用VSCode这种不带编译器的编辑器的时候，想要更多地自己配置编译方式，就需要用到我们今天的主角Makefile与CMake了！</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>为了能够自动化地配置工程，完成编译，人们发明了Makefile这样的文件。在含有Makefile文件的目录下执行make命令就可以执行编译动作。使用设定好的编译器，系统会读取Makefile文件的内容进行编译。<br>Makefile按照目标：依赖的结构组织工程，后面紧接着由依赖变化到目标的gcc（g++）命令。使用自动化变量加上自动寻找依赖的机制，Makefile的确使得编译更加方便，但是要写好Makefile，还是离不开gcc（g++）繁琐的语法，同时还要满足Makefile的语法格式。人们又发明了自动生成Makefile文件的工具CMake。<br>##<img src="/old_images/2020/06/2855613712.jpg" alt="Snipaste_2020-06-10_14-42-50.jpg"><br>Makefile的语法</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>想要使用Makefile，一般的Linux系统都会自带Makefile工具。但是CMake需要自行安装。CMake的设计初衷就是使用简单易懂的CMake语法生成晦涩难懂的Makefile语法，使得配置编译设置就像在IDE使用图形化配置一样方便（事实上确实有图形化的CMake——CMake GUI）。<br>在工程目录创建一个CMakeLists.txt文件，并且创建子目录build，用于放置编译生成的中间文件，进入build，执行cmake ..（注意这个..，表示上一级目录），就会生成我们想要的Makefile文件了，相信这个步骤使用源码安装Linux软件的同学都不陌生。</p><p>CMake语句：</p><pre><code>project(main)cmake_minimum_required(VERSION 2.8)</code></pre><p>新建一个CMake项目main，确定cmake需要的最低版本为2.8<br>    set(CMAKE_BUILD_TYPE “Release”)<br>    set(CMAKE_CXX_FLAGS “-O3”)<br>    set(CMAKE_CXX_FLAGS “-std=c++11”)<br>确定编译发布版，优化-o3，C++标准为c++11，set就是进行变量的赋值<br>    set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)<br>    set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)<br>确定输出可执行文件、库文件的位置<br>    find_package(OpenCV REQUIRED)<br>找到系统已经安装的库文件的路径，将其赋值给对应变量。一些比较大的库自己能够告知CMake自己的位置，但是有时就需要我们把FindXXlib.cmake文件告诉CMake（一般库中会提供的）：<br>    list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)<br>确定cmake文件的位置<br>    include_directories(${OpenCV_INCLUDE_DIRS})<br>添加头文件目录，相当于gcc（g++）命令中的-I<br>    add_subdirectory(./src)<br>添加一个子目录，需要保证子目录中有CMakeLists.txt文件，然后就会执行子目录中的CMake文件，用于多个目录的工程。一般在子目录中将源文件编译为库文件，再在根目录的CMake中链接这个库。<br>    add_library(HELLO hello.cpp)<br>    add_executable(main main.cpp)<br>生成一个库、可执行文件，使用源文件（可以是多个），进行编译、链接，生成一个二进制文件，相当于gcc（g++）中的 -o<br>    target_link_libraries(common ${OpenCV_LIBS})<br>给可执行文件链接一个库，这个库可以是绝对路径，也可以是已经放在环境变量中的变量。</p><p>总而言之这就是CMake的基本原理，确实是大大方便了工程项目配置，已经逐渐成为了主流。</p><p>附上在学习高翔老师《视觉SLAM14讲》时使用的CMake文件，留做参考。</p><p>./中的CMakeLists.txt<br>    project(main)<br>    cmake_minimum_required(VERSION 2.8)</p><pre><code>set(CMAKE_BUILD_TYPE &quot;Release&quot;)#set(CMAKE_BUILD_TYPE &quot;Debug&quot;)set(CMAKE_CXX_FLAGS &quot;-O3&quot;)set(CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)set(CMAKE_CXX_FLAGS &quot;-std=c++11 -O2 $&#123;SSE_FLAGS&#125; -g -march=native&quot;)set(G2O_LIBS g2o_core g2o_stuff g2o_types_sba g2o_types_slam3d             g2o_solver_csparse g2o_csparse_extension cholmod g2o_solver_cholmod cxsparse)list(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)find_package(Sophus REQUIRED)find_package(OpenCV REQUIRED)find_package(Pangolin REQUIRED)find_package(Ceres REQUIRED)Find_Package(CSparse REQUIRED)find_package(G2O REQUIRED)include_directories($&#123;G2O_INCLUDE_DIRS&#125;)include_directories( $&#123;CSPARSE_INCLUDE_DIR&#125; )include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)include_directories($&#123;Sophus_INCLUDE_DIRS&#125;)include_directories($&#123;CERES_INCLUDE_DIRS&#125;)include_directories(/usr/include/eigen3)include_directories(./src)include_directories(./include)add_subdirectory(./src)add_executable(main main.cpp)target_link_libraries(main HELLO)target_link_libraries(main common)target_link_libraries(main $&#123;Pangolin_LIBRARIES&#125;)target_link_libraries(main $&#123;OpenCV_LIBS&#125;)target_link_libraries(main $&#123;CERES_LIBRARIES&#125;)target_link_libraries(main $&#123;G2O_LIBS&#125;)</code></pre><p>./src中的CMakeLists.txt<br>    cmake_minimum_required(VERSION 2.8)</p><pre><code>set(CMAKE_BUILD_TYPE &quot;Release&quot;)# set(CMAKE_CXX_FLAGS &quot;-O3&quot;)set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)set(G2O_LIBS g2o_core g2o_stuff g2o_types_sba g2o_types_slam3d             g2o_solver_csparse g2o_csparse_extension cholmod g2o_solver_cholmod cxsparse)list(APPEND CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)find_package(Sophus REQUIRED)find_package(OpenCV REQUIRED)find_package(Pangolin REQUIRED)find_package(Ceres REQUIRED)find_package(G2O REQUIRED)include_directories($&#123;G2O_INCLUDE_DIRS&#125;)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)include_directories($&#123;Sophus_INCLUDE_DIRS&#125;)include_directories($&#123;CERES_INCLUDE_DIRS&#125;)include_directories(/usr/include/eigen3)include_directories(../include)add_library(HELLO hello.cpp)add_library(common common.cpp)target_link_libraries(common $&#123;Pangolin_LIBRARIES&#125;)target_link_libraries(common $&#123;OpenCV_LIBS&#125;)target_link_libraries(common $&#123;CERES_LIBRARIES&#125;)target_link_libraries(common $&#123;G2O_LIBS&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信大家在进行C/C++开发时，经常会遇到项目管理的问题。如果你只有一个源文件，那么这将不是什么难事，一条gcc/g++指令，配合上合适的参数，就能够做得很好。但是对于像这样庞大的工程：&lt;br&gt;&lt;img src=&quot;/old_images/2020/06/3640866494</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>浅尝OpenGL</title>
    <link href="http://example.com/2020/06/05/%E6%B5%85%E5%B0%9DOpenGL/"/>
    <id>http://example.com/2020/06/05/%E6%B5%85%E5%B0%9DOpenGL/</id>
    <published>2020-06-04T18:17:00.000Z</published>
    <updated>2020-12-13T08:43:23.622Z</updated>
    
    <content type="html"><![CDATA[<p>学习了OpenGL的一些基础知识，来分享一下!<br><a href="https://learnopengl-cn.github.io/">Learn OpenGL</a><br>首先，OpenGL到底是什么？<br>OpenGL是API，没错，但OpenGL更被认为是一种标准，然后每个显卡公司，会针对这种标准，编写自己的一套API函数。<br>这就带来了一个麻烦，代码的可以执行问题。对于不同的一套显卡设备，API函数不同，让移植变得很困难。因此，在进行OpenGL开发之前，通常使用一种函数映射的库将硬件对应函数对应到一套公用的函数上，只要使用一套公用的函数API，就能够方便地进行移植（也方便了学习）。因此我们先将glad库（正是负责函数映射库）加入到工程中。配合使用的OpenGl库是glfw库，矩阵运算库选择的是glm库，图片操作库选择的是stb_image库，这些库都需要用户先安装。至此，我们的OpenGL开发环境就搭建完成了。</p><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>OpenGL的最基础元素是顶点元素，三个顶点可以组成一个三角形，构成了最基础的图形，OpenGL的所有图形均是由三角形构成的，这点一定要明确！（即使我想要一个正方形，我也只能通过两个三角形来构建）<br><img src="/old_images/2020/06/4288438894.jpg" alt="Snipaste_2020-06-10_16-55-32.jpg"><br>首先我们通过某种方式（自己定义在内存中、导入各种格式的模型等）得到一个物体的顶点坐标，这个顶点坐标称为局部空间（Local Space），也就是最初物体的坐标，一般将物体坐标放在中央。我们通过坐标变换，对每个顶点进行变换（Model Matrix），让他出现在应该出现的世界坐标的位置，这个变换包括6个自由度，分别确定了物体在世界坐标下的三维位置与姿态（称之为位姿）。之后，需要将这些点再次变换到以摄像机为中心的坐标系下 （View Matrix），以实现摄像机的自由运动。但是这样直接显示在屏幕上，OpenGL会直接去掉这些点的Z坐标，会有一种不真实的感觉（总而言之就是没有近大远小的感觉），我们再使用投影变换，再将结果同时÷Z坐标，将每个平截头体内点变换到屏幕上，这样我们就得到了一个三维点在二维平面上的坐标了，OpenGL将其画出来就行了。（甚至你可以直接使用小孔模型进行变换）<br><img src="/old_images/2020/06/890806100.jpg" alt="Snipaste_2020-06-10_20-03-07.jpg"></p><h2 id="着色器Shader"><a href="#着色器Shader" class="headerlink" title="着色器Shader"></a>着色器Shader</h2><p>机器是如何把图像画出来的呢？学习OpenGL，其中重要的一点就是学习Shader的编程（GLSL语言）以及它的工作流程（渲染流水线）<br>下面这张图展示了渲染流水线的工作流程：<br><img src="/old_images/2020/06/1099674099.jpg" alt="Snipaste_2020-06-10_16-52-24.jpg"><br>上图每一个着色器对应一个shader文件，但是大部分情况下我们只需要顶点着色器（VERTEX SHADER，简称为VS）和片段着色器（FRAGMENT SHADER，简称为FS）即可，顶点着色器用于绘制点，片段着色器用于绘制光栅化后三角形内每一个像素的颜色。<br>我们在程序里使用API函数编译、链接这些SHADER文件，构成一个SHADER项目，供我们在渲染中使用（SHADER是跑在GPU中的！）。<br>VS接受程序存在内存中的点的坐标（不只是位置，还可以包括颜色、法向量等其他属性），对其进行坐标变换，将结果送入FS，FS接受VS处理的结果，并在整个三角形中对接收数据进行插值，<strong>相当于接收到的数据不再是三个顶点而是光栅化后的三角形内的许多像素</strong>，再依据程序对这些像素进行运算（需要GPU并行加速），输出每个像素的颜色，进行渲染。</p><h2 id="光照与纹理"><a href="#光照与纹理" class="headerlink" title="光照与纹理"></a>光照与纹理</h2><p>有了上面的基础，在OpenGL中实现光照效果就很简单了（因为我们已经知道如何操作每一个像素的颜色），重中之重在于找到合适的光照模型：<br>在这里我们使用冯氏光照模型，一个物体的颜色由三个分量加权得到：<br><img src="/old_images/2020/06/2875422330.jpg" alt="Snipaste_2020-06-10_20-32-35.jpg"><br>ambient：环境光<br>占有分量最少，描述的是物体在完全黑暗处由于极少量反射呈现的颜色。颜色取决于物体颜色。<br>diffuse：漫反射<br>占有分量最多，强度大小由光源向量与面的法向量的内积确定。颜色取决于物体颜色。<br><img src="/old_images/2020/06/1829637362.jpg" alt="Snipaste_2020-06-10_20-37-22.jpg"><br>specular：镜面反射<br>占有份量也比较多，强度大小取决于反射后的光线向量与<strong>视角向量</strong>的内积。颜色同时取决于光源颜色与物体颜色。<br><img src="/old_images/2020/06/4103478537.jpg" alt="Snipaste_2020-06-10_20-37-13.jpg"></p><p>由于FS中获得的是VS传来值的插值，也就能够获得每个像素点的坐标，因此在FS中进行光照计算能够使得光照更加真实，但是运算量也会更大。</p><p>这样一来，每个像素经过渲染流水线就能够产生一个特定的颜色，显示在我们的屏幕上。</p><p>最后我们就可以实现一些简单的渲染啦，不要说我技能点点歪了，学习渲染也可以图形化一些问题，也是解题的一大工具呢！</p><p>将我的一个入门小项目源码放在这里供大家学习：</p><pre><code>#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &quot;shader.h&quot;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot;using namespace std;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;float deltaTime = 0.0f; // 当前帧与上一帧的时间差float lastFrame = 0.0f; // 上一帧的时间float vertices[] = &#123;    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f&#125;;glm::vec3 cubePositions[] = &#123;  glm::vec3( 0.0f,  0.0f,  0.0f),   glm::vec3( 2.0f,  5.0f, -15.0f),   glm::vec3(-1.5f, -2.2f, -2.5f),    glm::vec3(-3.8f, -2.0f, -12.3f),    glm::vec3( 2.4f, -0.4f, -3.5f),    glm::vec3(-1.7f,  3.0f, -7.5f),    glm::vec3( 1.3f, -2.0f, -2.5f),    glm::vec3( 1.5f,  2.0f, -2.5f),   glm::vec3( 1.5f,  0.2f, -1.5f),   glm::vec3(-1.3f,  1.0f, -1.5f)  &#125;;// unsigned int indices[] = &#123;//     0, 1, 3,//     1, 2, 3// &#125;;unsigned int VAO,lightVAO;unsigned int VBO, EBO;unsigned int texture0;int vertexColorLocation;int pic_width,pic_height,nrChannels;//cameraglm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);glm::mat4 Up_rotate_p = glm::mat4(1.0f);glm::mat4 Up_rotate_n = glm::mat4(1.0f);;float lastX = 400, lastY = 300;float yaw,pitch,fov = 45.0f;int main()&#123;    // glfw: initialize and configure    // ------------------------------    glfwInit();    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    // glfw window creation    // --------------------    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);    if (window == NULL)    &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window);    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // glad: load all OpenGL function pointers    // ---------------------------------------    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))    &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;    //mouse    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);    glfwSetCursorPosCallback(window, mouse_callback);    glfwSetScrollCallback(window, scroll_callback);    //texture    glGenTextures(1, &amp;texture0);    glBindTexture(GL_TEXTURE_2D, texture0);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);           //x轴扩充方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);           //y轴扩充方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);       //缩小插值方法    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);       //放大插值方法    stbi_set_flip_vertically_on_load(true);    unsigned char *data0 = stbi_load(&quot;girls.jpg&quot;, &amp;pic_width, &amp;pic_height, &amp;nrChannels, 0);    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, pic_width, pic_height, 0, GL_RGB, GL_UNSIGNED_BYTE, data0);    glGenerateMipmap(GL_TEXTURE_2D);                                        //自动多级渐远    stbi_image_free(data0);    //shader compile to program    //using shader class    //不能是全局变量，由于构造时未初始化    Shader main_shader(&quot;./shaders/box.vs&quot;,&quot;./shaders/box.fs&quot;);    //vertices    glGenVertexArrays(1, &amp;VAO);             //generate VAO    glGenBuffers(1, &amp;VBO);                  //generate VBO    //glGenBuffers(1, &amp;EBO);                  //generate EBO    glBindVertexArray(VAO);                 //bind VAO    glBindBuffer(GL_ARRAY_BUFFER, VBO);     //bind VBO    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);    // glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));    glEnableVertexAttribArray(1);    //VBO -&gt; VAO 之后只须绑定VAO即可    glBindBuffer(GL_ARRAY_BUFFER, 0);       //unbind VBO    glBindVertexArray(0);                   //unbind VAO    //light    glGenVertexArrays(1, &amp;lightVAO);     glBindVertexArray(lightVAO);    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    // render loop    // -----------    while (!glfwWindowShouldClose(window))    &#123;        float currentFrame = glfwGetTime();        deltaTime = currentFrame - lastFrame;        lastFrame = currentFrame;        // input        // -----        processInput(window);        //预处理        glm::mat4 model = glm::mat4(1.0f);        model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(1.0, 0.0, 0.5));        //清屏 清除Z缓冲        glClearColor(0.8f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        //渲染        main_shader.use();        //main_shader.setVec4(&quot;ourColor&quot;,0.3f,0.1f,0.7f,1.0f);        main_shader.setInt(&quot;texture0&quot;, 0);        glEnable(GL_DEPTH_TEST);                    //开启Z缓冲        glActiveTexture(GL_TEXTURE0);               //在绑定纹理之前先激活纹理单元        glBindTexture(GL_TEXTURE_2D, texture0);        glBindVertexArray(VAO);        glm::vec3 front;        front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));        front.y = sin(glm::radians(pitch));        front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));        cameraFront = glm::normalize(front);        //trans        glm::mat4 view = glm::mat4(1.0f);;        view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);        main_shader.setMat4(&quot;view&quot;, view);        Up_rotate_p = glm::rotate(Up_rotate_p, glm::radians(0.2f*deltaTime),  cameraFront);        Up_rotate_n = glm::rotate(Up_rotate_n, glm::radians(-0.2f*deltaTime), cameraFront);        glm::mat4 project = glm::mat4(1.0f);        project = glm::perspective&lt;float&gt;(glm::radians(fov), (SCR_WIDTH/SCR_HEIGHT), 0.1f, 100.0f);        main_shader.setMat4(&quot;project&quot;, project);        for (unsigned int i = 0; i &lt; 10; i++)        &#123;            // calculate the model matrix for each object and pass it to shader before drawing            glm::mat4 model = glm::mat4(1.0f);            model = glm::translate(model, cubePositions[i]);            float angle = 20.0f * i;            model = glm::rotate(model, glm::radians(angle+(float)(glfwGetTime()*60)), glm::vec3(1.0f, 0.3f, 0.5f));            main_shader.setMat4(&quot;model&quot;, model);            glDrawArrays(GL_TRIANGLES, 0, 36);        &#125;        glDrawArrays(GL_TRIANGLES, 0, 36);        glBindVertexArray(0);        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)        // -------------------------------------------------------------------------------        glfwSwapBuffers(window);        glfwPollEvents();    &#125;    // optional: de-allocate all resources once they&#39;ve outlived their purpose:    // ------------------------------------------------------------------------    glDeleteVertexArrays(1, &amp;VAO);    glDeleteBuffers(1, &amp;VBO);    // glfw: terminate, clearing all previously allocated GLFW resources.    // ------------------------------------------------------------------    glfwTerminate();    return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123;    float cameraSpeed = 3.0f * deltaTime;    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)        cameraPos += cameraSpeed * cameraFront;    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)        cameraPos -= cameraSpeed * cameraFront;    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;    if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS)        &#123;            glm::vec4 cameraUp4 = Up_rotate_p * glm::vec4(cameraUp,1.0f);            cameraUp = glm::vec3(cameraUp4.x,cameraUp4.y,cameraUp4.z);        &#125;    if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)        &#123;            glm::vec4 cameraUp4 = Up_rotate_n * glm::vec4(cameraUp,1.0f);            cameraUp = glm::vec3(cameraUp4.x,cameraUp4.y,cameraUp4.z);        &#125;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123;    // make sure the viewport matches the new window dimensions; note that width and     // height will be significantly larger than specified on retina displays.    glViewport(0, 0, width, height);&#125;void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123;    float xoffset = xpos - lastX;    float yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的    lastX = xpos;    lastY = ypos;    float sensitivity = 0.05f;    xoffset *= sensitivity;    yoffset *= sensitivity;    yaw   += xoffset;    pitch += yoffset;    if(pitch &gt; 89.0f)        pitch =  89.0f;    if(pitch &lt; -89.0f)        pitch = -89.0f;&#125;void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123;  if(fov &gt;= 1.0f &amp;&amp; fov &lt;= 45.0f)    fov -= yoffset;  if(fov &lt;= 1.0f)    fov = 1.0f;  if(fov &gt;= 45.0f)    fov = 45.0f;&#125;</code></pre><p>使用的Makefile：</p><pre><code>INCLUDE_PATH = ./includeSOURCE_PATH = ./srcOBJECT = main.o glad.oLIBS = -lglfw3 -lGL -lGLU -ldl -lX11 -lpthread++ = g++CC = gccmain:$(OBJECT)    $(++) -I$(INCLUDE_PATH) -o main $(OBJECT) $(LIBS)main.o:main.cpp    $(++) -I$(INCLUDE_PATH) -c main.cppglad.o:$(SOURCE_PATH)/glad.c    $(CC) -I$(INCLUDE_PATH) -c $(SOURCE_PATH)/glad.cclean:    rm *.o    rm main</code></pre><p><img src="/old_images/2020/09/3319805378.png" alt="QQ图片20200914195150.png"><br><img src="/old_images/2020/09/2082677778.png" alt="QQ图片20200914195155.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习了OpenGL的一些基础知识，来分享一下!&lt;br&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;Learn OpenGL&lt;/a&gt;&lt;br&gt;首先，OpenGL到底是什么？&lt;br&gt;OpenGL是API，没错，但OpenGL更被认为是一</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP协议最常见的两种请求方法</title>
    <link href="http://example.com/2020/05/14/HTTP%E5%8D%8F%E8%AE%AE%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/05/14/HTTP%E5%8D%8F%E8%AE%AE%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-14T01:25:00.000Z</published>
    <updated>2020-12-13T08:44:09.608Z</updated>
    
    <content type="html"><![CDATA[<p>运行在网络中的诸多协议，组成了你生活中所有网络应用的基础。这些应用层协议常见的有如下几种：</p><ol><li>http：最常见的协议，实现超文本传输，浏览器中文本图像在服务器与客户端之间传递；</li><li>ssh：安全shell，远程连接服务器的shell；</li><li>ftp：远程文件系统；</li><li>dns：域名解析；</li><li>smtp：邮件协议；<br>等等等等……</li></ol><p>只要掌握了这些协议的内部原理，我们就可以随意操作实现功能了。<br>这次我们来讲一下使用python的requests库实现http协议的请求<br>http协议通过客户端（浏览器）向服务器发出请求，服务器相应这些请求，文字，图像就能够显示在我们的浏览器上了！<br>这些请求有如下几种：<br><img src="/old_images/2020/05/1596536276.jpg" alt="Snipaste_2020-05-14_16-43-46.jpg"><br>我们主要讲解两种最常见的——GET、POST</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>GET请求是一种显式传递信息的方式，通常用于获取服务器发来的数据而做出请求。<br>常见发起GET请求的方式就是URL。<br>我们在浏览器中输入一个URL，点击访问，就是发起了一次GET请求<br>GET请求的内容通常是直接显式地显示在URL后面，以?分隔的。<br>GET返回的内容就会被浏览器理解，显示在界面上了：<br>使用浏览器自带的抓包工具，我们来看一下GET请求与响应都是什么样的<br><img src="/old_images/2020/05/1113348697.jpg" alt="Snipaste_2020-05-14_16-52-41.jpg"><br>点开B站的一瞬间，扑面而来的GET请求瞬间刷屏，当然这些都是第一个GET所带来的连锁反应<br><img src="/old_images/2020/05/330527918.jpg" alt="Snipaste_2020-05-14_16-54-24.jpg"><br>首先General中告诉我们这是一个GET，目标URL是B站，IP也可以看见，status code就是状态码，200表示成功<br>大家常见的404、502也是状态码：        <a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">关于状态码详细——百度百科</a><br><img src="/old_images/2020/05/1088359098.jpg" alt="Snipaste_2020-05-14_16-56-30.jpg"><br>后面接着是Request Header，请求头，是我们发给服务器的数据：<br><img src="/old_images/2020/05/3068723404.jpg" alt="Snipaste_2020-05-14_16-58-34.jpg"><br>这其中包含着语言、所用浏览器、操作系统、编码方式等等，服务器拿到这些数据进行分析，来给你做出响应（反-反爬虫最基本的就是伪造请求头(●ˇ∀ˇ●)）<br>当然这里面最重要的是cookie信息，它保存着我的登录信息，利用cookie就可以实现免重复登陆的功能。<br>B站接到这个请求后，会进行处理，返回给我们一个Response Header：<br><img src="/old_images/2020/05/2576890486.jpg" alt="Snipaste_2020-05-14_17-02-55.jpg"><br>还有Response的内容，也就是B站主站的index.html，通过这个html我们就知道接下来该去哪些URL去GET些什么了。<br><img src="/old_images/2020/05/2978689860.jpg" alt="Snipaste_2020-05-14_17-31-24.jpg"><br>接下来，就是一系列GET来搭建出整个网站所呈现出的样子，比如一些图片啊、script啊之类的。至此，通过一系列的GET我们访问到了B站。</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>当我们想去向服务器传递内容时，比如登陆时传递用户名密码，发送弹幕、评论，该如何发送请求呢？这时就需要POST登场了。<br>与GET不同，POST是一种隐含的信息传递方式，因此它更安全，适合向服务器传递隐私内容。<br>常见发起POST请求的是FORM表单。<br>这次我们以发送弹幕为例来看看POST是如何工作的：<br><img src="/old_images/2020/05/1187310326.jpg" alt="Snipaste_2020-05-14_17-18-41.jpg"><br>点击发送弹幕，发现，我们确实发出了一次POST请求（忽略下面这个failed的GET）<br>除了Request Header和Response，我们发现，POST还多了一个Form Data表单：<br><img src="/old_images/2020/05/910319602.jpg" alt="Snipaste_2020-05-14_17-22-29.jpg"><br>这个Form Data中就保存了我们要传递给服务器的数据，比如弹幕的字体大小、颜色、内容、发送时间、BV号等等。<br>服务器接收到这样的POST请求，就能做出反应（在视频上显示出该弹幕），同样，评论与登录也是一个道理。<br>得到的Response也挺有趣的(/▽＼)<br><img src="/old_images/2020/05/963849757.jpg" alt="Snipaste_2020-05-14_17-25-22.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;运行在网络中的诸多协议，组成了你生活中所有网络应用的基础。这些应用层协议常见的有如下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;http：最常见的协议，实现超文本传输，浏览器中文本图像在服务器与客户端之间传递；&lt;/li&gt;
&lt;li&gt;ssh：安全shell，远程连接服务器的shell；&lt;</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>双系统？虚拟机？Docker？</title>
    <link href="http://example.com/2020/05/10/%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9FDocker%EF%BC%9F/"/>
    <id>http://example.com/2020/05/10/%E5%8F%8C%E7%B3%BB%E7%BB%9F%EF%BC%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9FDocker%EF%BC%9F/</id>
    <published>2020-05-10T00:20:00.000Z</published>
    <updated>2020-12-13T08:45:21.385Z</updated>
    
    <content type="html"><![CDATA[<p>Linux环境由于它可移植性强，轻量化，底层化的特点，得到了开发者们广泛的应用。<br>它在服务器市场，移动嵌入式市场，机器人领域有着重要的应用。<br>但是，有的应用对Linux支持很不友好（腾讯，说的就是你！），甚至没有Linux版本，这时候就需要另外一个Windows环境来运行Windows程序，这是，两个环境之间的切换就成了问题。</p><p>今天我们来讨论一下在一台机器上运行Windows环境与Linux环境的方法。</p><h2 id="为什么程序对操作系统环境有要求"><a href="#为什么程序对操作系统环境有要求" class="headerlink" title="为什么程序对操作系统环境有要求"></a>为什么程序对操作系统环境有要求</h2><p>首先，我们抛出一个问题，是不是所有程序运行都需要操作系统的支持？<br>紧接着，又有几个问题，为什么Linux下编译的程序不能再Windows环境下运行，反之也不行呢？</p><p>对于第一个问题，不是所有程序都需要操作系统才能够运行，最常见的，<strong>单片机</strong>里跑的程序，<strong>U-Boot</strong>、<strong>grub</strong>这样的引导操作系统程序，还有<strong>操作系统本身</strong>，这些都是不需要运行在操作系统环境下运行的，我们称之为裸机程序。<br>逻辑程序唯一要求的，就是芯片的架构。ARM、x86、RISC-V架构的芯片跑的一定不是相同的程序。这也就是操作系统需要对不同架构芯片做版本移植的原因。</p><p>第一点就是编译器的问题。不同的操作系统，有不同的内核提供的系统调用，这就对应着不同的编译器，才能编译不同操作系统下的程序。默认的编译器总是编译自己操作系统的代码，如果想编译运行在其他操作系统的代码，就需要交叉编译工具链（编译器、链接器……）<br><img src="/old_images/2020/05/3174243626.jpg" alt="Snipaste_2020-05-10_16-59-38.jpg"><br>平时一点就ok的按钮，其实就使用了交叉编译工具链，这就是IDE的力量(。・∀・)ノ</p><p>还有就是库的问题。Win下动态链接库是.dll文件，静态链接库则是.lib文件，目标文件是.obj，而在Linux下，对应的分别是.so，.a，.o文件。<br>最终一点，可执行文件格式也不同，Win是大家耳熟能详的.exe文件，而Linux没有特定的后缀名。<br>最后两点本质上也是由于编译器、链接器不同导致生成的文件格式也不同。</p><h2 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h2><p>解决方案一：双系统，最简单粗暴的方法，在一台电脑中安装两个操作系统。方便的是拥有完整的环境，操作系统可享用完整的计算机资源，缺点则是切换麻烦，文件传输麻烦，多个操作系统不能同时工作。<br>这里还要注意的是，操作系统的引导是由引导程序来进行的。BIOS会<strong>按顺序</strong>对每个硬盘分区最前面的区域进行查找，如果找到了引导程序，就执行它。如果不想启动先被找到的操作系统，则由引导程序将启动权交给下个分区内的引导程序。不过，由于Windows自带的引导程序无法启动Linux，但是grub却可以启动Windows，所以需要先安装Windows再安装Linux，否则Linux的引导会被覆盖。</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><img src="/old_images/2020/05/3462557488.png" alt="vm-logo.png"><br>解决方案二：虚拟机（VMWare）。虚拟机的具体实现需要OS的知识才能够理解，本菜鸡就不做过多解释了，总之可以理解为这是一个应用程序，在应用程序内又跑着一个操作系统。<br>虚拟机的优势就在于两个操作系统可以同时运行，交互良好（可以互相传文件），缺点就是两个操作系统共同占有一块计算机资源，性能下降，并且还有虚拟机对显卡支持不好的缺点。<br><img src="/old_images/2020/05/904172395.jpg" alt="v2-ee27d299f5e38ed460218ac087518bba_720w.jpg"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="/old_images/2020/05/1820938573.jpg" alt="u=3999212251,2537480795&amp;fm=74&amp;app=80&amp;f=JPEG&amp;size=f121,90.jpg"><br>与虚拟机类似，Docker也是跑在宿主OS中的程序（更准确是<strong>容器</strong>）<br>这个<strong>容器</strong>能够隔离内部程序与操作系统，且内部不需要安装操作系统，就能跨平台运行程序，上手容易，轻量化，很好用！<br><img src="/old_images/2020/05/3518464858.jpg" alt="v2-0d67e01d75d19e227fb44104eca28f43_720w.jpg"></p><p>对比Docker与虚拟机<br><img src="/old_images/2020/05/1170183205.png" alt="20180711090727241.png"><br><img src="/old_images/2020/05/664969895.png" alt="20180711094611205.png"></p><h2 id="基于Docker的人工智能小助手艾拉"><a href="#基于Docker的人工智能小助手艾拉" class="headerlink" title="基于Docker的人工智能小助手艾拉"></a>基于Docker的人工智能小助手艾拉</h2><p>前几天突然心血来潮，拿图灵机器人+酷Q做了一个简单的人工智障小助手，结果发现酷Q只能在Win下运行，想尽一切办法最终发现酷Q有一个on docker版本，赶紧拿来使用。几行命令，这个人工智障就已经跑在我的Linux服务器下了。这个Docker使用VNC远程桌面作为图形界面交互，我把它放在了我服务器的7070端口，进入VNC界面，你就会发现里面是一个实打实的Windows环境。</p><p>具体命令见这篇：<a href="https://www.vpsjxw.com/vps_use/kuq_docker/">酷Q on docker 安装部署、使用及二次开发教程</a></p><p><img src="/old_images/2020/05/2761601438.jpg" alt="Snipaste_2020-05-10_17-35-21.jpg"><br><img src="/old_images/2020/05/1424232658.jpg" alt="Snipaste_2020-05-10_17-34-58.jpg"></p><p>顺便吐槽一下，现在的腾讯对QQ的外部接口是越来越不上心了，果然微信才是主流嘛……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux环境由于它可移植性强，轻量化，底层化的特点，得到了开发者们广泛的应用。&lt;br&gt;它在服务器市场，移动嵌入式市场，机器人领域有着重要的应用。&lt;br&gt;但是，有的应用对Linux支持很不友好（腾讯，说的就是你！），甚至没有Linux版本，这时候就需要另外一个Windows</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>浅浅浅浅浅谈计算机求数值解的方法</title>
    <link href="http://example.com/2020/05/09/%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B1%82%E6%95%B0%E5%80%BC%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/05/09/%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B1%82%E6%95%B0%E5%80%BC%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-08T23:01:00.000Z</published>
    <updated>2020-12-13T08:43:41.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>之前最小二乘的那篇文章中，我们知道了最优化的最基本方法就是求出cost function的极值点。<br>对于简单的、已知表达式的cost function（就比如最小二乘），我们可以直接通过偏导数等零的方法求得极值点。<br>但是对于表达式复杂、甚至无法获取表达式的cost function，求偏导的方法就无能为力了，我们只能借助计算机这个不是很聪明但是算的很快的工具，通过迭代的方法，求出极值点的近似解。</p><p>怎么个迭代法呢？<br>极小值点，就是附近一片区域中函数值最小的那一个点，将函数看作一块地面，我们如果在极小值附近区域放上一个小球，小球一定可以滚落到极小值点的位置。如果我们使用计算机来模拟这个小球的行为，不就能够得到极小值点了吗<br>伟大的科学家们利用这个原理，发明了梯度下降的方法来求解极小值点：</p><ol><li>将一个初始点送入梯度下降算法（小球放在初始某个位置）</li><li>使用差分代替微分，求出初始点位置函数的梯度（地面的梯度方向即为小球下降趋势的方向）</li><li>使当前这个点向梯度<strong>反方向</strong>前进，速度为梯度大小，时间为步长τ，得到一个新的点（<strong>近似</strong>模拟小球下降的过程）</li><li>将新得到的点作为起始点，重复执行此过程，直到梯度大小小于某个阈值δ，停止迭代，得到结果（小球稳定在地面的最低点处）<br><img src="/old_images/2020/05/4174507093.gif" alt="v2-05bafbc0557270f96773e544b2ae683e_hd (1).gif"></li></ol><p>实际上这是一个很简单的算法，我们只需要规定步长τ与阈值δ就能求出函数的极值点<br>其中，步长τ越大，算法收敛的也就越快，但是在步长过大时可能出现在极值点附近震荡而无法进入阈值范围而陷入死循环；<br>而阈值δ越大，限制条件相当于越宽松，收敛也会更容易，但是精度相对变差，δ越小则反之。</p><p>这个简单的算法也有着诸多限制条件：</p><ol><li>目标函数的点的细度一定要足够，否则求取梯度会不精确，极值点的精度也会变差，必要时可能需要插值</li><li>目标函数在一定范围内一定要平滑，即梯度函数要连续，不能出现梯度的突变，否则不能收敛</li><li>目标函数在一定范围内一定要连续</li><li>没有全局性。可能会求得局部极小值，即最优化问题中的局部最优解</li></ol><p><img src="/old_images/2020/05/3433924516.png" alt="无标题.png"></p><h2 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h2><p>同梯度下降法一样得思路，牛顿迭代法是用来解决方程的解的问题的</p><p>我们通过对f(x)的迭代，可以的出一元方程f(x) = 0的近似数值解，方法如下：</p><ol><li>同样，选取起始点</li><li>求出起始点位置函数f(x)导数</li><li>向着导数反方向移动该点，步长τ，得到新的点</li><li>将新点当作初始点，迭代运算，直至新点处函数值小于阈值δ，得到方程近似解<br><img src="/old_images/2020/05/557249455.jpg" alt="f703738da97739126a4f98f3ff198618367ae233.jpg"></li></ol><p>可以看到梯度下降与牛顿迭代具有很强的相似性，二者的方法与性质也大体类似，本质上，二者都是通过对f(x)泰勒展开式进行近似（取一阶导数项），通过近似式进行迭代求解。这种迭代求数值解的思想值得我们借鉴与学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;梯度下降法&quot;&gt;&lt;a href=&quot;#梯度下降法&quot; class=&quot;headerlink&quot; title=&quot;梯度下降法&quot;&gt;&lt;/a&gt;梯度下降法&lt;/h2&gt;&lt;p&gt;之前最小二乘的那篇文章中，我们知道了最优化的最基本方法就是求出cost function的极值点。&lt;br&gt;对于简单的</summary>
      
    
    
    
    <category term="物数" scheme="http://example.com/categories/%E7%89%A9%E6%95%B0/"/>
    
    
  </entry>
  
</feed>
